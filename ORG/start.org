#-*- mode: org -*-
#+STARTUP: content
#+TODO: TODO DONE

* Pathes
** org files
[[file:weekly.org][weekly file]]
[[file:todo_plan.org][ToDo Plan org]]
[[file:monthly.org][Monthly file]]
[[file:GTD.org][GTD file]]
[[file:~/ORG/gtd/inbox.org][Inbox GTD File]]
[[file:~/ORG/gtd/tickler.org][Tikler Todo File]]
[[file:today.org][Today org file]]

(find-file "d:/My_Docs/Ofice/PaperFlow/TODO/todo_plan.org")
(find-file "d:/My_Docs/Ofice/PaperFlow/TODO/weekly.org")
(find-file "d:/My_Docs/Ofice/PaperFlow/TODO/monthly.org")
(find-file "d:/My_Docs/Ofice/PaperFlow/TODO/GTD.org")
(find-file "d:/My_Docs/Ofice/PaperFlow/TODO/today.org")

(find-file "~/ORG/gtd/gtd.org")
(find-file "~/ORG/gtd/inbox.org")
(find-file "~/ORG/gtd/tickler.org")
** init files
(find-file "~/INI/init.el")
(find-file "~/INI/inpak.el")
(find-file "~/INI/frame-control.el")
(find-file "~/INI/vanila_cfg.el")
(find-file "~/INI/c-mode-cfg.el")
(find-file "~/INI/evil-mod-cfg.el")
    (find-file "~/INI/origami_cfg.el")
(find-file "~/INI/init.el")
* Команды
** init files
(load "~/INI/evil-mod-cfg.el")
(load "~/INI/frame-control.el")
(load "~/INI/vanila_cfg.el")
(load "~/INI/origami_cfg.el")
** открыть
(find-file-other-frame "d:/My_Docs/Ofice/PaperFlow/TODO/todo.org")
(org-agenda nil "a")

** линкс команды
   C+c C+o
	[[shell:echo%20"hi%20Max"][Hello?]]
	[[shell:dir][Whera are u?]]
[[
shell:echo "dfgdfg max"
] [
Working?
]]
[[shell:echo "dfgdfg max"][Working?]]

[[shell:echo "dfgdfg max"]
[Working?]]
**  сорс комады
   C+c C+c
#+BEGIN_SRC sh :shcmd "cmdproxy.exe"
dir
#+END_SRC
#+BEGIN_SRC sh :exports both
ls
#+END_SRC
** Install
tar not found when trying to install from melpa 
You probably have an outdated package database
(package-refresh-contents)
(package-install company-irony)
** setings
*** systems paths
(setq exec-path (append exec-path '("D:/Development/CPP/CMake/bin/")))
	неменяет системную переменую только переменая емака взятая при запуске
(setenv "PATH" (concat (getenv "PATH") ";c:\\sw\\bin"))
(setq exec-path (append exec-path '("d:/sw/bin")))
	;; example of setting env var named “path”, by appending a new path to existing path

(setenv "PATH"
  (concat
   "C:/cygwin/usr/local/bin" ";"
   "C:/cygwin/usr/bin" ";"
   "C:/cygwin/bin" ";"
   (getenv "PATH")
  )
)
    You can use slash / and you don't have to use backslash \.
    Dir path may end with a path separator /, or without.
    the builtin variable path-separator can be used instead of ;.
;; show env var named path
(getenv "PATH")
* TODO натройка емака
** TODO Vims Tabs
*** Таб должен взаимодействоать с полнооконым режимом
если фул скри добовляет окна 4 с права
и помнит для каждого что в нём было
по доп нажатию фула в окне меняет местами содержания из доп окна и основного
** DONE Vims Folding 
   CLOSED: [2019-08-06 Вт 05:59]
** TODO настроить для работы с JS
   Найти файил с туториалом по настройке
   [[https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html]]
*** Mods
**** Indium
     https://github.com/NicolasPetton/Indium
A JavaScript development environment for Emacs.

Indium connects to a browser tab or nodejs process and provides many features for JavaScript development, including:

    a REPL (with auto completion) & object inspection;
    an inspector, with history and navigation;
    a scratch buffer (M-x indium-scratch);
    JavaScript evaluation in JS buffers with indium-interaction-mode;
    a stepping Debugger, similar to edebug, or cider.

** TODO настроить редактор 
*** TODO Понять что делать с языком 
- заменить в ивеле команду замены чтоб она понимала язык
*** TODO добовлять один символ
- [ ] энтер2
- [ ] 2пробел
- [ ] пробел + i\a(I\A)
** TODO Настроить емак для работы с Си 
 1) сварачивание
 2) авто дополнение
 3) снипиты
 4) подсветка
    + кода
    + скобок
    + курсора при альттабинге
 5) квикфикс
 6) оргмод литпрограминг
    - импор сорса в один файл
    - создание нового файла на основе
    - создание структуры папок
    - создание всего проеката на основе стуктурного описания (файлов и папок). с возможностью открытия следуших 
*** примеры удачных реализаций
**** Run shell command and jump to error workflow

 Hi all,

 I have recently started using Emacs(Doom) more and more seriously and really liking the experience. I have come so far that I feel pretty comfortable to use it at work without slowing down my efficiency that much. One aspect of my Vim workflow that I haven't found a good solution to however is building my project (C++) and running unit tests.

 With Vim I am used to using the plugin Asyncrun, https://github.com/skywind3000/asyncrun.vim. This plugin makes it possible to execute shell commands, typically calling the python script that runs build/ or the unit tests and printing the progress in the quickfix window. It would automatically parse the text and find errors and where they are located making it possible to use my keybinding for navigating the quickfix list to easily jump to an error, solve the issue and jump to the next one.

 So far I have only figured out a solution where I open a multiterm window and enable compilation-shell-minor-mode. Run the build command, go back to evil normal mode, M-x compilation-next-error-function. Switch window to the window with the code, fix the error, go to normal mode, switch back to shell window and repeat the process. This seems a little inefficient so I am sure there are better solutions out there but my Emacs skills are very low :)

 So I wonder what your workflows are like in Emacs? :)

 Cheers!
 4 comments
 100% Upvoted
 This thread is archived
 New comments cannot be posted and votes cannot be cast
 Sort by
 level 1
 rskiad
 12 points ·
 1 year ago
 · edited 1 year ago

 How about

 M-x compile RET whatever-command
 C-x `

 There is also projectile that provides projectile-compile-project and projectile-test-project that also work with next-error (C-x `)
 level 2
 squirelpower
 2 points ·
 1 year ago

 That's perfect, works exactly like I want it, many thanks! :)
 level 2
 oantolin
 1 point ·
 1 year ago
 · edited 1 year ago

 I prefer the keybinding M-g M-n for next-error and its companion M-g M-p for previous-error.
 level 2
 TabCompletion
 1 point ·
 1 year ago
 · edited 1 year ago

 I bound F6 for my next-error command. I also have a mondo compilation-error-regexp-alist regex to match errors:
** TODO Добавить функционал 
*** DONE пробел символ
	CLOSED: [2019-08-06 Вт 06:03]
*** ентер для пост символа
*** сдвиг строк
*** копия строк
** TODO работа с серийным портом
 - Передовать команды из буфера в открытый порт
 - посмотреть как настроен емак в видео с форсом
 - понять как реконектится наиболее быстро
   - командой
   - сочетание кнопок
   - строкой из скреч буфера
** Моды для емака
*** Ivy mods 
    [[https://www.youtube.com/watch?v=AaUlOH4GTCs]] youtube from where I get this 
    https://truthseekers.io/lessons/how-to-use-ivy-swiper-counsel-in-emacs-for-noobs/ text version lesson
    Ivy, Counsel, and Swiper are great if you can figure out how to use them!
 Luckily they are all pretty simple. In fact, you can just... install them and copy/paste some stuff and be on your way!
 I wanted to understand these emacs packages though, and that's a little more challenging.
    - ~Ivy~     :: is a package that helps you search. It helps you do things in M-x, or find file, and Dired, etc... Anything where you look for something in Emacs, Ivy can come to the rescue and help you type less. For example. Let's say I want to look through some Melpa packages. No longer do I have to type package-list-packages. Instead, I can just type "pa li packa" and Ivy will find all the results that match the search terms. Using spaces, you can target certain parts of what you're looking for. It just helps you type less. Ivy doesn't rely on anything, but
    - ~Swiper~  :: will automatically pull in Ivy when it's installed, because Swiper needs Ivy. Swiper does the same thing as Ivy, but replaces isearch, so you can use ivy features when searching through text.
    - ~Counsel~ :: gives you extra functions that aren't normally available. For example: You can open a buffer or file in a new window.
*** use-package


The easiest way is to install use-package.

(package-initialize)
(require 'package)
(add-to-list 'package-archives
    '("melpa" . "http://melpa.milkbox.net/packages/") t)

(dolist (package '(use-package))
   (unless (package-installed-p package)
       (package-install package)))

Then

 (use-package paredit
   :ensure t)

The :ensure t is what ensures that the package is installed.

To just load ensure multiple packages are install

(dolist (package '(package-a package-b package-c))
 (unless (package-installed-p package)
   (package-install package))
   (require package))))
   
*** hidra mod 
    https://github.com/abo-abo/hydra
This is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common prefix - a Hydra.
*** Mover mods
**** Avy mods
     - Avy :: is one of my favorite packages in Emacs.
     https://truthseekers.io/lessons/avy-emacs-tutorial-moving-around-emacs-quickly/
     Learning how to use Avy is one of the easiest and fastest ways to improve your efficiency in Emacs. The Avy Emacs package allows you to quickly get to any visible point in an Emacs buffer, window, or frame. By using one of the functions Avy provides, you define a search term, and Avy provides a "Tree" list of options to choose from. You choose the point you want your cursor to move to by typing one or two characters and BOOM, your cursor is exactly where you need it. The best part about Avy is how simple it is. You only need one or two key bindings, and you're good to go.
**** DONE Fast Emacs Window & Frame switching with WindMove & FrameMove 
	 CLOSED: [2019-08-06 Вт 05:49]
https://truthseekers.io/lessons/an-introduction-to-emacs-everything-you-need-to-know-to-get-started/
;; Remap windmove keys to home keys
(global-set-key (kbd "M-h") 'windmove-left)
(global-set-key (kbd "M-j") 'windmove-down)
(global-set-key (kbd "M-k") 'windmove-up)
(global-set-key (kbd "M-l") 'windmove-right)
*** quickfix-mode 
https://github.com/emacsmirror/quickfix-mode
    quickfix-mode consists of a series of quickfixes registered for your favourite programming mode. 
These will suggest a possible suggestion depending on the error (or warning) reported for flymake.
 Oh yes, _quickfix-mode depends_ on ~flymake~ (and ~popup~).
 https://github.com/auto-complete/popup-el
    Quickfix in action
Let's say flymake reports some errors in your code (in this case in erlang)
flymake errors and warnings
bar is undefined
C-c C-f to the rescue...
quickfix suggest it could define the function for us
selecting...and voila!
and the function is defined so that we can work on it
Exporting unused functions works too.
foo is unused :-o
quickfix to the rescue
and we're good!
*** Emacs Support for reStructuredText
    reStructuredText is a syntax for simple text files that allows a tool set - docutils - to extract generic document structure. For people who use Emacs, there is a package that adds a major mode that supports editing the syntax of reStructuredText: rst.el. This document describes the features it provides, and how to setup your Emacs to use them and how to invoke them.
    ~reStructuredText~ is an easy-to-read, what-you-see-is-what-you-get plaintext markup syntax and parser system. It is useful for in-line program documentation (such as Python docstrings), for quickly creating simple web pages, and for standalone documents. reStructuredText is designed for extensibility for specific application domains. The reStructuredText parser is a component of Docutils. reStructuredText is a revision and reinterpretation of the StructuredText and Setext lightweight markup systems.

The primary goal of reStructuredText is to define and implement a markup syntax for use in Python docstrings and other documentation domains, that is readable and simple, yet powerful enough for non-trivial use. The intended purpose of the markup is the conversion of reStructuredText documents into useful structured data formats.

See statemachine.py for an example of a Python module fully documented using reStructuredText.
** TODO Add lisp code
*** Folding on Org Mode vs C mode
If you want to exclude one specific mode, you can do the following:

(global-set-key (kbd "<C-S-down>") 'move-line-down) 

to make it globally available, and

(define-key KEYMAP (kbd "<C-S-down>") nil) 

to exclude one mode where KEYMAP is the name name of the mode, followed by "mode-map" (e.g. ess-mode-map). You could also bind the original thing to the key instead of nil.
shareimprove this answer

* TODO Оргаизовать Org Mod
** TODO Разобратся с агендой
*** DONE разобрать фаил по подфайлам
	CLOSED: [2019-08-06 Вт 06:05]
*** DONE понять как разбить на карты повторного выполнения
	CLOSED: [2019-08-06 Вт 06:04]
*** настроить агеду чтоб показывать только глаыный фаили и зависиый родитель
*** DONE что делать с выполненыемт заданиями чтоб не замусоривать 
	CLOSED: [2019-08-06 Вт 06:04]
*** keys add agenda file
   C-c [     (org-agenda-file-to-front)

    Add current file to the list of agenda files. The file is added to the front of the list. If it was already in the list, it is moved to the front. With a prefix argument, file is added/moved to the end. 
C-c ]     (org-remove-file)

    Remove current file from the list of agenda files. 
   SCHEDULED: <2018-10-25 Чт 09:40>
*** comands to add agenda file
   (setq org-agenda-files '("~/org"))
   (setq org-agenda-files '("~/ORG/start.org"))
   (setq org-agenda-files (quote ("~/ORG/start.org")))
* Help Docs Emacs 
** info\help
   Check out the info manual for Org Mode with C-h i (info) to learn more, including how to customize the number of days initially displayed and what day your week starts on. 
   удобная систе показиваюшая мануалки по всем установленым модам
** Options
*** Visual
*** Text Eltments
**** Parenthesis
***** 5.27 How do I show which parenthesis matches the one I’m looking at?
  Call show-paren-mode in your .emacs file:
  (show-paren-mode 1)

  You can also enable this mode by selecting the ‘Paren Match Highlighting’ option from the ‘Options’ menu of the Emacs menu bar at the top of any Emacs frame.

  Alternatives to this mode include:

  If you’re looking at a right parenthesis (or brace or bracket) you can delete it and reinsert it. Emacs will momentarily move the cursor to the matching parenthesis.

  C-M-f (forward-sexp) and C-M-b (backward-sexp) will skip over one set of balanced parentheses, so you can see which parentheses match. (You can train it to skip over balanced brackets and braces at the same time by modifying the syntax table.)

  Here is some Emacs Lisp that will make the % key show the matching parenthesis, like in vi. In addition, if the cursor isn’t over a parenthesis, it simply inserts a % like normal.
  #+BEGIN_SRC elisp
;; By an unknown contributor
(global-set-key "%" 'match-paren)
(defun match-paren (arg)
"Go to the matching paren if on a paren; otherwise insert %."
    (interactive "p")
    (cond ((looking-at "\\s(") (forward-list 1) (backward-char 1))
	    ((looking-at "\\s)") (forward-char 1) (backward-list 1))
	    (t (self-insert-command (or arg 1)))))
  #+END_SRC

** eLisp
*** Cool guid
https://github.com/chrisdone/elisp-guide
** Keyborde help 
*** evaluate
    27.9 Evaluating Emacs Lisp Expressions
Emacs Lisp mode is the major mode for editing Emacs Lisp. Its mode command is M-x emacs-lisp-mode.
Emacs provides several commands for evaluating Emacs Lisp expressions. You can use these commands in Emacs Lisp mode, to test your Emacs Lisp code as it is being written. For example, after re-writing a function, you can evaluate the function definition to make it take effect for subsequent function calls. These commands are also available globally, and can be used outside Emacs Lisp mode.
M-:
    Read a single Emacs Lisp expression in the minibuffer, evaluate it, and print the value in the echo area (eval-expression).
~C-x C-e~
    Evaluate the Emacs Lisp expression ~before point~, and print the value in the echo area (eval-last-sexp).
~C-M-x (in Emacs Lisp mode)~
~M-x eval-defun~
    Evaluate the defun containing or after point, and print the value in the echo area (eval-defun).
~M-x eval-region~
    Evaluate all the Emacs Lisp expressions in the region.
~M-x eval-buffer~
    Evaluate all the Emacs Lisp expressions in the buffer. 

M-: (eval-expression) reads an expression using the minibuffer, and evaluates it. (Before evaluating the expression, the current buffer switches back to the buffer that was current when you typed M-:, not the minibuffer into which you typed the expression.)

The command C-x C-e (eval-last-sexp) evaluates the Emacs Lisp expression preceding point in the buffer, and displays the value in the echo area. When the result of an evaluation is an integer, it is displayed together with the value in other formats (octal, hexadecimal, and character if eval-expression-print-maximum-character, described below, allows it).

If M-: or C-x C-e is given a prefix argument, it inserts the value into the current buffer at point, rather than displaying it in the echo area. If the prefix argument is zero, any integer output is inserted together with its value in other formats (octal, hexadecimal, and character). Such a prefix argument also prevents abbreviation of the output according to the variables eval-expression-print-level and eval-expression-print-length (see below). Similarly, a prefix argument of -1 overrides the effect of eval-expression-print-length.

The eval-defun command is bound to C-M-x in Emacs Lisp mode. It evaluates the top-level Lisp expression containing or following point, and prints the value in the echo area. In this context, a top-level expression is referred to as a “defun”, but it need not be an actual defun (function definition). In particular, this command treats defvar expressions specially. Normally, evaluating a defvar expression does nothing if the variable it defines already has a value. But this command unconditionally resets the variable to the initial value specified by the defvar; this is convenient for debugging Emacs Lisp programs. defcustom and defface expressions are treated similarly. Note that the other commands documented in this section do not have this special feature.

With a prefix argument, C-M-x instruments the function definition for Edebug, the Emacs Lisp Debugger. See Instrumenting for Edebug.

The command M-x eval-region parses the text of the region as one or more Lisp expressions, evaluating them one by one. M-x eval-buffer is similar but evaluates the entire buffer.

The options eval-expression-print-level and eval-expression-print-length control the maximum depth and length of lists to print in the result of the evaluation commands before abbreviating them. Supplying a zero prefix argument to eval-expression or eval-last-sexp causes lists to be printed in full. eval-expression-debug-on-error controls whether evaluation errors invoke the debugger when these commands are used; its default is t. eval-expression-print-maximum-character prevents integers which are larger than it from being displayed as characters. 
5.31 How do I execute (“evaluate”) a piece of Emacs Lisp code?
There are a number of ways to execute (evaluate, in Lisp lingo) an Emacs Lisp form:
    If you want it evaluated every time you run Emacs, put it in a file named .emacs in your home directory. This is known as “your .emacs file,” and contains all of your personal customizations.
    You can type the form in the *scratch* buffer, and then type <LFD> (or C-j) after it. The result of evaluating the form will be inserted in the buffer.
    ~In emacs-lisp-mode~, typing ~C-M-x~ evaluates a top-level form before or around point.
    Typing ~C-x C-e~ in ~any buffer~ evaluates the Lisp form immediately before point and prints its value in the echo area.
    Typing M-: or M-x eval-expression allows you to type a Lisp form in the minibuffer which will be evaluated once you press <RET>.
    You can use M-x load-file to have Emacs evaluate all the Lisp forms in a file. (To do this from Lisp use the function load instead.)
    The functions load-library, eval-region, eval-buffer, require, and autoload are also useful; see Emacs Lisp documentation, if you want to learn more about them. 
*** get help 
*** get menu command 
    Some of the commands in the menu bar have ordinary key bindings as well;
 if so, a key binding is shown after the item itself. 
To view the full ~command name~ and documentation for a menu item, type ~C-h k~,
 and then select the menu bar with the mouse in the usual way (see Key Help). 
*** coment line 
26.5.1 Comment Commands
The following commands operate on comments:
M-;
    Insert or realign comment on current line; if the region is active, comment or uncomment the region instead (comment-dwim).
~C-x C-;~
    Comment or uncomment the current line (comment-line). If the region is active, comment or uncomment the lines in the region instead.
C-u M-;
    Kill comment on current line (comment-kill).
C-x ;
    Set comment column (comment-set-column).
C-M-j
M-j
    Like <RET> followed by inserting and aligning a comment (comment-indent-new-line). See Multi-Line Comments.
M-x comment-region
C-c C-c (in C-like modes)
    Add comment delimiters to all the lines in the region. 

The command to create or align a comment is M-; (comment-dwim). The word “dwim” is an acronym for “Do What I Mean”; it indicates that this command can be used for many different jobs relating to comments, depending on the situation where you use it.
When a region is active (see Mark), M-; either adds comment delimiters to the region, or removes them. If every line in the region is already a comment, it uncomments each of those lines by removing their comment delimiters. Otherwise, it adds comment delimiters to enclose the text in the region.
If you supply a prefix argument to M-; when a region is active, that specifies the number of comment delimiters to add or delete. A positive argument n adds n delimiters, while a negative argument -n removes n delimiters.
If the region is not active, and there is no existing comment on the current line, M-; adds a new comment to the current line. If the line is blank (i.e., empty or containing only whitespace characters), the comment is indented to the same position where <TAB> would indent to (see Basic Indent). If the line is non-blank, the comment is placed after the last non-whitespace character on the line. Emacs tries to fit the comment between the columns specified by the variables comment-column and comment-fill-column (see Options for Comments), if possible. Otherwise, it will choose some other suitable position, usually separated from the non-comment text by at least one space. In each case, Emacs places point after the comment's starting delimiter, so that you can start typing the comment text right away.
You can also use M-; to align an existing comment. If a line already contains the comment-start string, M-; realigns it to the conventional alignment and moves point after the comment's starting delimiter. As an exception, comments starting in column 0 are not moved. Even when an existing comment is properly aligned, M-; is still useful for moving directly to the start of the comment text.
~C-x C-;~ (comment-line) comments or uncomments complete lines. When a region is active (see Mark), C-x C-; either comments or uncomments the lines in the region. If the region is not active, this command comments or uncomments the line point is on. With a positive prefix argument n, it operates on n lines starting with the current one; with a negative n, it affects n preceding lines. After invoking this command with a negative argument, successive invocations with a positive argument will operate on preceding lines as if the argument were negated.
C-u M-; (comment-dwim with a prefix argument) kills any comment on the current line, along with the whitespace before it. Since the comment is saved to the kill ring, you can reinsert it on another line by moving to the end of that line, doing C-y, and then M-; to realign the comment. You can achieve the same effect as C-u M-; by typing M-x comment-kill (comment-dwim actually calls comment-kill as a subroutine when it is given a prefix argument).
The command M-x comment-region is equivalent to calling M-; on an active region, except that it always acts on the region, even if the mark is inactive. In C mode and related modes, this command is bound to C-c C-c. The command M-x uncomment-region uncomments each line in the region; a numeric prefix argument specifies the number of comment delimiters to remove (negative arguments specify the number of comment delimiters to add).
For C-like modes, you can configure the exact effect of M-; by setting the variables c-indent-comment-alist and c-indent-comments-syntactically-p. For example, on a line ending in a closing brace, M-; puts the comment one space after the brace rather than at comment-column. For full details see Comment Commands. 
** REPL 
** DeBug
* Help Docs Org
** Welcome to Org mode
*** Marker sibols  
 You can make words 
 *bold*, /italic/, _underlined_, =code= and ~verbatim sdfsdfs~, 
 and, if you must, +strike-through+.
*** Lord of the Rings
    My favorite scenes are (in this order)
    1. Eowyn's fight with the witch king
       + this was already my favorite scene in the book
       + I really like Miranda Otto.
    2. The attack of the Rohirrim
    3. Peter Jackson being shot by Legolas
       - on DVD only
       He makes a really funny face when it happens.
    But in the end, no individual scenes matter but the film as a whole.
    Important actors in this film are:
    - Elijah Wood :: He plays Frodo
    - Sean Austin :: He plays Sam, Frodo's friend.  I still remember
      him very well from his role as Mikey Walsh in The Goonies.
** Help
*** info\manual
    Check out the info manual for Org Mode with C-h i (info) to learn more, including how to customize the number of days initially displayed and what day your week starts on. 
    удобная систе показиваюшая мануалки по всем установленым модам
*** links
**** Org Mode - Organize Your Life In Plain Text!
     http://doc.norang.ca/org-mode.html   
     очень последовательнвый манул по всему оргу с кучей примеров
** Tree Notes 
*** Exempls
  - Note taken on [2018-10-29 Пн 20:19] \\
    ladfdfd
    fdf
    df
    df
    ts add anoser note
    - sdfsdf sdf sdf sdfsd \\
    sdfsdfsdf
    sdfsdf sd fsd fd
    - some note?
	Intrasting where it puting this
    - d
    - sdf
    - sdfsdfsf
    - [X] 
    - [X] sdf
    - 
    - sdfsdfs sdf sdf sd[fn:1] 
    - 
*** Footnotes

[fn:1] The footnote.

[fn:2] Second footnote.
[fn:1] I not undestend ecthakli how this must work
** Help keys
*** Visibility cycling
Tab – show current
S-tab – show all children
C-u C-u C-u Tab – show all including drawers
Startup options
Editting
M-Ret – add element on the same level
M-S-Ret – insert TODO element
M-Right – demote current element
M-S-Right – deomote current subtree
M-Left – promote current element
M-S-Left – promote current subtree
M-S-Up – move current tree up
M-S-Down – move current tree down
C-c C-x C-w – kill current subtree
C-c C-x M-w – copy current subtree
C-c C-x C-y – yank subtree
C-x n s     (org-narrow-to-subtree)
    Narrow buffer to current subtree.
C-x n b     (org-narrow-to-block)
    Narrow buffer to current block.
C-x n w     (widen)
    Widen buffer to remove narrowing.
C-c *     (org-toggle-heading)
    Turn a normal line or plain list item into a headline (so that it becomes a subheading at its location). Also turn a headline into a normal line by removing the stars. If there is an active region, turn all lines in the region into headlines. If the first line in the region was an item, turn only the item lines into headlines. Finally, if the first line is a headline, remove the stars from all headlines in the region. 
*** Plain lists
Use M-Ret to add list item
Ordered list:

    First
    Second
    Third

Unordered lists

    abc
    efg

List with checkboxes (M-S-Ret)

    [ ] First element
    [X] Second element (C-c C-c – toggle checkbox state)
    [X] Third element
*** ToDo functionality
C-c C-t – rotate TODO state
S-Left, S-Right – rotate TODO state
S-M-Ret – insert new TODO note
(setq org-todo-keywords’((sequence “TODO” “FEEDBACK” “VERIFY” “|” “DONE” “DELEGATED”)))
Footnotes

*** unsort
More devices
C-c C-z – time-stamped drawer

    Note taken on [2013-09-02 Mon 23:54]
    My note here

[fn:2]
 C-c C-x f – footnote[fn:1]**
** Tabels
   | freeman | 1 | hucker |
   | max     | 1 | humen  |
   |---------+---+--------|
   |         |   |        |
  
   |---------+---+--------|
   |         |   |        |
** Tags 
Two: Which tags do you use most?
You can always add tags freely and by hand, but if you configure the most important ones along with fast-access keys, life will be better. Configure the variable org-tags-alist or simply do this right in the file with1
#+TAGS: home(h) work(w) @computer(c) @phone(p) errants(e)
** Todos 
*** Dependantistis 
**** TODO Blocked until (two) is done
***** DONE one
***** TODO two
**** Parent
     :PROPERTIES:
     :ORDERED:  t
     :END:
***** WAITING a
- isdf
- [ ] sdfs
- [X] sdfsdf
***** TODO b, needs to wait for (a)
***** TODO c, needs to wait for (a) and (b)

   You can ensure an entry is never blocked by using the NOBLOCKING property:

**** This entry is never blocked
     :PROPERTIES:
     :NOBLOCKING: t
     :END:

   C-c C-x o     (org-toggle-ordered-property)
*** Status 
  One: More TODO keywords
  Define the TODO states you find useful and single letters for fast selection. Customize the variable org-todo-keywords or simply do this right in the file with1:
  #+TODO: TODO(t) STARTED(s) WAITING(w) | DONE(d) CANCELED(c)
*** arhiv 
    c+c $ 
you can move them to an archive file with C-c $ (org-archive-subtree)отправляет в архи таким путём чистя агенду и лист
момет отправки помечается временени поидееии
и соответственно его скорй всего потом оможно будет от туда выташить и использовать 
*** shadule
    С+с С+s
  Next, we're going to schedule some tasks. Go to a task that you want to do today. Press C-c C-s (org-schedule) and accept the default. Schedule a couple of other tasks for today.

Schedule some tasks for tomorrow, too. This time, when you schedule it, type +1 for the date. You can specify +2 for the day after tomorrow, etc. The 28th? 28. If you want to schedule something for next Saturday, you can type sat. Two Tuesdays from now? 2thu. A month from now? 1m. It's really flexible. 
*** агендa
**** keys add agenda file
    C-c [     (org-agenda-file-to-front)

     Add current file to the list of agenda files. The file is added to the front of the list. If it was already in the list, it is moved to the front. With a prefix argument, file is added/moved to the end. 
 C-c ]     (org-remove-file)

     Remove current file from the list of agenda files. 
**** comands to add agenda file
    (setq org-agenda-files '("~/org"))
    (setq org-agenda-files '("~/ORG/start.org"))
    (setq org-agenda-files (quote ("~/ORG/start.org")))
*** *add a :CATEGORY: property to the top-level, non-TODO heading that identifies the project.  Using your example:

 * Project ABC
  :PROPERTIES:
  :CATEGORY: ABC
  :END:

 ** TODO A task related to Project ABC
 ** TODO Another task related to ABC
 *** TODO Subtask
SCHEDULED: 

In my bog-standard org-mode setup, this results in “ABC” being displayed in the far-left column of the agenda instead of just “todo” (which seems to be the default). This is great — it means that, in the text of the “Subtask” todo entry itself, I don’t need to include a reminder of what project the todo entry is associated with.

Here’s an agenda mockup to illustrate the point, augmented with a “default” entry from my own to-do list:

  todo:       Scheduled:  Follow up on expense reimbursement request
  ABC:        Scheduled:  Subtask

** Links 
   (define-key global-map "\C-cl" 'org-store-link)
Для того что бы создать ссылку достаточно использовать такой шаблон — [[ссылка][описание]].
  [ {] [] ]

Для создания ссылки можно ещё использовать комбинацию C+c C+l. В мини-буфере emacs предложит сначала написать ссылку, затем после нажатия RET — её создать. Находясь в мини-буфере так же можно нажать TAB, для просмотра, какие виды ссылок бывают.

Что бы открыть вновь созданные ссылки необходимо навести точку на ссылку и тыкнуть C+c C+o. Или C+u C+c C+o — если Вы хотите открыть её в другом окне.

Ради интереса, можно перейти в другой файл, нажать там C+c l. И ссылка на этот файл поместится в хранилище ссылок. Перейдя в любой наш файл .org мы можем извлечь из этого хранилища любые сохраненные ссылки, с помощью той же команды C+c C+l.
Самые наблюдательные читатели уже могли заметить, что эта команда как раз и есть та, которую мы вписали в ~/.emacs, в начале.
   [[https://orgmode.org/org.pdf][Link to 304p doc about org]]
* Help Docs Gnus
  The Emacs news and email reader.
* Help Docs Mods 
** use-package
*** Getting started
;; This is only needed once, near the top of the file
(eval-when-compile
  ;; Following line is not needed if use-package.el is in ~/.emacs.d
  (add-to-list 'load-path "<path where use-package is installed>")
  (require 'use-package))

(use-package foo)
This loads in the package foo, but only if foo is available on your system. If not, a warning is logged to the *Messages* buffer.
*** :init :config
Use the :init keyword to execute code before a package is loaded. It accepts one or more forms, up to the next keyword:

(use-package foo
  :init
  (setq foo-variable t))
Similarly, :config can be used to execute code after a package is loaded. In cases where loading is done lazily (see more about autoloading below), this execution is deferred until after the autoload occurs:

(use-package foo
  :init
  (setq foo-variable t)
  :config
  (foo-mode 1))
As you might expect, you can use :init and :config together:

(use-package color-moccur
  :commands (isearch-moccur isearch-all)
  :bind (("M-s O" . moccur)
         :map isearch-mode-map
         ("M-o" . isearch-moccur)
         ("M-O" . isearch-moccur-all))
  :init
  (setq isearch-lazy-highlight t)
  :config
  (use-package moccur-edit))
In this case, I want to autoload the commands isearch-moccur and isearch-all from color-moccur.el, and bind keys both at the global level and within the isearch-mode-map (see next section). When the package is actually loaded (by using one of these commands), moccur-edit is also loaded, to allow editing of the moccur buffer.
*** Key-binding
Another common thing to do when loading a module is to bind a key to primary commands within that module:

(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))
This does two things: first, it creates an autoload for the ace-jump-mode command and defers loading of ace-jump-mode until you actually use it. Second, it binds the key C-. to that command. After loading, you can use M-x describe-personal-keybindings to see all such keybindings you've set throughout your .emacs file.

A more literal way to do the exact same thing is:

(use-package ace-jump-mode
  :commands ace-jump-mode
  :init
  (bind-key "C-." 'ace-jump-mode))
When you use the :commands keyword, it creates autoloads for those commands and defers loading of the module until they are used. Since the :init form is always run -- even if ace-jump-mode might not be on your system -- remember to restrict :init code to only what would succeed either way.

The :bind keyword takes either a cons or a list of conses:

(use-package hi-lock
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))
The :commands keyword likewise takes either a symbol or a list of symbols.

NOTE: inside strings, special keys like tab or F1-Fn have to be written inside angle brackets, e.g. "C-<up>". Standalone special keys (and some combinations) can be written in square brackets, e.g. [tab] instead of "<tab>". The syntax for the keybindings is similar to the "kbd" syntax: see https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-Rebinding.html for more information.

Examples:

(use-package helm
  :bind (("M-x" . helm-M-x)
         ("M-<f5>" . helm-find-files)
         ([f10] . helm-buffers-list)
         ([S-f10] . helm-recentf)))
Furthermore, remapping commands with :bind and bind-key works as expected, because when the binding is a vector, it is passed straight to define-key. So the following example will rebind M-q (originally fill-paragraph) to unfill-toggle:

(use-package unfill
  :bind ([remap fill-paragraph] . unfill-toggle))
Binding to keymaps

Normally :bind expects that commands are functions that will be autoloaded from the given package. However, this does not work if one of those commands is actually a keymap, since keymaps are not functions, and cannot be autoloaded using Emacs' autoload mechanism.

To handle this case, use-package offers a special, limited variant of :bind called :bind-keymap. The only difference is that the "commands" bound to by :bind-keymap must be keymaps defined in the package, rather than command functions. This is handled behind the scenes by generating custom code that loads the package containing the keymap, and then re-executes your keypress after the first load, to reinterpret that keypress as a prefix key.

For example:

(use-package projectile
  :bind-keymap
  ("C-c p" . projectile-command-map))
Binding within local keymaps

Slightly different from binding a key to a keymap, is binding a key within a local keymap that only exists after the package is loaded. use-package supports this with a :map modifier, taking the local keymap to bind to:

(use-package helm
  :bind (:map helm-command-map
         ("C-c h" . helm-execute-persistent-action)))
The effect of this statement is to wait until helm has loaded, and then to bind the key C-c h to helm-execute-persistent-action within Helm's local keymap, helm-mode-map.

Multiple uses of :map may be specified. Any binding occurring before the first use of :map are applied to the global keymap:

(use-package term
  :bind (("C-c t" . term)
         :map term-mode-map
         ("M-p" . term-send-up)
         ("M-n" . term-send-down)
         :map term-raw-map
         ("M-o" . other-window)
         ("M-p" . term-send-up)
         ("M-n" . term-send-down)))
*** Modes and interpreters
Similar to :bind, you can use :mode and :interpreter to establish a deferred binding within the auto-mode-alist and interpreter-mode-alist variables. The specifier to either keyword can be a cons cell, a list of cons cells, or a string or regexp:

(use-package ruby-mode
  :mode "\\.rb\\'"
  :interpreter "ruby")

;; The package is "python" but the mode is "python-mode":
(use-package python
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode))
If you aren't using :commands, :bind, :bind*, :bind-keymap, :bind-keymap*, :mode, :interpreter, or :hook (all of which imply :defer; see the docstring for use-package for a brief description of each), you can still defer loading with the :defer keyword:

(use-package ace-jump-mode
  :defer t
  :init
  (autoload 'ace-jump-mode "ace-jump-mode" nil t)
  (bind-key "C-." 'ace-jump-mode))
This does exactly the same thing as the following:

(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))
*** Magic handlers

Similar to :mode and :interpreter, you can also use :magic and :magic-fallback to cause certain function to be run if the beginning of a file matches a given regular expression. The difference between the two is that :magic-fallback has a lower priority than :mode. For example:

(use-package pdf-tools
  :load-path "site-lisp/pdf-tools/lisp"
  :magic ("%PDF" . pdf-view-mode)
  :config
  (pdf-tools-install :no-query))
This registers an autoloaded command for pdf-view-mode, defers loading of pdf-tools, and runs pdf-view-mode if the beginning of a buffer matches the string "%PDF".

*** Hooks

The :hook keyword allows adding functions onto hooks, here only the basename of the hook is required. Thus, all of the following are equivalent:

(use-package ace-jump-mode
  :hook prog-mode)

(use-package ace-jump-mode
  :hook (prog-mode . ace-jump-mode))

(use-package ace-jump-mode
  :commands ace-jump-mode
  :init
  (add-hook 'prog-mode-hook #'ace-jump-mode))
And likewise, when multiple hooks should be applied, the following are also equivalent:

(use-package ace-jump-mode
  :hook (prog-mode text-mode))

(use-package ace-jump-mode
  :hook ((prog-mode text-mode) . ace-jump-mode))

(use-package ace-jump-mode
  :hook ((prog-mode . ace-jump-mode)
         (text-mode . ace-jump-mode)))

(use-package ace-jump-mode
  :commands ace-jump-mode
  :init
  (add-hook 'prog-mode-hook #'ace-jump-mode)
  (add-hook 'text-mode-hook #'ace-jump-mode))
The use of :hook, as with :bind, :mode, :interpreter, etc., causes the functions being hooked to implicitly be read as :commands (meaning they will establish interactive autoload definitions for that module, if not already defined as functions), and so :defer t is also implied by :hook.
*** Conditional loading
**** :if
You can use the :if keyword to predicate the loading and initialization of modules.
For example, I only want edit-server running for my main, graphical Emacs, not for other Emacsen I may start at the command line:

(use-package edit-server
  :if window-system
  :init
  (add-hook 'after-init-hook 'server-start t)
  (add-hook 'after-init-hook 'edit-server-start t))
In another example, we can load things conditional on the operating system:

(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :ensure t
  :config
  (exec-path-from-shell-initialize))
**** :disable
The :disabled keyword can turn off a module you're having difficulties with, or stop loading something you're not using at the present time:

(use-package ess-site
  :disabled
  :commands R)
When byte-compiling your .emacs file, disabled declarations are omitted from the output entirely, to accelerate startup times.
**** :when
NOTE: :when is provided as an alias for :if, and :unless foo means the same thing as :if (not foo). For example, the following will also stop :ensure from happening on Mac systems:

(when (memq window-system '(mac ns))
  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize)))
Conditional loading before :preface

If you need to conditionalize a use-package form so that the condition occurs before even the :preface is executed, simply use when around the use-package form itself:
*** Loading packages in sequence
Sometimes it only makes sense to configure a package after another has been loaded, because certain variables or functions are not in scope until that time. This can achieved using an :after keyword that allows a fairly rich description of the exact conditions when loading should occur. Here is an example:

(use-package hydra
  :load-path "site-lisp/hydra")

(use-package ivy
  :load-path "site-lisp/swiper")

(use-package ivy-hydra
  :after (ivy hydra))
In this case, because all of these packages are demand-loaded in the order they occur, the use of :after is not strictly necessary. By using it, however, the above code becomes order-independent, without an implicit depedence on the nature of your init file.

By default, :after (foo bar) is the same as :after (:all foo bar), meaning that loading of the given package will not happen until both foo and bar have been loaded. Here are some of the other possibilities:

:after (foo bar)
:after (:all foo bar)
:after (:any foo bar)
:after (:all (:any foo bar) (:any baz quux))
:after (:any (:all foo bar) (:all baz quux))
When you nest selectors, such as (:any (:all foo bar) (:all baz quux)), it means that the package will be loaded when either both foo and bar have been loaded, or both baz and quux have been loaded.

NOTE: pay attention if you set use-package-always-defer to t, and also use the :after keyword, as you will need to specify how the declared package is to be loaded: e.g., by some :bind. If you're not using one of tho mechanisms that registers autoloads, such as :bind or :hook, and your package manager does not provide autoloads, it's possible that without adding :demand t to those declarations, your package will never be loaded.

*** Prevent loading if dependencies are missing

While the :after keyword delays loading until the dependencies are loaded, the somewhat simpler :requires keyword simply never loads the package if the dependencies are not available at the time the use-package declaration is encountered. By "available" in this context it means that foo is available if (featurep 'foo) evaluates to a non-nil value. For example:

(use-package abbrev
  :requires foo)
This is the same as:

(use-package abbrev
  :if (featurep 'foo))
As a convenience, a list of such packages may be specified:

(use-package abbrev
  :requires (foo bar baz))
For more complex logic, such as that supported by :after, simply use :if and the appropriate Lisp expression.
*** Gathering Statistics

If you'd like to see how many packages you've loaded, what stage of initialization they've reached, and how much aggregate time they've spent (roughly), you can enable use-package-compute-statistics after loading use-package but before any use-package forms, and then run the command M-x use-package-report to see the results. The buffer displayed is a tabulated list. You can use S in a column to sort the rows based on it.
*** (use-package-chords)
The :chords keyword allows you to define key-chord bindings for use-package declarations in the same manner as the :bind keyword.

To enable the extension:

(use-package use-package-chords
  :ensure t
  :config (key-chord-mode 1))
Then you can define your chord bindings in the same manner as :bind using a cons or a list of conses:

(use-package ace-jump-mode
  :chords (("jj" . ace-jump-char-mode)
           ("jk" . ace-jump-word-mode)
           ("jl" . ace-jump-line-mode)))
*** Some timing results
On my Retina iMac, the "Mac port" variant of Emacs 24.4 loads in 0.57s, with around 218 packages configured (nearly all of them lazy-loaded). However, I experience no loss of functionality, just a bit of latency when I'm first starting to use Emacs (due to the autoloading). Since I also use idle-loading for many packages, perceived latency is typically reduced overall.

On Linux, the same configuration loads in 0.32s.

If I don't use Emacs graphically, I can test the absolute minimum times. This is done by running:

time emacs -l init.elc -batch --eval '(message "Hello, world!")'
On the Mac I see an average of 0.36s for the same configuration, and on Linux 0.26s.
