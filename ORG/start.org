#-*- mode: org -*-
#+STARTUP: content
#+TODO: TODO DONE

* Pathes
** org files
[[file:weekly.org][weekly file]]
[[file:todo_plan.org][ToDo Plan org]]
[[file:monthly.org][Monthly file]]
[[file:GTD.org][GTD file]]
[[file:~/ORG/gtd/inbox.org][Inbox GTD File]]
[[file:~/ORG/gtd/tickler.org][Tikler Todo File]]
[[file:today.org][Today org file]]

(find-file "d:/My_Docs/Ofice/PaperFlow/TODO/todo_plan.org")
(find-file "d:/My_Docs/Ofice/PaperFlow/TODO/weekly.org")
(find-file "d:/My_Docs/Ofice/PaperFlow/TODO/monthly.org")
(find-file "d:/My_Docs/Ofice/PaperFlow/TODO/GTD.org")
(find-file "d:/My_Docs/Ofice/PaperFlow/TODO/today.org")

(find-file "~/ORG/gtd/gtd.org")
(find-file "~/ORG/gtd/inbox.org")
(find-file "~/ORG/gtd/tickler.org")
** init files
(find-file "~/INI/init.el")
(find-file "~/INI/inpak.el")
(find-file "~/INI/frame-control.el")
(find-file "~/INI/vanila_cfg.el")
(find-file "~/INI/c-mode-cfg.el")
(find-file "~/INI/evil-mod-cfg.el")
    (find-file "~/INI/origami_cfg.el")
(find-file "~/INI/init.el")
* Команды
** init files
(load "~/INI/evil-mod-cfg.el")
(load "~/INI/frame-control.el")
(load "~/INI/vanila_cfg.el")
** открыть
(find-file-other-frame "d:/My_Docs/Ofice/PaperFlow/TODO/todo.org")
(org-agenda nil "a")

** линкс команды
   C+c C+o
	[[shell:echo%20"hi%20Max"][Hello?]]
	[[shell:dir][Whera are u?]]
[[
shell:echo "dfgdfg max"
] [
Working?
]]
[[shell:echo "dfgdfg max"][Working?]]

[[shell:echo "dfgdfg max"]
[Working?]]
**  сорс комады
   C+c C+c
#+BEGIN_SRC sh :shcmd "cmdproxy.exe"
dir
#+END_SRC
#+BEGIN_SRC sh :exports both
ls
#+END_SRC
** Install
tar not found when trying to install from melpa 
You probably have an outdated package database
(package-refresh-contents)
(package-install company-irony)
** setings
*** systems paths
(setq exec-path (append exec-path '("D:/Development/CPP/CMake/bin/")))
	неменяет системную переменую только переменая емака взятая при запуске
(setenv "PATH" (concat (getenv "PATH") ";c:\\sw\\bin"))
(setq exec-path (append exec-path '("d:/sw/bin")))
	;; example of setting env var named “path”, by appending a new path to existing path

(setenv "PATH"
  (concat
   "C:/cygwin/usr/local/bin" ";"
   "C:/cygwin/usr/bin" ";"
   "C:/cygwin/bin" ";"
   (getenv "PATH")
  )
)
    You can use slash / and you don't have to use backslash \.
    Dir path may end with a path separator /, or without.
    the builtin variable path-separator can be used instead of ;.
;; show env var named path
(getenv "PATH")
* TODO натройка емака
  
** TODO Vims Tabs
*** Таб должен взаимодействоать с полнооконым режимом
если фул скри добовляет окна 4 с права
и помнит для каждого что в нём было
по доп нажатию фула в окне меняет местами содержания из доп окна и основного
** DONE Vims Folding 
   CLOSED: [2019-08-06 Вт 05:59]
** TODO настроить для работы с JS
   Найти файил с туториалом по настройке
   [[https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html]]
*** Mods
**** Indium
     https://github.com/NicolasPetton/Indium
A JavaScript development environment for Emacs.

Indium connects to a browser tab or nodejs process and provides many features for JavaScript development, including:

    a REPL (with auto completion) & object inspection;
    an inspector, with history and navigation;
    a scratch buffer (M-x indium-scratch);
    JavaScript evaluation in JS buffers with indium-interaction-mode;
    a stepping Debugger, similar to edebug, or cider.

** TODO настроить редактор 
*** TODO Понять что делать с языком 
- заменить в ивеле команду замены чтоб она понимала язык
*** TODO добовлять один символ
- [ ] энтер2
- [ ] 2пробел
- [ ] пробел + i\a(I\A)
** TODO Настроить емак для работы с Си 
 1) сварачивание
 2) авто дополнение
 3) снипиты
 4) подсветка
    + кода
    + скобок
    + курсора при альттабинге
 5) квикфикс
 6) оргмод литпрограминг
    - импор сорса в один файл
    - создание нового файла на основе
    - создание структуры папок
    - создание всего проеката на основе стуктурного описания (файлов и папок). с возможностью открытия следуших 
*** примеры удачных реализаций
**** Run shell command and jump to error workflow

 Hi all,

 I have recently started using Emacs(Doom) more and more seriously and really liking the experience. I have come so far that I feel pretty comfortable to use it at work without slowing down my efficiency that much. One aspect of my Vim workflow that I haven't found a good solution to however is building my project (C++) and running unit tests.

 With Vim I am used to using the plugin Asyncrun, https://github.com/skywind3000/asyncrun.vim. This plugin makes it possible to execute shell commands, typically calling the python script that runs build/ or the unit tests and printing the progress in the quickfix window. It would automatically parse the text and find errors and where they are located making it possible to use my keybinding for navigating the quickfix list to easily jump to an error, solve the issue and jump to the next one.

 So far I have only figured out a solution where I open a multiterm window and enable compilation-shell-minor-mode. Run the build command, go back to evil normal mode, M-x compilation-next-error-function. Switch window to the window with the code, fix the error, go to normal mode, switch back to shell window and repeat the process. This seems a little inefficient so I am sure there are better solutions out there but my Emacs skills are very low :)

 So I wonder what your workflows are like in Emacs? :)

 Cheers!
 4 comments
 100% Upvoted
 This thread is archived
 New comments cannot be posted and votes cannot be cast
 Sort by
 level 1
 rskiad
 12 points ·
 1 year ago
 · edited 1 year ago

 How about

 M-x compile RET whatever-command
 C-x `

 There is also projectile that provides projectile-compile-project and projectile-test-project that also work with next-error (C-x `)
 level 2
 squirelpower
 2 points ·
 1 year ago

 That's perfect, works exactly like I want it, many thanks! :)
 level 2
 oantolin
 1 point ·
 1 year ago
 · edited 1 year ago

 I prefer the keybinding M-g M-n for next-error and its companion M-g M-p for previous-error.
 level 2
 TabCompletion
 1 point ·
 1 year ago
 · edited 1 year ago

 I bound F6 for my next-error command. I also have a mondo compilation-error-regexp-alist regex to match errors:
** TODO Добавить функционал 
*** DONE пробел символ
	CLOSED: [2019-08-06 Вт 06:03]
*** ентер для пост символа
*** сдвиг строк
*** копия строк
** TODO работа с серийным портом
 - Передовать команды из буфера в открытый порт
 - посмотреть как настроен емак в видео с форсом
 - понять как реконектится наиболее быстро
   - командой
   - сочетание кнопок
   - строкой из скреч буфера
** Моды для емака
*** Ivy mods 
    [[https://www.youtube.com/watch?v=AaUlOH4GTCs]] youtube from where I get this 
    https://truthseekers.io/lessons/how-to-use-ivy-swiper-counsel-in-emacs-for-noobs/ text version lesson
    Ivy, Counsel, and Swiper are great if you can figure out how to use them!
 Luckily they are all pretty simple. In fact, you can just... install them and copy/paste some stuff and be on your way!
 I wanted to understand these emacs packages though, and that's a little more challenging.
    - ~Ivy~     :: is a package that helps you search. It helps you do things in M-x, or find file, and Dired, etc... Anything where you look for something in Emacs, Ivy can come to the rescue and help you type less. For example. Let's say I want to look through some Melpa packages. No longer do I have to type package-list-packages. Instead, I can just type "pa li packa" and Ivy will find all the results that match the search terms. Using spaces, you can target certain parts of what you're looking for. It just helps you type less. Ivy doesn't rely on anything, but
    - ~Swiper~  :: will automatically pull in Ivy when it's installed, because Swiper needs Ivy. Swiper does the same thing as Ivy, but replaces isearch, so you can use ivy features when searching through text.
    - ~Counsel~ :: gives you extra functions that aren't normally available. For example: You can open a buffer or file in a new window.
*** use-package


The easiest way is to install use-package.

(package-initialize)
(require 'package)
(add-to-list 'package-archives
    '("melpa" . "http://melpa.milkbox.net/packages/") t)

(dolist (package '(use-package))
   (unless (package-installed-p package)
       (package-install package)))

Then

 (use-package paredit
   :ensure t)

The :ensure t is what ensures that the package is installed.

To just load ensure multiple packages are install

(dolist (package '(package-a package-b package-c))
 (unless (package-installed-p package)
   (package-install package))
   (require package))))
   
*** hidra mod 
    https://github.com/abo-abo/hydra
This is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common prefix - a Hydra.
*** Mover mods
**** Avy mods
     - Avy :: is one of my favorite packages in Emacs.
     https://truthseekers.io/lessons/avy-emacs-tutorial-moving-around-emacs-quickly/
     Learning how to use Avy is one of the easiest and fastest ways to improve your efficiency in Emacs. The Avy Emacs package allows you to quickly get to any visible point in an Emacs buffer, window, or frame. By using one of the functions Avy provides, you define a search term, and Avy provides a "Tree" list of options to choose from. You choose the point you want your cursor to move to by typing one or two characters and BOOM, your cursor is exactly where you need it. The best part about Avy is how simple it is. You only need one or two key bindings, and you're good to go.
**** DONE Fast Emacs Window & Frame switching with WindMove & FrameMove 
	 CLOSED: [2019-08-06 Вт 05:49]
https://truthseekers.io/lessons/an-introduction-to-emacs-everything-you-need-to-know-to-get-started/
;; Remap windmove keys to home keys
(global-set-key (kbd "M-h") 'windmove-left)
(global-set-key (kbd "M-j") 'windmove-down)
(global-set-key (kbd "M-k") 'windmove-up)
(global-set-key (kbd "M-l") 'windmove-right)
*** quickfix-mode 
https://github.com/emacsmirror/quickfix-mode
    quickfix-mode consists of a series of quickfixes registered for your favourite programming mode. 
These will suggest a possible suggestion depending on the error (or warning) reported for flymake.
 Oh yes, _quickfix-mode depends_ on ~flymake~ (and ~popup~).
 https://github.com/auto-complete/popup-el
    Quickfix in action
Let's say flymake reports some errors in your code (in this case in erlang)
flymake errors and warnings
bar is undefined
C-c C-f to the rescue...
quickfix suggest it could define the function for us
selecting...and voila!
and the function is defined so that we can work on it
Exporting unused functions works too.
foo is unused :-o
quickfix to the rescue
and we're good!
*** Emacs Support for reStructuredText
    reStructuredText is a syntax for simple text files that allows a tool set - docutils - to extract generic document structure. For people who use Emacs, there is a package that adds a major mode that supports editing the syntax of reStructuredText: rst.el. This document describes the features it provides, and how to setup your Emacs to use them and how to invoke them.
    ~reStructuredText~ is an easy-to-read, what-you-see-is-what-you-get plaintext markup syntax and parser system. It is useful for in-line program documentation (such as Python docstrings), for quickly creating simple web pages, and for standalone documents. reStructuredText is designed for extensibility for specific application domains. The reStructuredText parser is a component of Docutils. reStructuredText is a revision and reinterpretation of the StructuredText and Setext lightweight markup systems.

The primary goal of reStructuredText is to define and implement a markup syntax for use in Python docstrings and other documentation domains, that is readable and simple, yet powerful enough for non-trivial use. The intended purpose of the markup is the conversion of reStructuredText documents into useful structured data formats.

See statemachine.py for an example of a Python module fully documented using reStructuredText.
** TODO Add lisp code
*** Folding on Org Mode vs C mode
If you want to exclude one specific mode, you can do the following:

(global-set-key (kbd "<C-S-down>") 'move-line-down) 

to make it globally available, and

(define-key KEYMAP (kbd "<C-S-down>") nil) 

to exclude one mode where KEYMAP is the name name of the mode, followed by "mode-map" (e.g. ess-mode-map). You could also bind the original thing to the key instead of nil.
shareimprove this answer

* TODO Оргаизовать Org Mod
** DONE Понять что работает а что нет
   SCHEDULED: <2018-10-26 Пт 16:50>
** DONE Понять как настраивать 
- много разных хелпов
- понял обшие принципы и вообще новерное разобрался
   SCHEDULED: <2018-10-26 Пт 15:10>
** TODO Разобратся с агендой
*** DONE разобрать фаил по подфайлам
	CLOSED: [2019-08-06 Вт 06:05]
*** DONE понять как разбить на карты повторного выполнения
	CLOSED: [2019-08-06 Вт 06:04]
*** настроить агеду чтоб показывать только глаыный фаили и зависиый родитель
*** DONE что делать с выполненыемт заданиями чтоб не замусоривать 
	CLOSED: [2019-08-06 Вт 06:04]
*** keys add agenda file
   C-c [     (org-agenda-file-to-front)

    Add current file to the list of agenda files. The file is added to the front of the list. If it was already in the list, it is moved to the front. With a prefix argument, file is added/moved to the end. 
C-c ]     (org-remove-file)

    Remove current file from the list of agenda files. 
   SCHEDULED: <2018-10-25 Чт 09:40>
*** comands to add agenda file
   (setq org-agenda-files '("~/org"))
   (setq org-agenda-files '("~/ORG/start.org"))
   (setq org-agenda-files (quote ("~/ORG/start.org")))
* Help Docs Emacs 
** info\help
   Check out the info manual for Org Mode with C-h i (info) to learn more, including how to customize the number of days initially displayed and what day your week starts on. 
   удобная систе показиваюшая мануалки по всем установленым модам
** Options
*** Visual
*** Text Eltments
**** Parenthesis
***** 5.27 How do I show which parenthesis matches the one I’m looking at?
  Call show-paren-mode in your .emacs file:
  (show-paren-mode 1)

  You can also enable this mode by selecting the ‘Paren Match Highlighting’ option from the ‘Options’ menu of the Emacs menu bar at the top of any Emacs frame.

  Alternatives to this mode include:

  If you’re looking at a right parenthesis (or brace or bracket) you can delete it and reinsert it. Emacs will momentarily move the cursor to the matching parenthesis.

  C-M-f (forward-sexp) and C-M-b (backward-sexp) will skip over one set of balanced parentheses, so you can see which parentheses match. (You can train it to skip over balanced brackets and braces at the same time by modifying the syntax table.)

  Here is some Emacs Lisp that will make the % key show the matching parenthesis, like in vi. In addition, if the cursor isn’t over a parenthesis, it simply inserts a % like normal.
  #+BEGIN_SRC elisp
;; By an unknown contributor
(global-set-key "%" 'match-paren)
(defun match-paren (arg)
"Go to the matching paren if on a paren; otherwise insert %."
    (interactive "p")
    (cond ((looking-at "\\s(") (forward-list 1) (backward-char 1))
	    ((looking-at "\\s)") (forward-char 1) (backward-list 1))
	    (t (self-insert-command (or arg 1)))))
  #+END_SRC


** Lisp
** Keyborde help 
*** evaluate
    27.9 Evaluating Emacs Lisp Expressions
Emacs Lisp mode is the major mode for editing Emacs Lisp. Its mode command is M-x emacs-lisp-mode.
Emacs provides several commands for evaluating Emacs Lisp expressions. You can use these commands in Emacs Lisp mode, to test your Emacs Lisp code as it is being written. For example, after re-writing a function, you can evaluate the function definition to make it take effect for subsequent function calls. These commands are also available globally, and can be used outside Emacs Lisp mode.
M-:
    Read a single Emacs Lisp expression in the minibuffer, evaluate it, and print the value in the echo area (eval-expression).
~C-x C-e~
    Evaluate the Emacs Lisp expression ~before point~, and print the value in the echo area (eval-last-sexp).
~C-M-x (in Emacs Lisp mode)~
~M-x eval-defun~
    Evaluate the defun containing or after point, and print the value in the echo area (eval-defun).
~M-x eval-region~
    Evaluate all the Emacs Lisp expressions in the region.
~M-x eval-buffer~
    Evaluate all the Emacs Lisp expressions in the buffer. 

M-: (eval-expression) reads an expression using the minibuffer, and evaluates it. (Before evaluating the expression, the current buffer switches back to the buffer that was current when you typed M-:, not the minibuffer into which you typed the expression.)

The command C-x C-e (eval-last-sexp) evaluates the Emacs Lisp expression preceding point in the buffer, and displays the value in the echo area. When the result of an evaluation is an integer, it is displayed together with the value in other formats (octal, hexadecimal, and character if eval-expression-print-maximum-character, described below, allows it).

If M-: or C-x C-e is given a prefix argument, it inserts the value into the current buffer at point, rather than displaying it in the echo area. If the prefix argument is zero, any integer output is inserted together with its value in other formats (octal, hexadecimal, and character). Such a prefix argument also prevents abbreviation of the output according to the variables eval-expression-print-level and eval-expression-print-length (see below). Similarly, a prefix argument of -1 overrides the effect of eval-expression-print-length.

The eval-defun command is bound to C-M-x in Emacs Lisp mode. It evaluates the top-level Lisp expression containing or following point, and prints the value in the echo area. In this context, a top-level expression is referred to as a “defun”, but it need not be an actual defun (function definition). In particular, this command treats defvar expressions specially. Normally, evaluating a defvar expression does nothing if the variable it defines already has a value. But this command unconditionally resets the variable to the initial value specified by the defvar; this is convenient for debugging Emacs Lisp programs. defcustom and defface expressions are treated similarly. Note that the other commands documented in this section do not have this special feature.

With a prefix argument, C-M-x instruments the function definition for Edebug, the Emacs Lisp Debugger. See Instrumenting for Edebug.

The command M-x eval-region parses the text of the region as one or more Lisp expressions, evaluating them one by one. M-x eval-buffer is similar but evaluates the entire buffer.

The options eval-expression-print-level and eval-expression-print-length control the maximum depth and length of lists to print in the result of the evaluation commands before abbreviating them. Supplying a zero prefix argument to eval-expression or eval-last-sexp causes lists to be printed in full. eval-expression-debug-on-error controls whether evaluation errors invoke the debugger when these commands are used; its default is t. eval-expression-print-maximum-character prevents integers which are larger than it from being displayed as characters. 
5.31 How do I execute (“evaluate”) a piece of Emacs Lisp code?
There are a number of ways to execute (evaluate, in Lisp lingo) an Emacs Lisp form:
    If you want it evaluated every time you run Emacs, put it in a file named .emacs in your home directory. This is known as “your .emacs file,” and contains all of your personal customizations.
    You can type the form in the *scratch* buffer, and then type <LFD> (or C-j) after it. The result of evaluating the form will be inserted in the buffer.
    ~In emacs-lisp-mode~, typing ~C-M-x~ evaluates a top-level form before or around point.
    Typing ~C-x C-e~ in ~any buffer~ evaluates the Lisp form immediately before point and prints its value in the echo area.
    Typing M-: or M-x eval-expression allows you to type a Lisp form in the minibuffer which will be evaluated once you press <RET>.
    You can use M-x load-file to have Emacs evaluate all the Lisp forms in a file. (To do this from Lisp use the function load instead.)
    The functions load-library, eval-region, eval-buffer, require, and autoload are also useful; see Emacs Lisp documentation, if you want to learn more about them. 
*** get help 
*** get menu command 
    Some of the commands in the menu bar have ordinary key bindings as well;
 if so, a key binding is shown after the item itself. 
To view the full ~command name~ and documentation for a menu item, type ~C-h k~,
 and then select the menu bar with the mouse in the usual way (see Key Help). 
*** coment line 
26.5.1 Comment Commands
The following commands operate on comments:
M-;
    Insert or realign comment on current line; if the region is active, comment or uncomment the region instead (comment-dwim).
~C-x C-;~
    Comment or uncomment the current line (comment-line). If the region is active, comment or uncomment the lines in the region instead.
C-u M-;
    Kill comment on current line (comment-kill).
C-x ;
    Set comment column (comment-set-column).
C-M-j
M-j
    Like <RET> followed by inserting and aligning a comment (comment-indent-new-line). See Multi-Line Comments.
M-x comment-region
C-c C-c (in C-like modes)
    Add comment delimiters to all the lines in the region. 

The command to create or align a comment is M-; (comment-dwim). The word “dwim” is an acronym for “Do What I Mean”; it indicates that this command can be used for many different jobs relating to comments, depending on the situation where you use it.
When a region is active (see Mark), M-; either adds comment delimiters to the region, or removes them. If every line in the region is already a comment, it uncomments each of those lines by removing their comment delimiters. Otherwise, it adds comment delimiters to enclose the text in the region.
If you supply a prefix argument to M-; when a region is active, that specifies the number of comment delimiters to add or delete. A positive argument n adds n delimiters, while a negative argument -n removes n delimiters.
If the region is not active, and there is no existing comment on the current line, M-; adds a new comment to the current line. If the line is blank (i.e., empty or containing only whitespace characters), the comment is indented to the same position where <TAB> would indent to (see Basic Indent). If the line is non-blank, the comment is placed after the last non-whitespace character on the line. Emacs tries to fit the comment between the columns specified by the variables comment-column and comment-fill-column (see Options for Comments), if possible. Otherwise, it will choose some other suitable position, usually separated from the non-comment text by at least one space. In each case, Emacs places point after the comment's starting delimiter, so that you can start typing the comment text right away.
You can also use M-; to align an existing comment. If a line already contains the comment-start string, M-; realigns it to the conventional alignment and moves point after the comment's starting delimiter. As an exception, comments starting in column 0 are not moved. Even when an existing comment is properly aligned, M-; is still useful for moving directly to the start of the comment text.
~C-x C-;~ (comment-line) comments or uncomments complete lines. When a region is active (see Mark), C-x C-; either comments or uncomments the lines in the region. If the region is not active, this command comments or uncomments the line point is on. With a positive prefix argument n, it operates on n lines starting with the current one; with a negative n, it affects n preceding lines. After invoking this command with a negative argument, successive invocations with a positive argument will operate on preceding lines as if the argument were negated.
C-u M-; (comment-dwim with a prefix argument) kills any comment on the current line, along with the whitespace before it. Since the comment is saved to the kill ring, you can reinsert it on another line by moving to the end of that line, doing C-y, and then M-; to realign the comment. You can achieve the same effect as C-u M-; by typing M-x comment-kill (comment-dwim actually calls comment-kill as a subroutine when it is given a prefix argument).
The command M-x comment-region is equivalent to calling M-; on an active region, except that it always acts on the region, even if the mark is inactive. In C mode and related modes, this command is bound to C-c C-c. The command M-x uncomment-region uncomments each line in the region; a numeric prefix argument specifies the number of comment delimiters to remove (negative arguments specify the number of comment delimiters to add).
For C-like modes, you can configure the exact effect of M-; by setting the variables c-indent-comment-alist and c-indent-comments-syntactically-p. For example, on a line ending in a closing brace, M-; puts the comment one space after the brace rather than at comment-column. For full details see Comment Commands. 
** REPL 
** DeBug
* Help Docs Org
** Welcome to Org mode
*** Marker sibols  
 You can make words 
 *bold*, /italic/, _underlined_, =code= and ~verbatim sdfsdfs~, 
 and, if you must, +strike-through+.
*** Lord of the Rings
    My favorite scenes are (in this order)
    1. Eowyn's fight with the witch king
       + this was already my favorite scene in the book
       + I really like Miranda Otto.
    2. The attack of the Rohirrim
    3. Peter Jackson being shot by Legolas
       - on DVD only
       He makes a really funny face when it happens.
    But in the end, no individual scenes matter but the film as a whole.
    Important actors in this film are:
    - Elijah Wood :: He plays Frodo
    - Sean Austin :: He plays Sam, Frodo's friend.  I still remember
      him very well from his role as Mikey Walsh in The Goonies.
** Help
*** info\manual
    Check out the info manual for Org Mode with C-h i (info) to learn more, including how to customize the number of days initially displayed and what day your week starts on. 
    удобная систе показиваюшая мануалки по всем установленым модам
*** links
**** Org Mode - Organize Your Life In Plain Text!
     http://doc.norang.ca/org-mode.html   
     очень последовательнвый манул по всему оргу с кучей примеров
** Tree Notes 
*** Exempls
  - Note taken on [2018-10-29 Пн 20:19] \\
    ladfdfd
    fdf
    df
    df
    ts add anoser note
    - sdfsdf sdf sdf sdfsd \\
    sdfsdfsdf
    sdfsdf sd fsd fd
    - some note?
	Intrasting where it puting this
    - d
    - sdf
    - sdfsdfsf
    - [X] 
    - [X] sdf
    - 
    - sdfsdfs sdf sdf sd[fn:1] 
    - 
*** Footnotes

[fn:1] The footnote.

[fn:2] Second footnote.
[fn:1] I not undestend ecthakli how this must work
** Help keys
*** Visibility cycling
Tab – show current
S-tab – show all children
C-u C-u C-u Tab – show all including drawers
Startup options
Editting
M-Ret – add element on the same level
M-S-Ret – insert TODO element
M-Right – demote current element
M-S-Right – deomote current subtree
M-Left – promote current element
M-S-Left – promote current subtree
M-S-Up – move current tree up
M-S-Down – move current tree down
C-c C-x C-w – kill current subtree
C-c C-x M-w – copy current subtree
C-c C-x C-y – yank subtree
C-x n s     (org-narrow-to-subtree)
    Narrow buffer to current subtree.
C-x n b     (org-narrow-to-block)
    Narrow buffer to current block.
C-x n w     (widen)
    Widen buffer to remove narrowing.
C-c *     (org-toggle-heading)
    Turn a normal line or plain list item into a headline (so that it becomes a subheading at its location). Also turn a headline into a normal line by removing the stars. If there is an active region, turn all lines in the region into headlines. If the first line in the region was an item, turn only the item lines into headlines. Finally, if the first line is a headline, remove the stars from all headlines in the region. 
*** Plain lists
Use M-Ret to add list item
Ordered list:

    First
    Second
    Third

Unordered lists

    abc
    efg

List with checkboxes (M-S-Ret)

    [ ] First element
    [X] Second element (C-c C-c – toggle checkbox state)
    [X] Third element
*** ToDo functionality
C-c C-t – rotate TODO state
S-Left, S-Right – rotate TODO state
S-M-Ret – insert new TODO note
(setq org-todo-keywords’((sequence “TODO” “FEEDBACK” “VERIFY” “|” “DONE” “DELEGATED”)))
Footnotes

*** unsort
More devices
C-c C-z – time-stamped drawer

    Note taken on [2013-09-02 Mon 23:54]
    My note here

[fn:2]
 C-c C-x f – footnote[fn:1]**
** Tabels
   | freeman | 1 | hucker |
   | max     | 1 | humen  |
   |---------+---+--------|
   |         |   |        |
  
   |---------+---+--------|
   |         |   |        |
** Tags 
Two: Which tags do you use most?
You can always add tags freely and by hand, but if you configure the most important ones along with fast-access keys, life will be better. Configure the variable org-tags-alist or simply do this right in the file with1
#+TAGS: home(h) work(w) @computer(c) @phone(p) errants(e)
** Todos 
*** Dependantistis 
**** TODO Blocked until (two) is done
***** DONE one
***** TODO two
**** Parent
     :PROPERTIES:
     :ORDERED:  t
     :END:
***** WAITING a
- isdf
- [ ] sdfs
- [X] sdfsdf
***** TODO b, needs to wait for (a)
***** TODO c, needs to wait for (a) and (b)

   You can ensure an entry is never blocked by using the NOBLOCKING property:

**** This entry is never blocked
     :PROPERTIES:
     :NOBLOCKING: t
     :END:

   C-c C-x o     (org-toggle-ordered-property)
*** Status 
  One: More TODO keywords
  Define the TODO states you find useful and single letters for fast selection. Customize the variable org-todo-keywords or simply do this right in the file with1:
  #+TODO: TODO(t) STARTED(s) WAITING(w) | DONE(d) CANCELED(c)
*** arhiv 
    c+c $ 
you can move them to an archive file with C-c $ (org-archive-subtree)отправляет в архи таким путём чистя агенду и лист
момет отправки помечается временени поидееии
и соответственно его скорй всего потом оможно будет от туда выташить и использовать 
*** shadule
    С+с С+s
  Next, we're going to schedule some tasks. Go to a task that you want to do today. Press C-c C-s (org-schedule) and accept the default. Schedule a couple of other tasks for today.

Schedule some tasks for tomorrow, too. This time, when you schedule it, type +1 for the date. You can specify +2 for the day after tomorrow, etc. The 28th? 28. If you want to schedule something for next Saturday, you can type sat. Two Tuesdays from now? 2thu. A month from now? 1m. It's really flexible. 
*** агендa
**** keys add agenda file
    C-c [     (org-agenda-file-to-front)

     Add current file to the list of agenda files. The file is added to the front of the list. If it was already in the list, it is moved to the front. With a prefix argument, file is added/moved to the end. 
 C-c ]     (org-remove-file)

     Remove current file from the list of agenda files. 
**** comands to add agenda file
    (setq org-agenda-files '("~/org"))
    (setq org-agenda-files '("~/ORG/start.org"))
    (setq org-agenda-files (quote ("~/ORG/start.org")))
*** *add a :CATEGORY: property to the top-level, non-TODO heading that identifies the project.  Using your example:

 * Project ABC
  :PROPERTIES:
  :CATEGORY: ABC
  :END:

 ** TODO A task related to Project ABC
 ** TODO Another task related to ABC
 *** TODO Subtask
SCHEDULED: 

In my bog-standard org-mode setup, this results in “ABC” being displayed in the far-left column of the agenda instead of just “todo” (which seems to be the default). This is great — it means that, in the text of the “Subtask” todo entry itself, I don’t need to include a reminder of what project the todo entry is associated with.

Here’s an agenda mockup to illustrate the point, augmented with a “default” entry from my own to-do list:

  todo:       Scheduled:  Follow up on expense reimbursement request
  ABC:        Scheduled:  Subtask

** Links 
   (define-key global-map "\C-cl" 'org-store-link)
Для того что бы создать ссылку достаточно использовать такой шаблон — [[ссылка][описание]].
  [ {] [] ]

Для создания ссылки можно ещё использовать комбинацию C+c C+l. В мини-буфере emacs предложит сначала написать ссылку, затем после нажатия RET — её создать. Находясь в мини-буфере так же можно нажать TAB, для просмотра, какие виды ссылок бывают.

Что бы открыть вновь созданные ссылки необходимо навести точку на ссылку и тыкнуть C+c C+o. Или C+u C+c C+o — если Вы хотите открыть её в другом окне.

Ради интереса, можно перейти в другой файл, нажать там C+c l. И ссылка на этот файл поместится в хранилище ссылок. Перейдя в любой наш файл .org мы можем извлечь из этого хранилища любые сохраненные ссылки, с помощью той же команды C+c C+l.
Самые наблюдательные читатели уже могли заметить, что эта команда как раз и есть та, которую мы вписали в ~/.emacs, в начале.
   [[https://orgmode.org/org.pdf][Link to 304p doc about org]]
* Help Docs Gnus
  The Emacs news and email reader.

