* Wellcome! Don`t panic!
** Set 
#-*- mode: org -*-
#+STARTUP: overview 
#+TODO: TODO DONE
** Like a craftsman entering his workshop : 
Whenever I open Emacs, I feel inspired. Like a craftsman entering his workshop, I feel a realm of possibility open before me. I feel the comfort of an environment that has evolved over time to fit me perfectly—an assortment of packages and key bindings that help me bring ideas to life day after day.
https://www.braveclojure.com/basic-emacs/
| |_| |_| |           | |_| |_| |
 \ _____ /      o_     \ _____ /
  |     |       |_|     |     |
  |  |  |       |       |  |  |
  |   _ } _   _ | _   _ { _   |
  |  | |_| |_| ||| |_| |_| |  |
  |  |                     |  |
  || |                     | ||
  |  |        _____        |  |
  |  |       /_|_|_\       |  |
  |  |      /|_|_|_|\      |  |
  |  |      ||_|_|_||      |  |
  |  |      ||_|_|_||      |  |
  |__|      ||_|_|_||      |__|
 /   |      ||_|_|_||      |   \
=================================
** Tmp  
|        |        |   |   |   |
|--------+--------+---+---+---|
|        |        |   |   |   |
|        |        |   |   |   |
|        |        |   |   |   |
|        |        |   |   |   |
|--------+--------+---+---+---|
|        |        |   |   |   |
| sdfsdf | sdfsfd |   |   |   |
|--------+--------+---+---+---|
| sdf    |        |   |   |   |
|        | sdfsdf |   |   |   |
|        |        |   |   |   |
|--------+--------+---+---+---|
#+TBLFM: @II-1$2:=191

(setq path-to-emagus-cmd "d:/Development/lisp/Emacs/bin/runemacs.exe")

(defun buyn-start-emagus (unix-path-to-file)
  "	buyn start new emacs process
		as parametr  
		get file path in unix format
		unix-path-to-file path to file in unix format
		"
  (shell-command
		;; (message
		(concat path-to-emagus-cmd
						" "
						unix-path-to-file)
		)
  )
** Templats 
*** Туду
**** сделать
**** в процесе
**** завершно
*** Kanban
**** todo
**** in progress 
**** done
*** Ezenhaur 
**** Срочное и важное
**** Срочное но не важное
**** Важное но не срочное 
**** Не Срочное и не важное
*** SWOT 
**** Strengths
**** Weaknesses
**** Opportunities
**** Threats
** progn : 
#+begin_src emacs-lisp :results output silent
	(setq minimap-major-modes '(prog-mode org-mode Info-mode))
#+end_src
(progn
		) progn end
** Rogue 
*** templ
|---+---+---+---+---|
|   |   |   |   |   |
|   | # | # | # |   |
|   | # | # | # |   |
|   | # |   |   |   |
|   | # |   | # | # |
|   |   |   | # | # |
|   |   | @ |   |   |
|---+---+---+---+---|
** Calc 
*** random
		Выдаёт между 0-1
(random 2)
		Выдаёт между 0-99
(random 100)
		Выдаёт между 1-100
(+ (random 100) 1)
		Выдаёт между 10-100 (проверил)
(+ (random 91) 10)
*** time 
(setq-local pom 25)
(setq-local h 60)
(defun min-to-houre (min-in)
		(let ((hour (/ min-in 60)))
		 (message "%s:%s" hour (- min-in (* hour 60)))))
(/ h pom)
(* 4 pom)
(min-to-houre 100)

* Pathes
** init files
*** root
(find-file "~/.emacs")
	(find-file-other-frame "~/INI/init.el")
*** vanila
(find-file-other-frame "~/INI/inpak.el")
(find-file-other-frame "~/INI/vanila_cfg.el")
*** Evil
	(find-file-other-frame "~/INI/evil-mod-cfg.el")
	(find-file-other-frame "~/ELs/Evil/evil-respect-input.el")
	(find-file-other-frame "~/ELs/Evil/onecharadd.el") not used
	(find-file-other-frame "~/ELs/Evil/copylines.el") пока нет
*** Orgs
(find-file-other-frame "~/INI/org-cfg.el")
	(find-file-other-frame "~/INI/org_agend_cfg.el")
	(find-file-other-frame "~/INI/babel-cfg.el")
	(find-file-other-frame "~/ELs/Org/Babel/ob-eshell.el")
	(find-file-other-frame "~/INI/org-brain-cfg.el") 
*** Folding
(find-file-other-frame "~/INI/folding-cfg.el")
	(find-file-other-frame "~/INI/outshine_cfg.el")
	(find-file-other-frame "~/INI/origami_cfg.el") not using
	но содержит в себе огромное количество класных решенией
	которые нужно перенести в outshine-mod
		(find-file-other-frame "~/ELs/Evil/origami_triplebrase.el")
*** frame : 
(find-file-other-frame "~/INI/frame-control.el")
	(find-file-other-frame "~/INI/fullscreen-cfg.el")
		(find-file-other-frame "~/INI/frames/minimap-cfg.el")
		minimap-mode loading
*** Other 
(find-file-other-frame "~/INI/advnsed-selections-cfg.el")
(find-file-other-frame "~/INI/www-cfg.el") not used
*** interface
(find-file-other-frame "~/INI/interface-mods.el")
	(find-file-other-frame "~/INI/interface/powerline-cfg.el") 
		(find-file-other-frame "~/INI/interface/jonathanchu-emacs-powerline-cfg.el") 
			(find-file-other-frame "~/ELs/powerline/sm-package-powerline.el")notuse
		(find-file-other-frame "~/INI/interface/spaceline-cfg.el") notuse
*** Hydra menu
 (find-file-other-frame "~/INI/hydra-cfg.el")
*** literary 
(find-file-other-frame "~/INI/lit-cfg.el") 
	(find-file-other-frame "~/INI/translate-cfg.el") not et
	(find-file-other-frame "~/INI/grammer-cfg.el") not et
*** Programing
(find-file-other-frame "~/INI/dev-cfg.el")
	(find-file-other-frame "~/INI/autocomplete-cfg.el")
	(find-file-other-frame "~/INI/snippets-cfg.el")
	(find-file-other-frame "~/INI/delimiters-cfg.el")
	(find-file-other-frame "~/INI/js-cfg.el") not used
	(find-file-other-frame "~/INI/lua-cfg.el")
	(find-file-other-frame "~/INI/python-cfg.el")
	(find-file-other-frame "~/INI/dev/csharp-cfg.el")
	(find-file-other-frame "~/INI/dev/clojure-cfg.el")
	(find-file-other-frame "~/INI/dev/unity-cfg.el")
	(find-file-other-frame "~/INI/c-mode-cfg.el") not used
	(find-file-other-frame "~/INI/flycheck-cfg.el") 
*** My Elisp
	(find-file-other-frame "~/ELs/BuYn/shell.el")
** org files
*** lincks
[[file:~/../Dropbox/orgs/weekly.org][weekly file]]
[[file:~/../Dropbox/orgs/todo_plan.org][ToDo Plan org]]
[[file:~/../Dropbox/orgs/monthly.org][Monthly file]]
[[file:GTD.org][GTD file]]
[[file:today.org][Today org file]]
[[file:~/ORG/gtd/inbox.org][Inbox GTD File]]
[[file:~/ORG/gtd/tickler.org][Tikler Todo File]]
*** main todos
(find-file "D:/Development/lisp/Dropbox/orgs/weekly.org")
(find-file "~/../Dropbox/orgs/todo_main.org")
(find-file "~/../Dropbox/orgs/todo_plan.org")
(find-file "~/../Dropbox/orgs/todo_LongRun.org")
*** uptown todos
файлы для Вышгорода
(find-file "~/../Dropbox/orgs/uptown/todo_rasps.org")
(find-file "~/../Dropbox/orgs/uptown/todo_uplan.org")
*** tools
(find-file-other-frame "~/../Desktop/orgs/capture/Pensieve.org")
*** captures
(find-file-other-frame "~/../Desktop/orgs/capture/Pensieve.org")
(find-file "~/../Desktop/orgs/capture/Pensieve.org")
(find-file-other-frame "~/../Desktop/orgs/capture/astronomicon.org")
(find-file "~/../Desktop/orgs/capture/astronomicon.org")
(find-file-other-frame "~/../Desktop/orgs/capture/emagus.org")
(find-file "~/../Desktop/orgs/capture/emagus.org")
*** gts 
(find-file "~/ORG/gtd/gtd.org")
(find-file "~/ORG/gtd/inbox.org")
(find-file "~/ORG/gtd/tickler.org")
** exempl
(find-file "~/../hi.txt")
*Help Docs Emacs 
* Команды
** reload init files
(load "~/INI/hydra-cfg.el")
(load "~/INI/evil-mod-cfg.el")
(load "~/INI/frame-control.el")
(load "~/INI/vanila_cfg.el")
(load "~/INI/origami_cfg.el")
(load "~/INI/folding-cfg.el")
(load "~/INI/org-cfg.el")
(load "~/INI/lit-cfg.el")
(load "~/INI/dev-cfg.el")
(load "~/INI/interface-mods.el")
(load "~/ELs/BuYn/shell.el")
** load init files
(load "~/INI/org-brain-cfg.el")
** открыть
(find-file-other-frame "d:/My_Docs/Ofice/PaperFlow/TODO/todo.org")
(org-agenda nil "a")
** Agenda
*** revert 
(org-revert-all-org-buffers)
*** open 

** Install
tar not found when trying to install from melpa 
You probably have an outdated package database
(package-refresh-contents)
(package-install "company-irony")
remove pacage
нужно водом команды в m-x m-y
поскольку Поскольку название пакета отличается от его названия
наличием циферхеша 
m-x
package-delete
** setings
*** systems paths
(setq exec-path (append exec-path '("D:/Development/CPP/CMake/bin/")))
	неменяет системную переменую только переменая емака взятая при запуске
(setenv "PATH" (concat (getenv "PATH") ";c:\\sw\\bin"))
(setq exec-path (append exec-path '("d:/sw/bin")))
	;; example of setting env var named “path”, by appending a new path to existing path

(setenv "PATH"
  (concat
   "C:/cygwin/usr/local/bin" ";"
   "C:/cygwin/usr/bin" ";"
   "C:/cygwin/bin" ";"
   (getenv "PATH")
  )
)
    You can use slash / and you don't have to use backslash \.
    Dir path may end with a path separator /, or without.
    the builtin variable path-separator can be used instead of ;.
;; show env var named path
(getenv "PATH")
*** for Source
(origami-mode)
(outline-minor-mode)
** линкс команды
	 C+c C+o
	[[shell:echo%20"hi%20Max"][Hello?]]
	[[shell:dir][Whera are u?]]
[[
shell:echo "dfgdfg max"
] [
Working?
]]
[[shell:echo "dfgdfg max"][Working?]]

[[shell:echo "dfgdfg max"]
[Working?]]

* Help Docs Emacs 
** To set on a file by file 
To set the VisualLineMode on a file by file basis using emacs local variables, try:
    #  local variables:
    #    eval: (visual-line-mode t)
** Install package
*** lisp auto code
		#+begin_src emacs-lisp :tangle yes
 (unless (package-installed-p 'yasnippet-snippets)
   (package-install 'yasnippet-snippets))
 (require 'yasnippet-snippets)
		#+end_src
*** устанавливать в ручную : 
;; только если устанавливать в ручную
;; (add-to-list 'load-path
;;               "~/.emacs.d/plugins/yasnippet")
*** autoload : 
(autoload 'helm-company "helm-company") ;; Not necessary if using ELPA package
*** eval-after-load : 
(eval-after-load 'company
  '(progn
     (define-key company-mode-map (kbd "C-:") 'helm-company)
     (define-key company-active-map (kbd "C-:") 'helm-company)))
*** describe-package
describe-package

** load require: 
	#+begin_src emacs-lisp :tangle yes
(eval-after-load 'company
  '(add-to-list
    'company-backends '(company-irony-c-headers company-irony)))
(eval-after-load 'company
  '(add-to-list 'company-backends 'company-irony))
(require 'company)
(add-hook 'after-init-hook 'global-company-mode)
(global-set-key "\t" 'company-complete-common)
	#+end_src
** Keyborde help 
*** evaluate
****    27.9 Evaluating Emacs Lisp Expressions
Emacs Lisp mode is the major mode for editing Emacs Lisp. Its mode command is M-x emacs-lisp-mode.
Emacs provides several commands for evaluating Emacs Lisp expressions. You can use these commands in Emacs Lisp mode, to test your Emacs Lisp code as it is being written. For example, after re-writing a function, you can evaluate the function definition to make it take effect for subsequent function calls. These commands are also available globally, and can be used outside Emacs Lisp mode.
M-:
    Read a single Emacs Lisp expression in the minibuffer, evaluate it, and print the value in the echo area (eval-expression).
~C-x C-e~
    Evaluate the Emacs Lisp expression ~before point~, and print the value in the echo area (eval-last-sexp).
~C-M-x (in Emacs Lisp mode)~
~M-x eval-defun~
    Evaluate the defun containing or after point, and print the value in the echo area (eval-defun).
~M-x eval-region~
    Evaluate all the Emacs Lisp expressions in the region.
~M-x eval-buffer~
    Evaluate all the Emacs Lisp expressions in the buffer. 

M-: (eval-expression) reads an expression using the minibuffer, and evaluates it. (Before evaluating the expression, the current buffer switches back to the buffer that was current when you typed M-:, not the minibuffer into which you typed the expression.)

The command C-x C-e (eval-last-sexp) evaluates the Emacs Lisp expression preceding point in the buffer, and displays the value in the echo area. When the result of an evaluation is an integer, it is displayed together with the value in other formats (octal, hexadecimal, and character if eval-expression-print-maximum-character, described below, allows it).

If M-: or C-x C-e is given a prefix argument, it inserts the value into the current buffer at point, rather than displaying it in the echo area. If the prefix argument is zero, any integer output is inserted together with its value in other formats (octal, hexadecimal, and character). Such a prefix argument also prevents abbreviation of the output according to the variables eval-expression-print-level and eval-expression-print-length (see below). Similarly, a prefix argument of -1 overrides the effect of eval-expression-print-length.

The eval-defun command is bound to C-M-x in Emacs Lisp mode. It evaluates the top-level Lisp expression containing or following point, and prints the value in the echo area. In this context, a top-level expression is referred to as a “defun”, but it need not be an actual defun (function definition). In particular, this command treats defvar expressions specially. Normally, evaluating a defvar expression does nothing if the variable it defines already has a value. But this command unconditionally resets the variable to the initial value specified by the defvar; this is convenient for debugging Emacs Lisp programs. defcustom and defface expressions are treated similarly. Note that the other commands documented in this section do not have this special feature.

With a prefix argument, C-M-x instruments the function definition for Edebug, the Emacs Lisp Debugger. See Instrumenting for Edebug.

The command M-x eval-region parses the text of the region as one or more Lisp expressions, evaluating them one by one. M-x eval-buffer is similar but evaluates the entire buffer.

The options eval-expression-print-level and eval-expression-print-length control the maximum depth and length of lists to print in the result of the evaluation commands before abbreviating them. Supplying a zero prefix argument to eval-expression or eval-last-sexp causes lists to be printed in full. eval-expression-debug-on-error controls whether evaluation errors invoke the debugger when these commands are used; its default is t. eval-expression-print-maximum-character prevents integers which are larger than it from being displayed as characters. 
5.31 How do I execute (“evaluate”) a piece of Emacs Lisp code?
There are a number of ways to execute (evaluate, in Lisp lingo) an Emacs Lisp form:
    If you want it evaluated every time you run Emacs, put it in a file named .emacs in your home directory. This is known as “your .emacs file,” and contains all of your personal customizations.
    You can type the form in the *scratch* buffer, and then type <LFD> (or C-j) after it. The result of evaluating the form will be inserted in the buffer.
    ~In emacs-lisp-mode~, typing ~C-M-x~ evaluates a top-level form before or around point.
    Typing ~C-x C-e~ in ~any buffer~ evaluates the Lisp form immediately before point and prints its value in the echo area.
    Typing M-: or M-x eval-expression allows you to type a Lisp form in the minibuffer which will be evaluated once you press <RET>.
    You can use M-x load-file to have Emacs evaluate all the Lisp forms in a file. (To do this from Lisp use the function load instead.)
    The functions load-library, eval-region, eval-buffer, require, and autoload are also useful; see Emacs Lisp documentation, if you want to learn more about them. 
**** python
***** run unit test
 C-c C-t [elpy-test]

*** get help 
**** get menu command 
     Some of the commands in the menu bar have ordinary key bindings as well;
	if so, a key binding is shown after the item itself. 
 To view the full ~command name~ and documentation for a menu item, type ~C-h k~,
	and then select the menu bar with the mouse in the usual way (see Key Help). 
*** coment line 
26.5.1 Comment Commands
The following commands operate on comments:
M-;
    Insert or realign comment on current line; if the region is active, comment or uncomment the region instead (comment-dwim).
~C-x C-;~
    Comment or uncomment the current line (comment-line). If the region is active, comment or uncomment the lines in the region instead.
C-u M-;
    Kill comment on current line (comment-kill).
C-x ;
    Set comment column (comment-set-column).
C-M-j
M-j
    Like <RET> followed by inserting and aligning a comment (comment-indent-new-line). See Multi-Line Comments.
M-x comment-region
C-c C-c (in C-like modes)
    Add comment delimiters to all the lines in the region. 

The command to create or align a comment is M-; (comment-dwim). The word “dwim” is an acronym for “Do What I Mean”; it indicates that this command can be used for many different jobs relating to comments, depending on the situation where you use it.
When a region is active (see Mark), M-; either adds comment delimiters to the region, or removes them. If every line in the region is already a comment, it uncomments each of those lines by removing their comment delimiters. Otherwise, it adds comment delimiters to enclose the text in the region.
If you supply a prefix argument to M-; when a region is active, that specifies the number of comment delimiters to add or delete. A positive argument n adds n delimiters, while a negative argument -n removes n delimiters.
If the region is not active, and there is no existing comment on the current line, M-; adds a new comment to the current line. If the line is blank (i.e., empty or containing only whitespace characters), the comment is indented to the same position where <TAB> would indent to (see Basic Indent). If the line is non-blank, the comment is placed after the last non-whitespace character on the line. Emacs tries to fit the comment between the columns specified by the variables comment-column and comment-fill-column (see Options for Comments), if possible. Otherwise, it will choose some other suitable position, usually separated from the non-comment text by at least one space. In each case, Emacs places point after the comment's starting delimiter, so that you can start typing the comment text right away.
You can also use M-; to align an existing comment. If a line already contains the comment-start string, M-; realigns it to the conventional alignment and moves point after the comment's starting delimiter. As an exception, comments starting in column 0 are not moved. Even when an existing comment is properly aligned, M-; is still useful for moving directly to the start of the comment text.
~C-x C-;~ (comment-line) comments or uncomments complete lines. When a region is active (see Mark), C-x C-; either comments or uncomments the lines in the region. If the region is not active, this command comments or uncomments the line point is on. With a positive prefix argument n, it operates on n lines starting with the current one; with a negative n, it affects n preceding lines. After invoking this command with a negative argument, successive invocations with a positive argument will operate on preceding lines as if the argument were negated.
C-u M-; (comment-dwim with a prefix argument) kills any comment on the current line, along with the whitespace before it. Since the comment is saved to the kill ring, you can reinsert it on another line by moving to the end of that line, doing C-y, and then M-; to realign the comment. You can achieve the same effect as C-u M-; by typing M-x comment-kill (comment-dwim actually calls comment-kill as a subroutine when it is given a prefix argument).
The command M-x comment-region is equivalent to calling M-; on an active region, except that it always acts on the region, even if the mark is inactive. In C mode and related modes, this command is bound to C-c C-c. The command M-x uncomment-region uncomments each line in the region; a numeric prefix argument specifies the number of comment delimiters to remove (negative arguments specify the number of comment delimiters to add).
For C-like modes, you can configure the exact effect of M-; by setting the variables c-indent-comment-alist and c-indent-comments-syntactically-p. For example, on a line ending in a closing brace, M-; puts the comment one space after the brace rather than at comment-column. For full details see Comment Commands. 
*** Rebind keys
**** keys to keys
(global-set-key (kbd "<f7>") (kbd "C-u C-c C-c"))
** Environment Variable 
*** "PATH" : 
**** Описание бага\фичи
	 переменая енворемент обновляется только после перезапуска системы
 тоесть после установки нового софта - он не виден даже после перезапуска емак
 ещё могут быть проблемы посколько есть переменая пути систему
 а есть переменая запуска емака и есть переменая рабочей деректории емака
***** решение:
	  установить инворемнт перемуную в ручную для запушеного еворемента
	  из емака
***** фича
	  есть возможность поексмеремтиовать 
	  если нет уверености что всё настроено как надо
**** setenv "PATH" : 
  ;; example of setting env var named “path”, by appending a new path to existing path
  (setenv "PATH"
	(concat
	 "C:/cygwin/usr/local/bin" ";"
	 "C:/cygwin/usr/bin" ";"
	 "C:/cygwin/bin" ";"
	 (getenv "PATH")
	)
  )
**** getenv "PATH" : 
 (to evaluate elisp code, select it and Alt+x eval-region.
 [see Evaluate Emacs Lisp Code])
	 (getenv "PATH")
**** edit in file
	 copy to *scratch*
(progn
(forward-line 3)
(insert (getenv "PATH"))
)
  (setenv "PATH"
"

"
)
*** SHELL : 
If the path printed by evaluating (getenv "SHELL") in Emacs points at bash
or zsh, this should work fine.
**** getenv : 
(getenv "SHELL")
"D:/Development/lisp/Emacs/libexec/emacs/26.2/x86_64-w64-mingw32/cmdproxy.exe"

*** exec-path
**** Difference between exec-path and PATH
	 The value of environment variable “PATH” is used by emacs when you are running a shell in emacs, similar to when you are using a shell in a terminal.
	 The exec-path is used by emacs itself to find programs it needs for its features, such as spell checking, file compression, compiling, grep, diff, etc.

(when (string-equal system-type "windows-nt")
  (setq exec-path
'(
"C:/Program Files (x86)/Emacs/emacs/bin/"
"C:/Program Files (x86)/Emacs/EmacsW32/gnuwin32/bin/"
"C:/Windows/system32/"
"C:/Windows/"
"C:/Windows/System32/Wbem/"
"C:/Windows/system32/WindowsPowerShell/v1.0/"
)
 ))
**** показать exec-path
(message exec-path)
  (setq exec-path)
**** set
    (setq exec-path (append exec-path '("/sw/bin")))
    (setenv "PATH" (concat (getenv "PATH") ":/sw/bin"))
**** Emacs Lisp Code for Setting PATH and exec-path in sync
(when (string-equal system-type "windows-nt")
  (let (
        (mypaths
         '(
           "C:/Python27"
           ;; "C:/Python32"
           "C:/strawberry/c/bin"
           "C:/strawberry/perl/site/bin"
           "C:/strawberry/perl/bin"

           "C:/Users/h3/AppData/Roaming/npm"
           "C:/Program Files (x86)/nodejs/"

           "C:/cygwin/usr/local/bin"
           "C:/cygwin/usr/bin"
           "C:/cygwin/bin"

           "C:/Program Files (x86)/ErgoEmacs/msys/bin"
           "C:/Program Files (x86)/Mozilla Firefox/"
           "C:/Program Files (x86)/Opera"
           "C:/Program Files (x86)/Safari"
           "C:/Users/h3/AppData/Local/Google/Chrome/Application"
           ) )
        )

    (setenv "PATH" (mapconcat 'identity mypaths ";") )

    (setq exec-path (append mypaths (list "." exec-directory)) )
    ) )
*** Operating System Environment
Emacs provides access to variables in the operating system environment
through various functions.  These variables include the name of the
system, the user’s UID, and so on.
**** Variable: system-configuration
 This variable holds the standard GNU configuration name for the
 hardware/software configuration of your system, as a string.  For
 example, a typical value for a 64-bit GNU/Linux system is
 ‘"x86_64-unknown-linux-gnu"’.
**** Variable: system-type
 The value of this variable is a symbol indicating the type of operating
 system Emacs is running on.  The possible values are:
	We do not wish to add new symbols to make finer distinctions unless it
	is absolutely necessary!  In fact, we hope to eliminate some of these
	alternatives in the future.  If you need to make a finer distinction
	than system-type allows for, you can test
	system-configuration, e.g., against a regexp.
***** aix
  IBM’s AIX.
***** berkeley-unix
   Berkeley BSD and its variants.
***** cygwin
	Cygwin, a Posix layer on top of MS-Windows.
***** 	darwin
	 Darwin (Mac OS X).
***** 	gnu
	 The GNU system (using the GNU kernel, which consists of the HURD and Mach).
***** 	gnu/linux
	 A GNU/Linux system—that is, a variant GNU system, using the Linux
	 kernel.  (These systems are the ones people often call “Linux”, but
	 actually Linux is just the kernel, not the whole system.)
***** 	gnu/kfreebsd
	 A GNU (glibc-based) system with a FreeBSD kernel.
***** 	hpux
	 Hewlett-Packard HPUX operating system.
***** 	irix
	 Silicon Graphics Irix system.
***** 	nacl
	 Google Native Client (NaCl) sandboxing system.
***** 	ms-dos
	 Microsoft’s DOS.  Emacs compiled with DJGPP for MS-DOS binds
	 system-type to ms-dos even when you run it on MS-Windows.
***** 	usg-unix-v
	 AT&T Unix System V.
***** 	windows-nt
	 Microsoft Windows NT, 9X and later.  The value of system-type
	 is always windows-nt, e.g., even on Windows 10.
**** Function: system-name
 This function returns the name of the machine you are running on, as a
 string.
**** User Option: mail-host-address
 If this variable is non-nil, it is used instead of
 system-name for purposes of generating email addresses.  For
 example, it is used when constructing the default value of
 user-mail-address.  See User Identification.  (Since this is
 done when Emacs starts up, the value actually used is the one saved when
 Emacs was dumped.  See Building Emacs.)
**** Command: getenv var &optional frame

 This function returns the value of the environment variable var,
 as a string.  var should be a string.  If var is undefined
 in the environment, getenv returns nil.  It returns
 ‘""’ if var is set but null.  Within Emacs, a list of environment
 variables and their values is kept in the variable process-environment.


 (getenv "USER")
      ⇒ "lewis"


 The shell command printenv prints all or part of the environment:


 bash$ printenv
 PATH=/usr/local/bin:/usr/bin:/bin
 USER=lewis
 TERM=xterm
 SHELL=/bin/bash
 HOME=/home/lewis
 …
**** Command: setenv variable &optional value substitute
 This command sets the value of the environment variable named
 variable to value.  variable should be a string.
 Internally, Emacs Lisp can handle any string.  However, normally
 variable should be a valid shell identifier, that is, a sequence
 of letters, digits and underscores, starting with a letter or
 underscore.  Otherwise, errors may occur if subprocesses of Emacs try
 to access the value of variable.  If value is omitted or
 nil (or, interactively, with a prefix argument), setenv
 removes variable from the environment.  Otherwise, value
 should be a string.

 If the optional argument substitute is non-nil, Emacs
 calls the function substitute-env-vars to expand any
 environment variables in value.

 setenv works by modifying process-environment; binding
 that variable with let is also reasonable practice.

 setenv returns the new value of variable, or nil
 if it removed variable from the environment.
**** Variable: process-environment
 This variable is a list of strings, each describing one environment
 variable.  The functions getenv and setenv work by means
 of this variable.


 process-environment
 => ("PATH=/usr/local/bin:/usr/bin:/bin"
     "USER=lewis"
     "TERM=xterm"
     "SHELL=/bin/bash"
     "HOME=/home/lewis"
     …)


 If process-environment contains multiple elements that
 specify the same environment variable, the first of these elements
 specifies the variable, and the others are ignored.
**** Variable: initial-environment
 This variable holds the list of environment variables Emacs inherited
 from its parent process when Emacs started.
**** Variable: path-separator
 This variable holds a string that says which character separates
 directories in a search path (as found in an environment variable).  Its
 value is ":" for Unix and GNU systems, and ";" for MS systems.
**** Function: parse-colon-path path
 This function takes a search path string such as the value of
 the PATH environment variable, and splits it at the separators,
 returning a list of directory names.  nil in this list means
 the current directory.  Although the function’s name says
 “colon”, it actually uses the value of path-separator.
 (parse-colon-path ":/foo:/bar")
      => (nil "/foo/" "/bar/")
**** Variable: invocation-name
 This variable holds the program name under which Emacs was invoked.  The
 value is a string, and does not include a directory name.
**** Variable: invocation-directory
 This variable holds the directory from which the Emacs executable was
 invoked, or nil if that directory cannot be determined.
**** Variable: installation-directory
 If non-nil, this is a directory within which to look for the
 lib-src and etc subdirectories.  In an installed Emacs,
 it is normally nil.  It is non-nil
 when Emacs can’t find those directories in their standard installed
 locations, but can find them in a directory related somehow to the one
 containing the Emacs executable (i.e., invocation-directory).
**** Function: load-average &optional use-float
 This function returns the current 1-minute, 5-minute, and 15-minute
 system load averages, in a list.  The load average indicates the
 number of processes trying to run on the system.

 By default, the values are integers that are 100 times the system load
 averages, but if use-float is non-nil, then they are
 returned as floating-point numbers without multiplying by 100.

 If it is impossible to obtain the load average, this function signals
 an error.  On some platforms, access to load averages requires
 installing Emacs as setuid or setgid so that it can read kernel
 information, and that usually isn’t advisable.

 If the 1-minute load average is available, but the 5- or 15-minute
 averages are not, this function returns a shortened list containing
 the available averages.


 (load-average)
      ⇒ (169 48 36)
 (load-average t)
      ⇒ (1.69 0.48 0.36)


 The shell command uptime returns similar information.
**** Function: emacs-pid
 This function returns the process ID of the Emacs process,
 as an integer.
**** Variable: tty-erase-char
 This variable holds the erase character that was selected
 in the system’s terminal driver, before Emacs was started.
** Customize 
*** by menu
To customize rainbow-delimiters mode, you can use:
M-x customize-group rainbow-delimiters
Color Scheme

customize-group rainbow-delimiters-faces has the faces for successive nested pairs of delimiters. You can change them through emacs customize or in your color theme or dot-emacs.

The face rainbow-delimiters-unmatched-face is used for unmatched closing delimiters.

Zenburn and Solarized themes have their own colors for these faces.

deftheme/color-theme.el: Further information is at the top of rainbow-delimiters.el.
Stop Highlighting Certain Delimiters

You can disable highlighting of any of the supported delimiter types through the customize interface, in the Toggle Delimiters section. 
*** using command
используя названия из меню можно подобрать подходяшию команду
на основе примера
	;; (custom-theme-set-faces
	;; 'material
	;; `(outline-1 ((t (:height 1.25 :weight bold))))
	;; `(outline-2 ((t (:height 1.15 :weight bold))))
	;; `(outline-3 ((t (:height 1.05 :weight bold))))
	;; `(outline-4 ((t (:height 1.95 :weight bold))))
	;; `(outline-5 ((t (:height 1.85 :weight bold))))
	;; `(outline-6 ((t (:height 1.75 :weight bold))))
	;; `(outline-7 ((t (:height 1.65 :weight bold))))
** info\help
*** info manual : 
   Check out the info manual for Org Mode with C-h i (info) to learn more, including how to customize the number of days initially displayed and what day your week starts on. 
   удобная систе показиваюшая мануалки по всем установленым модам
*** customize-group
		Получить инфу по всем переменным
		режима поскольку зачастую режима нет в мануале
зато кажется это генерится автоматически
и там вполне полный хелп по каждой переменной
M-x customize-group RET company. 
** run 
*** run multiple Emacs servers : 
   You can run multiple Emacs servers on the same machine by giving each
one a unique “server name”, using the variable ‘server-name’.  For
example, ‘M-x set-variable <RET> server-name <RET> "foo" <RET>’ sets the
server name to ‘foo’.  The ‘emacsclient’ program can specify a server by
name, using the ‘-s’ or the ‘-f’ option (*note emacsclient Options::),
depending on whether or not the server uses a TCP socket (*note TCP
Emacs server::).

   If you want to run multiple Emacs daemons (*note Initial Options::),
you can give each daemon its own server name like this:

       emacs --daemon=foo

*** Subprocesses
**** 36.1 Functions that Create Subprocesses
 http://ergoemacs.org/emacs_manual/elisp/Shell-Arguments.html#Shell-Arguments
***** three primitives : 
	There are three primitives that create a new subprocess in which to run
	a program.  One of them, ~make-process~, creates an asynchronous
	process and returns a process object (see Asynchronous Processes).
	The other two, =call-process= and =call-process-region=,
	create a synchronous process and do not return a process object
	(see Synchronous Processes).  There are various higher-level
	functions that make use of these primitives to run particular types of
	process.

	Synchronous and asynchronous processes are explained in the following
	sections.  Since the three functions are all called in a similar
	fashion, their common arguments are described here.

	In all cases, the functions specify the program to be run.  An error
	is signaled if the file is not found or cannot be executed.  If the
	file name is relative, the variable exec-path contains a list
	of directories to search.  Emacs initializes exec-path when it
	starts up, based on the value of the environment variable PATH.
	The standard file name constructs, ‘~’, ‘.’, and ‘..’,
	are interpreted as usual in exec-path, but environment variable
	substitutions (‘$HOME’, etc.) are not recognized; use
	substitute-in-file-name to perform them (see File Name Expansion).  nil in this list refers to
	default-directory.

	Executing a program can also try adding suffixes to the specified
	name:
***** User Option: exec-suffixes
   This variable is a list of suffixes (strings) to try adding to the
   specified program file name.  The list should include "" if you
   want the name to be tried exactly as specified.  The default value is
   system-dependent.

   Please note: The argument program contains only the
   name of the program file; it may not contain any command-line
   arguments.  You must use a separate argument, args, to provide
   those, as described below.

   Each of the subprocess-creating functions has a buffer-or-name
   argument that specifies where the output from the program will go.  It
   should be a buffer or a buffer name; if it is a buffer name, that will
   create the buffer if it does not already exist.  It can also be
   nil, which says to discard the output, unless a custom filter
   function handles it.  (See Filter Functions, and Read and Print.)  Normally, you should avoid having multiple processes send
   output to the same buffer because their output would be intermixed
   randomly.  For synchronous processes, you can send the output to a
   file instead of a buffer (and the corresponding argument is therefore
   more appropriately called destination).  By default, both
   standard output and standard error streams go to the same destination,
   but all the 3 primitives allow optionally to direct the standard error
   stream to a different destination.

   All three of the subprocess-creating functions allow to specify
   command-line arguments for the process to run. For call-process
   and call-process-region, these come in the form of a
   &rest argument, args.  For make-process, both the
   program to run and its command-line arguments are specified as a list
   of strings.  The command-line arguments must all be strings, and they
   are supplied to the program as separate argument strings.  Wildcard
   characters and other shell constructs have no special meanings in
   these strings, since the strings are passed directly to the specified
   program.

   The subprocess inherits its environment from Emacs, but you can
   specify overrides for it with process-environment.  See System Environment.  The subprocess gets its current directory from the
   value of default-directory.
***** Variable: exec-directory
   The value of this variable is a string, the name of a directory that
   contains programs that come with GNU Emacs and are intended for Emacs
   to invoke.  The program movemail is an example of such a program;
   Rmail uses it to fetch new mail from an inbox.
***** User Option: exec-path
   The value of this variable is a list of directories to search for
   programs to run in subprocesses.  Each element is either the name of a
   directory (i.e., a string), or nil, which stands for the default
   directory (which is the value of default-directory).
   See executable-find, for the details of this search.


   The value of exec-path is used by call-process and
   start-process when the program argument is not an absolute
   file name.

   Generally, you should not modify exec-path directly.  Instead,
   ensure that your PATH environment variable is set appropriately
   before starting Emacs.  Trying to modify exec-path
   independently of PATH can lead to confusing results.
**** exempl
***** shell link
 [shell:D:\scripts\CMD\CygWin\vim.cmd "D:\tools.win\Fast\TehnoMage_fast\ActionDeck\Cooking\greentea.txt"]

 [shell:D:\Development\lisp\HOME\emacs_Run.cmd "D:\tools.win\Fast\TehnoMage_fast\ActionDeck\Cooking\greentea.txt"]
 (shell  "D:\tools.win\Fast\TehnoMage_fast\ActionDeck\Cooking\greentea.txt")
 [shell:D:\scripts\CMD\emagus\run_far.cmd "D:\tools.win\Fast\TehnoMage_fast\ActionDeck\Cooking\"]

 [shell:D:\Development\lisp\HOME\emacs_client.cmd  "D:\tools.win\Fast\TehnoMage_fast\ActionDeck\Cooking\greentea.txt"]
***** shell-command  : 
 (shell-command "D:/Development/lisp/HOME/emacs_Run.cmd D:/tools.win/Fast/TehnoMage_fast/ActionDeck/Cooking/greentea.txt")

 (shell-command "D:/Development/lisp/HOME/emacs_Run.cmd D:/tools.win/Fast/TehnoMage_fast/ActionDeck/Cooking/greentea.txt")

 (shell-command "D:/shell/CygWin/cygwin64/bin/mintty.exe -p 685,680 -s 43,24  -T 'Домашнее'  -e /bin/bash -li -c '/home/BuYn/scripts/sh/vim/todo/todoHome.sh'")
***** start-process : 
 (start-process "12" nil "d:/Development/lisp/Emacs/bin/runemacs.exe")

*** 44 Saving Emacs Sessions
[[info:emacs#Saving Emacs Sessions][info:emacs#Saving Emacs Sessions]]
**** simpl
***** append keys : 
‘C-u <F3>’
‘C-u C-x (’
     Re-execute last keyboard macro, then append keys to its definition.
‘C-u C-u <F3>’
‘C-u C-u C-x (’
     Append keys to the last keyboard macro without re-executing it.
***** last keyboard macro on each line : 
‘C-x C-k r’
     Run the last keyboard macro on each line that begins in the region
     (‘apply-macro-to-region-lines’).
***** 17.6 Editing a Keyboard Macro
****** Edit the last : 
‘C-x C-k C-e’
     Edit the last defined keyboard macro (‘kmacro-edit-macro’).
****** Edit previously NAME : 
‘C-x C-k e NAME <RET>’
     Edit a previously defined keyboard macro NAME (‘edit-kbd-macro’).
****** Edit 300 keystrokes as macro : 
‘C-x C-k l’
     Edit the last 300 keystrokes as a keyboard macro
     (‘kmacro-edit-lossage’).
***** 17.4 Executing Macros with Variations
In a keyboard macro, you can create an effect similar to that of
‘query-replace’, in that the macro asks you each time around whether to
make a change.

‘C-x q’
     When this point is reached during macro execution, ask for
     confirmation (‘kbd-macro-query’).

** keyboard macro
*** help
**** info links
	[[info:emacs#Keyboard Macros][info:emacs#Keyboard Macros]]
**** keys : 
***** base
	‘C-u <F3>’
	‘C-u C-x (’
			 Re-execute last keyboard macro, then append keys to its definition.
	‘C-u C-u <F3>’
	‘C-u C-u C-x (’
			 Append keys to the last keyboard macro without re-executing it.
	‘C-x C-k r’
			 Run the last keyboard macro on each line that begins in the region
			 (‘apply-macro-to-region-lines’).
***** edit 
‘C-x C-k C-e’
     Edit the last defined keyboard macro (‘kmacro-edit-macro’).
‘C-x C-k e NAME <RET>’
     Edit a previously defined keyboard macro NAME (‘edit-kbd-macro’).
‘C-x C-k l’
     Edit the last 300 keystrokes as a keyboard macro
     (‘kmacro-edit-lossage’).
***** name save session Bind 
‘C-x C-k n’
     Give a command name (for the duration of the Emacs session) to the
     most recently defined keyboard macro (‘kmacro-name-last-macro’).
‘C-x C-k b’
     Bind the most recently defined keyboard macro to a key sequence
     (for the duration of the session) (‘kmacro-bind-to-key’).
‘M-x insert-kbd-macro’
     Insert in the buffer a keyboard macro’s definition, as Lisp code.
***** ring 
‘C-x C-k C-k’
    Execute the keyboard macro at the head of the ring
    (‘kmacro-end-or-call-macro-repeat’).
‘C-x C-k C-n’
    Rotate the keyboard macro ring to the next macro (defined earlier)
    (‘kmacro-cycle-ring-next’).
‘C-x C-k C-p’
    Rotate the keyboard macro ring to the previous macro (defined
    later) (‘kmacro-cycle-ring-previous’).
C-x C-k C-d
		delete it from the macro ring.
** Registers
*** keybord help
**** 13.2 Saving Text in Registers
‘C-x r r R’
     Copy the region-rectangle into register R
     (‘copy-rectangle-to-register’).  With numeric argument, delete it
     as well.
‘C-x r s R’
     Copy region into register R (‘copy-to-register’).
‘C-x r i R’
     Insert text from register R (‘insert-register’).
‘M-x append-to-register <RET> R’
     Append region to text in register R.

     When register R contains text, you can use ‘C-x r +’
     (‘increment-register’) to append to that register.  Note that
     command ‘C-x r +’ behaves differently if R contains a number.
     *Note Number Registers::.

‘M-x prepend-to-register <RET> R’
     Prepend region to text in register R.
**** position : 
 ‘C-x r <SPC> R’
			Record the position of point and the current buffer in register R
			(‘point-to-register’).
 ‘C-x r j R’
			Jump to the position and buffer saved in register R
			(‘jump-to-register’).
     (set-register R '(file . NAME))
For example,
     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))
puts the file name shown in register ‘z’.
**** 13.8 Bookmarks
‘C-x r m <RET>’
     Set the bookmark for the visited file, at point.
‘C-x r m BOOKMARK <RET>’
     Set the bookmark named BOOKMARK at point (‘bookmark-set’).
‘C-x r M BOOKMARK <RET>’
     Like ‘C-x r m’, but don’t overwrite an existing bookmark.
‘C-x r b BOOKMARK <RET>’
     Jump to the bookmark named BOOKMARK (‘bookmark-jump’).
‘C-x r l’
     List all bookmarks (‘list-bookmarks’).
‘M-x bookmark-save’
     Save all the current bookmark values in the default bookmark file.
‘M-x bookmark-load <RET> FILENAME <RET>’
     Load a file named FILENAME that contains a list of bookmark values.
     You can use this command, as well as ‘bookmark-write’, to work with
     other files of bookmark values in addition to your default bookmark
     file.

‘M-x bookmark-write <RET> FILENAME <RET>’
     Save all the current bookmark values in the file FILENAME.

‘M-x bookmark-delete <RET> BOOKMARK <RET>’
     Delete the bookmark named BOOKMARK.

‘M-x bookmark-insert-location <RET> BOOKMARK <RET>’
     Insert in the buffer the name of the file that bookmark BOOKMARK
     points to.

‘M-x bookmark-insert <RET> BOOKMARK <RET>’
     Insert in the buffer the _contents_ of the file that bookmark
     BOOKMARK points to.

==============
**** 13.4 Saving Window Configurations in Registers
‘C-x r w R’
     Save the state of the selected frame’s windows in register R
     (‘window-configuration-to-register’).
‘C-x r f R’
     Save the state of all frames, including all their windows, in
     register R (‘frameset-to-register’).

   Use ‘C-x r j R’ to restore a window or frame configuration.  This is
  If you wish to delete these frames
instead, use ‘C-u C-x r j R’.

==============================================
**** 13.7 Keyboard Macro Registers
If you need to execute a keyboard macro (*note Keyboard Macros::)
frequently, it is more convenient to put it in a register or save it
(*note Save Keyboard Macro::).  ‘C-x C-k x R’ (‘kmacro-to-register’)
stores the last keyboard macro in register R.
=============================
**** 13.5 Keeping Numbers in Registers
‘C-u NUMBER C-x r n R’
     Store NUMBER into register R (‘number-to-register’).
‘C-u NUMBER C-x r + R’
     If R contains a number, increment the number in that register by
     NUMBER.  Note that command ‘C-x r +’ (‘increment-register’) behaves
     differently if R contains text.  *Note Text Registers::.
=================================
** Options
*** Visual
*** Home 
**** 3.5 Where do I put my init file?
***** file
On Windows, the .emacs file may be called _emacs for backward compatibility with DOS and FAT filesystems where filenames could not start with a dot. Some users prefer to continue using such a name due to historical problems various Windows tools had in the past with file names that begin with a dot. In Emacs 22 and later, the init file may also be called .emacs.d/init.el. Many of the other files that are created by lisp packages are now stored in the .emacs.d directory too, so this keeps all your Emacs related files in one place.

All the files mentioned above should go in your HOME directory. The HOME directory is determined by following the steps below:

***** environment variable HOME
    If the environment variable HOME is set, use the directory it indicates.
***** registry
    If the registry entry HKCU\SOFTWARE\GNU\Emacs\HOME is set, use the directory it indicates.
    If the registry entry HKLM\SOFTWARE\GNU\Emacs\HOME is set, use the directory it indicates. Not recommended, as it results in users sharing the same HOME directory.
***** if HOME was not set
    If C:\.emacs exists, then use C:/. This is for backward compatibility, as previous versions defaulted to C:/ if HOME was not set.
    Use the user's AppData directory, usually a directory called AppData under the user's profile directory, the location of which varies according to Windows version and whether the computer is part of a domain. 

***** Within Emacs, ~
Within Emacs, ~ at the beginning of a file name is expanded to your HOME directory, so you can always find your .emacs file by typing the command C-x C-f ~/.emacs. 
*** Text Eltments
**** Parenthesis
***** 5.27 How do I show which parenthesis matches the one I’m looking at?
  Call show-paren-mode in your .emacs file:
  (show-paren-mode 1)

  You can also enable this mode by selecting the ‘Paren Match Highlighting’ option from the ‘Options’ menu of the Emacs menu bar at the top of any Emacs frame.

  Alternatives to this mode include:

  If you’re looking at a right parenthesis (or brace or bracket) you can delete it and reinsert it. Emacs will momentarily move the cursor to the matching parenthesis.

  C-M-f (forward-sexp) and C-M-b (backward-sexp) will skip over one set of balanced parentheses, so you can see which parentheses match. (You can train it to skip over balanced brackets and braces at the same time by modifying the syntax table.)

  Here is some Emacs Lisp that will make the % key show the matching parenthesis, like in vi. In addition, if the cursor isn’t over a parenthesis, it simply inserts a % like normal.
  #+BEGIN_SRC elisp
;; By an unknown contributor
(global-set-key "%" 'match-paren)
(defun match-paren (arg)
"Go to the matching paren if on a paren; otherwise insert %."
    (interactive "p")
    (cond ((looking-at "\\s(") (forward-list 1) (backward-char 1))
	    ((looking-at "\\s)") (forward-char 1) (backward-list 1))
	    (t (self-insert-command (or arg 1)))))
  #+END_SRC
** dired
*** запуск dired
** eww 
**** other
*** 2 Basic Usage
 You can open a URL or search the web with the command ‘M-x eww’.  If the
 input doesn’t look like a URL or domain name the web will be searched
 via ‘eww-search-prefix’.  The default search engine is DuckDuckGo
 (https://duckduckgo.com).  If you want to open a file either prefix the
 file name with ‘file://’ or use the command ‘M-x eww-open-file’.
If loading the URL was successful the buffer ‘*eww*’ is opened and
*** keys
**** ‘q’ :  eww-quit : 
 the web page is rendered in it.  You can leave EWW by pressing ‘q’ or
 
 exit the browser by calling ‘eww-quit’. 
**** ‘g’ : (‘eww-reload’). 
 To reload the web page hit ‘g’
 (‘eww-reload’). 
**** ‘w’ : (‘eww-copy-page-url’) : 
 Pressing ‘w’ (‘eww-copy-page-url’) will copy the
 current URL to the kill ring.
**** M-<RET> : ‘eww-open-in-new-buffer’
		The ‘M-<RET>’ command (‘eww-open-in-new-buffer’) opens the URL at
 point in a new EWW buffer, akin to opening a link in a new “tab” in
 other browsers.
**** ‘R’ command (‘eww-readable’) : 
		The ‘R’ command (‘eww-readable’) will attempt to determine which part
 of the document contains the “readable” text, and will only display this
 part.  This usually gets rid of menus and the like.
**** ‘F’ command (‘eww-toggle-fonts’) : 
		The ‘F’ command (‘eww-toggle-fonts’) toggles whether to use
 variable-pitch fonts or not.  This sets the ‘shr-use-fonts’ variable.
**** ‘M-C’ command (‘eww-toggle-colors’) : 
		The ‘M-C’ command (‘eww-toggle-colors’) toggles whether to use
 HTML-specified colors or not.  This sets the ‘shr-use-colors’ variable.
**** ‘d’ (‘eww-download’) : 
		A URL under the point can be downloaded with ‘d’ (‘eww-download’).
 The file will be written to the directory specified in
 ‘eww-download-directory’ (Default: ‘~/Downloads/’).

**** ‘l’ (‘eww-back-url’) : 
		EWW remembers the URLs you have visited to allow you to go back and
 forth between them.  By pressing ‘l’ (‘eww-back-url’) you go to the
 previous URL. 
**** ‘r’ (‘eww-forward-url’) : 
 You can go forward again with ‘r’ (‘eww-forward-url’).
**** ‘H’ (‘eww-list-histories’) : 
 If you want an overview of your browsing history press ‘H’
 (‘eww-list-histories’) to open the history buffer ‘*eww history*’.  The
 history is lost when EWW is quit. 
****  can use bookmarks.
 If you want to remember websites you
 can use bookmarks.
		Along with the URLs visited, EWW also remembers both the rendered
 page (as it appears in the buffer) and its source.  This can take a
 considerable amount of memory, so EWW discards the history entries to
 keep their number within a set limit, as specified by
 ‘eww-history-limit’; the default being 50.  This variable could also be
 set to ‘nil’ to allow for the history list to grow indefinitely.
**** ‘b’ (‘eww-add-bookmark’)  : 
		EWW allows you to “bookmark” URLs.  Simply hit ‘b’
		
 (‘eww-add-bookmark’) to store a bookmark for the current website.  You
 
**** ‘B’ (‘eww-list-bookmarks’) : 
 can view stored bookmarks with ‘B’ (‘eww-list-bookmarks’).  This will
 open the bookmark buffer ‘*eww bookmarks*’.

**** PDFs are viewed : 
		PDFs are viewed inline, by default, with ‘doc-view-mode’, but this
 can be customized by using the mailcap (*note (emacs-mime)mailcap::)
 mechanism, in particular ‘mailcap-mime-data’.
**** ‘S’ (‘eww-list-buffers’) : 
		To get summary of currently opened EWW buffers, press ‘S’
 (‘eww-list-buffers’).  The ‘*eww buffers*’ buffer allows you to quickly
 kill, flip through and switch to specific EWW buffer.  
**** ‘s’ (‘eww-switch-to-buffer’). : 
To switch EWW
 buffers through a minibuffer prompt, press ‘s’ (‘eww-switch-to-buffer’).

**** ‘&’ (‘eww-browse-with-external-browser’) : 
		Although EWW and shr.el do their best to render webpages in GNU Emacs
 some websites use features which can not be properly represented or are
 not implemented (E.g., JavaScript).  If you have trouble viewing a
 
 website with EWW then hit ‘&’ (‘eww-browse-with-external-browser’)
 inside the EWW buffer to open the website in the external browser
 specified by ‘shr-external-browser’.  Some content types, such as video
 or audio content, do not make sense to display in GNU Emacs at all.  You
 can tell EWW to open specific content automatically in an external
 browser by customizing ‘eww-use-external-browser-for-content-type’.

** eShell
*** doc
**** commands
***** [so] Is it therefore possible to see what actual elisp is being invoked...
https://emacs.stackexchange.com/questions/14979/access-to-the-elisp-commands-behind-eshell-commands/14981#14981

Yes. They are all located in the eshell folder under Resources/elisp in the Emacs app folder. See screenshot of files on my computer. 


  So I'd like to have the actual elisp...


Open any of those files to see the actual elisp code. For example, ls command with its normal switches is implemented in em-ls.el file by John Wiegley and its core uses expand-file-name function.

How to find which lisp file provides what shell command? Open eshell prompt and then type, say you want to know where kill is in elisp:

which kill


will tell you that 

eshell/kill is a compiled Lisp function in `esh-proc.el'


What other commands are available in eshell?

see the [manual][2]



  there is no way I know of running eshell commands as Babel "code blocks."


There are no special eshell commands per se. Eshell mimics standard unix shell commands using existing lisp functions. You can invoke those same functions in org-babel lisp blocks without any mediating functions implemented in eshell. 
    
***** so find-function
        e.g.: M-x find-function RET eshell/ls RET

I like having find-function bound to C-hC-f as a variant on the standard describe-function binding (via which you can also indirectly get to the code, FYI).

You could also use the following:
#+BEGIN_SRC shell
(defun eshell/goto (name)
  "Visit the source code for the specified eshell command."
  (let ((func (eshell-find-alias-function name)))
    (if func
        (find-function func)
      (error "%s is not an elisp function" name))))
#+END_SRC
$ goto ls


If you want to know what's implemented in elisp and what isn't, you could just ask Emacs to complete on eshell/

e.g.: C-uC-ha eshell/ RET
** Shell
*** Описание 
используется для запуска других процесов
может сильно влиять на работу режимов
поскольку процес может запускатся из eshell
но при этом глючить в шеле
и как результат нечего не будет работать
просто потому что в винде
нужно заменить на чтонить другое
*** explicit-shell-file-name : 
You can start an interactive shell in Emacs by typing M-x shell. 
By default, this will start the standard Windows shell cmd.exe. 
Emacs uses the SHELL environment variable to determine which
program to use as the shell.  To instruct Emacs to use a non-default
shell, you can either set this environment variable, or customize
explicit-shell-file-name.  You can also customize
*** shell-file-name : 
shell-file-name to change the shell that will be used by
subprocesses that are started with shell-command and
related non-interactive shell commands.

"D:/Development/lisp/Emacs/libexec/emacs/26.2/x86_64-w64-mingw32/cmdproxy.exe"
Original value was 
"C:/msys64/home/Administrator/emacs-build/build/emacs-26.2/x86_64/nt/cmdproxy.exe"
*** to git hub
(setq explicit-shell-file-name "d:/Development/version-control.APP/Git/bin/sh.exe")
(setq shell-file-name "sh")
(setq explicit-sh.exe-args '("--noediting" "--login" "-i"))
(setenv "SHELL" shell-file-name)

# (setq explicit-sh.exe-args '("--login" "-i"))
# (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m)

** Folding 
*** HideShow
Invoke HideShow mode with M-x hs-minor-mode.

** Thems 
*** face 
**** note like 
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(bold ((t (:weight ultra-bold))))
 '(italic ((t (:slant italic))))
 '(org-agenda-structure ((t (:inherit default :foreground "#bbc2cf" :underline nil :slant normal :weight bold :height 2.0 :width normal :foundry "outline" :family "PT Sans"))))
 '(org-default ((t (:inherit variable-pitch))))
 '(org-document-title ((t (:inherit org-level-1 :foreground "dark gray" :weight bold :height 1.2 :family "IM Fell English SC"))))
 '(org-footnote ((t (:foreground "gray40" :underline t :height 0.5))))
 '(org-indent ((t (:inherit org-hide fixed-pitch))))
 '(org-level-1 ((t (:inherit variable-pitch :foreground "#a89984" :weight bold :height 1.6 :family "IM Fell English SC"))))
 '(org-level-2 ((t (:inherit nil :foreground "#bdae93" :weight bold :height 1.4 :family "IM Fell English SC"))))
 '(org-level-3 ((t (:foreground "#d5c4a1" :height 1.2 :family "IM Fell English SC"))))
 '(org-level-4 ((t (:inherit nil :foreground "#ebdbb2" :weight normal :height 1.1 :family "IM Fell English SC"))))
 '(org-level-5 ((t (:inherit nil :foreground "#ebdbb2" :weight normal :height 1.0 :family "IM Fell English SC"))))
 '(org-level-6 ((t (:inherit nil))))
 '(org-level-7 ((t nil)))
 '(org-link ((t (:inherit nil :foreground "cornflower blue" :underline t :height 1.0))))
 '(org-table ((t (:foreground "tomato"))))
 '(org-variable-pitch-face ((t (:height 1.0 :family "IM Fell English"))))
'(variable-pitch ((t (:height 1.0 :family "IM Fell English")))))
* Help Docs eLisp
** Data types
*** varible
**** show type
 (type-of chartoadd)
**** chek type
 (typep *x* 'integer)
**** chege type 
***** From number to string:
 (number-to-string 5)
 "5"
 you may transform a string to any numerical notation:
 (number-to-string 341 :base 10)
 "341"
***** From string to number:
 (parse-integer "5")
 5
 with some trash
 (parse-integer " 5 something not a number" :junk-allowed t)
 5
 Or use this:
 (read-from-string "23 absd")
 23
***** FORMAT 
 (format nil "~A" 1)
**** Seeing the Current Value of a Variable
	 c-h v
 describe-variable

 (progn
 (evil-open-below 3)
 (insert (getenv "PATH"))
 )

 (describe-variable exec-path)
 (symbol-value exec-path)
**** 12.7 Accessing Variable Values determined at run time
 https://www.gnu.org/software/emacs/manual/html_node/elisp/Accessing-Variables.html
 The usual way to reference a variable is to write the symbol which
 names it.  See Symbol Forms.

		Occasionally, you may want to reference a variable which is only
 determined at run time.  In that case, you cannot specify the variable
 name in the text of the program.  You can use the symbol-value
 function to extract the value.


 — Function: symbol-value symbol
 This function returns the value stored in symbol's value cell. 
 This is where the variable's current (dynamic) value is stored.  If
 the variable has no local binding, this is simply its global value. 
 If the variable is void, a void-variable error is signaled.

         If the variable is lexically bound, the value reported by
 symbol-value is not necessarily the same as the variable's
 lexical value, which is determined by the lexical environment rather
 than the symbol's value cell.  See Variable Scoping.

								(setq abracadabra 5)
								=> 5
           (setq foo 9)
								=> 9
          
           ;; Here the symbol abracadabra
           ;;   is the symbol whose value is examined.
           (let ((abracadabra 'foo))
             (symbol-value 'abracadabra))
								=>foo
          
           ;; Here, the value of abracadabra,
           ;;   which is foo,
           ;;   is the symbol whose value is examined.
           (let ((abracadabra 'foo))
             (symbol-value abracadabra))
               => 9
          
           (symbol-value 'abracadabra)
               => 5
**** 12.5 Defining Global Variables
 ==============================
 A “variable definition” is a construct that announces your intention to
 use a symbol as a global variable.  It uses the special forms ‘defvar’
 or ‘defconst’, which are documented below.
		A variable definition serves three purposes.  First, it informs
 people who read the code that the symbol is _intended_ to be used a
 certain way (as a variable).  Second, it informs the Lisp system of
 this, optionally supplying an initial value and a documentation string.
 Third, it provides information to programming tools such as ‘etags’,
 allowing them to find where the variable was defined.

		The difference between ‘defconst’ and ‘defvar’ is mainly a matter of
 intent, serving to inform human readers of whether the value should ever
 change.  Emacs Lisp does not actually prevent you from changing the
 value of a variable defined with ‘defconst’.  One notable difference
 between the two forms is that ‘defconst’ unconditionally initializes the
 variable, whereas ‘defvar’ initializes it only if it is originally void.

		To define a customizable variable, you should use ‘defcustom’ (which
 calls ‘defvar’ as a subroutine).  *Note Variable Definitions::.

	-- Special Form: defvar symbol [value [doc-string]]
			This special form defines SYMBOL as a variable.  Note that SYMBOL
			is not evaluated; the symbol to be defined should appear explicitly
			in the ‘defvar’ form.  The variable is marked as “special”, meaning
			that it should always be dynamically bound (*note Variable
			Scoping::).

			If VALUE is specified, and SYMBOL is void (i.e., it has no
			dynamically bound value; *note Void Variables::), then VALUE is
			evaluated and SYMBOL is set to the result.  But if SYMBOL is not
			void, VALUE is not evaluated, and SYMBOL’s value is left unchanged.
			If VALUE is omitted, the value of SYMBOL is not changed in any
			case.

			Note that specifying a value, even ‘nil’, marks the variable as
			special permanently.  Whereas if VALUE is omitted then the variable
			is only marked special locally (i.e. within the current lexical
			scope, or file if at the top-level).  This can be useful for
			suppressing byte compilation warnings, see *note Compiler Errors::.

			If SYMBOL has a buffer-local binding in the current buffer,
			‘defvar’ acts on the default value, which is buffer-independent,
			rather than the buffer-local binding.  It sets the default value if
			the default value is void.  *Note Buffer-Local Variables::.

			If SYMBOL is already lexically bound (e.g., if the ‘defvar’ form
			occurs in a ‘let’ form with lexical binding enabled), then ‘defvar’
			sets the dynamic value.  The lexical binding remains in effect
			until its binding construct exits.  *Note Variable Scoping::.

			When you evaluate a top-level ‘defvar’ form with ‘C-M-x’ in Emacs
			Lisp mode (‘eval-defun’), a special feature of ‘eval-defun’
			arranges to set the variable unconditionally, without testing
			whether its value is void.

			If the DOC-STRING argument is supplied, it specifies the
			documentation string for the variable (stored in the symbol’s
			‘variable-documentation’ property).  *Note Documentation::.

			Here are some examples.  This form defines ‘foo’ but does not
			initialize it:

           (defvar foo)
								= foo

			This example initializes the value of ‘bar’ to ‘23’, and gives it a
			documentation string:

           (defvar bar 23
             "The normal weight of a bar.")
								= bar

			The ‘defvar’ form returns SYMBOL, but it is normally used at top
			level in a file where its value does not matter.

			For a more elaborate example of using ‘defvar’ without a value, see
			*note Local defvar example::.

	-- Special Form: defconst symbol value [doc-string]
			This special form defines SYMBOL as a value and initializes it.  It
			informs a person reading your code that SYMBOL has a standard
			global value, established here, that should not be changed by the
			user or by other programs.  Note that SYMBOL is not evaluated; the
			symbol to be defined must appear explicitly in the ‘defconst’.

			The ‘defconst’ form, like ‘defvar’, marks the variable as
			“special”, meaning that it should always be dynamically bound
			(*note Variable Scoping::).  In addition, it marks the variable as
			risky (*note File Local Variables::).

			‘defconst’ always evaluates VALUE, and sets the value of SYMBOL to
			the result.  If SYMBOL does have a buffer-local binding in the
			current buffer, ‘defconst’ sets the default value, not the
			buffer-local value.  (But you should not be making buffer-local
			bindings for a symbol that is defined with ‘defconst’.)

			An example of the use of ‘defconst’ is Emacs’s definition of
			‘float-pi’—the mathematical constant pi, which ought not to be
			changed by anyone (attempts by the Indiana State Legislature
			notwithstanding).  As the second form illustrates, however,
			‘defconst’ is only advisory.

           (defconst float-pi 3.141592653589793 "The value of Pi.")
								= float-pi
           (setq float-pi 3)
								= float-pi
           float-pi
								= 3

		*Warning:* If you use a ‘defconst’ or ‘defvar’ special form while the
 variable has a local binding (made with ‘let’, or a function argument),
 it sets the local binding rather than the global binding.  This is not
 what you usually want.  To prevent this, use these special forms at top
 level in a file, where normally no local binding is in effect, and make
 sure to load the file before making a local binding for the variable.
**** 12.11.2 Creating and Deleting Buffer-Local Bindings
 Macro: defvar-local
 setq-local
 ---------------------------------------------------
	-- Command: make-local-variable variable
			This function creates a buffer-local binding in the current buffer
			for VARIABLE (a symbol).  Other buffers are not affected.  The
			value returned is VARIABLE.

			The buffer-local value of VARIABLE starts out as the same value
			VARIABLE previously had.  If VARIABLE was void, it remains void.

           ;; In buffer ‘b1’:
           (setq foo 5)                ; Affects all buffers.
								= 5
           (make-local-variable 'foo)  ; Now it is local in ‘b1’.
								= foo
           foo                         ; That did not change
								= 5                   ;   the value.
           (setq foo 6)                ; Change the value
								= 6                   ;   in ‘b1’.
           foo
								= 6

           ;; In buffer ‘b2’, the value hasn’t changed.
           (with-current-buffer "b2"
             foo)
								= 5

			Making a variable buffer-local within a ‘let’-binding for that
			variable does not work reliably, unless the buffer in which you do
			this is not current either on entry to or exit from the ‘let’.
			This is because ‘let’ does not distinguish between different kinds
			of bindings; it knows only which variable the binding was made for.

			It is an error to make a constant or a read-only variable
			buffer-local.  *Note Constant Variables::.

			If the variable is terminal-local (*note Multiple Terminals::),
			this function signals an error.  Such variables cannot have
			buffer-local bindings as well.

			*Warning:* do not use ‘make-local-variable’ for a hook variable.
			The hook variables are automatically made buffer-local as needed if
			you use the LOCAL argument to ‘add-hook’ or ‘remove-hook’.

	-- Macro: setq-local variable value
			This macro creates a buffer-local binding in the current buffer for
			VARIABLE, and gives it the buffer-local value VALUE.  It is
			equivalent to calling ‘make-local-variable’ followed by ‘setq’.
			VARIABLE should be an unquoted symbol.

	-- Command: make-variable-buffer-local variable
			This function marks VARIABLE (a symbol) automatically buffer-local,
			so that any subsequent attempt to set it will make it local to the
			current buffer at the time.  Unlike ‘make-local-variable’, with
			which it is often confused, this cannot be undone, and affects the
			behavior of the variable in all buffers.

			A peculiar wrinkle of this feature is that binding the variable
			(with ‘let’ or other binding constructs) does not create a
			buffer-local binding for it.  Only setting the variable (with ‘set’
			or ‘setq’), while the variable does not have a ‘let’-style binding
			that was made in the current buffer, does so.

			If VARIABLE does not have a default value, then calling this
			command will give it a default value of ‘nil’.  If VARIABLE already
			has a default value, that value remains unchanged.  Subsequently
			calling ‘makunbound’ on VARIABLE will result in a void buffer-local
			value and leave the default value unaffected.

			The value returned is VARIABLE.

			It is an error to make a constant or a read-only variable
			buffer-local.  *Note Constant Variables::.

			*Warning:* Don’t assume that you should use
			‘make-variable-buffer-local’ for user-option variables, simply
			because users _might_ want to customize them differently in
			different buffers.  Users can make any variable local, when they
			wish to.  It is better to leave the choice to them.

			The time to use ‘make-variable-buffer-local’ is when it is crucial
			that no two buffers ever share the same binding.  For example, when
			a variable is used for internal purposes in a Lisp program which
			depends on having separate values in separate buffers, then using
			‘make-variable-buffer-local’ can be the best solution.

	-- Macro: defvar-local variable value &optional docstring
			This macro defines VARIABLE as a variable with initial value VALUE
			and DOCSTRING, and marks it as automatically buffer-local.  It is
			equivalent to calling ‘defvar’ followed by
			‘make-variable-buffer-local’.  VARIABLE should be an unquoted
			symbol.

	-- Function: local-variable-p variable &optional buffer
			This returns ‘t’ if VARIABLE is buffer-local in buffer BUFFER
			(which defaults to the current buffer); otherwise, ‘nil’.

	-- Function: local-variable-if-set-p variable &optional buffer
			This returns ‘t’ if VARIABLE either has a buffer-local value in
			buffer BUFFER, or is automatically buffer-local.  Otherwise, it
			returns ‘nil’.  If omitted or ‘nil’, BUFFER defaults to the current
			buffer.

	-- Function: buffer-local-value variable buffer
			This function returns the buffer-local binding of VARIABLE (a
			symbol) in buffer BUFFER.  If VARIABLE does not have a buffer-local
			binding in buffer BUFFER, it returns the default value (*note
			Default Value::) of VARIABLE instead.

	-- Function: buffer-local-variables &optional buffer
			This function returns a list describing the buffer-local variables
			in buffer BUFFER.  (If BUFFER is omitted, the current buffer is
			used.)  Normally, each list element has the form ‘(SYM . VAL)’,
			where SYM is a buffer-local variable (a symbol) and VAL is its
			buffer-local value.  But when a variable’s buffer-local binding in
			BUFFER is void, its list element is just SYM.

           (make-local-variable 'foobar)
           (makunbound 'foobar)
           (make-local-variable 'bind-me)
           (setq bind-me 69)
           (setq lcl (buffer-local-variables))
               ;; First, built-in variables local in all buffers:
           = ((mark-active . nil)
               (buffer-undo-list . nil)
               (mode-name . "Fundamental")
               ...
               ;; Next, non-built-in buffer-local variables.
               ;; This one is buffer-local and void:
               foobar
               ;; This one is buffer-local and nonvoid:
               (bind-me . 69))

			Note that storing new values into the CDRs of cons cells in this
			list does _not_ change the buffer-local values of the variables.

	-- Command: kill-local-variable variable
			This function deletes the buffer-local binding (if any) for
			VARIABLE (a symbol) in the current buffer.  As a result, the
			default binding of VARIABLE becomes visible in this buffer.  This
			typically results in a change in the value of VARIABLE, since the
			default value is usually different from the buffer-local value just
			eliminated.

			If you kill the buffer-local binding of a variable that
			automatically becomes buffer-local when set, this makes the default
			value visible in the current buffer.  However, if you set the
			variable again, that will once again create a buffer-local binding
			for it.

			‘kill-local-variable’ returns VARIABLE.

			This function is a command because it is sometimes useful to kill
			one buffer-local variable interactively, just as it is useful to
			create buffer-local variables interactively.

	-- Function: kill-all-local-variables
			This function eliminates all the buffer-local variable bindings of
			the current buffer except for variables marked as permanent and
			local hook functions that have a non-‘nil’ ‘permanent-local-hook’
			property (*note Setting Hooks::).  As a result, the buffer will see
			the default values of most variables.

			This function also resets certain other information pertaining to
			the buffer: it sets the local keymap to ‘nil’, the syntax table to
			the value of ‘(standard-syntax-table)’, the case table to
			‘(standard-case-table)’, and the abbrev table to the value of
			‘fundamental-mode-abbrev-table’.

			The very first thing this function does is run the normal hook
			‘change-major-mode-hook’ (see below).

			Every major mode command begins by calling this function, which has
			the effect of switching to Fundamental mode and erasing most of the
			effects of the previous major mode.  To ensure that this does its
			job, the variables that major modes set should not be marked
			permanent.

			‘kill-all-local-variables’ returns ‘nil’.

	-- Variable: change-major-mode-hook
			The function ‘kill-all-local-variables’ runs this normal hook
			before it does anything else.  This gives major modes a way to
			arrange for something special to be done if the user switches to a
			different major mode.  It is also useful for buffer-specific minor
			modes that should be forgotten if the user changes the major mode.

			For best results, make this variable buffer-local, so that it will
			disappear after doing its job and will not interfere with the
			subsequent major mode.  *Note Hooks::.

		A buffer-local variable is “permanent” if the variable name (a
 symbol) has a ‘permanent-local’ property that is non-‘nil’.  Such
 variables are unaffected by ‘kill-all-local-variables’, and their local
 bindings are therefore not cleared by changing major modes.  Permanent
 locals are appropriate for data pertaining to where the file came from
 or how to save it, rather than with how to edit the contents.
*** String 
**** Conversion
***** 4.6 Conversion of Characters and Strings
****** section describes : 
	 This section describes functions for converting between characters, strings and
	 integers. format (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Formatting-Strings.html#Formatting-Strings][Formatting Strings]]) and prin1-to-string (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#Output-Functions][Output Functions]])
	 can also convert Lisp objects into strings. read-from-string (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Input-Functions.html#Input-Functions][Input Functions]]) can
	 convert a string representation of a Lisp object into an object. The functions
	 string-to-multibyte and string-to-unibyte convert the text representation of a string (see
	 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Converting-Representations.html#Converting-Representations][Converting Representations]]). 

	 See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation.html#Documentation][Documentation]], for functions that produce textual descriptions of text characters
	 and general input events (single-key-description and text-char-description). These are
	 used primarily for making help messages. 
****** Function: number-to-string number
		This function returns a string consisting of the printed base-ten representation of
		number. The returned value starts with a minus sign if the argument is negative. 

	 (number-to-string 256)
				=> "256"
	 (number-to-string -23)
				=> "-23"
	 (number-to-string -23.5)
				=> "-23.5"

		int-to-string is a semi-obsolete alias for this function. 

		See also the function format in [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Formatting-Strings.html#Formatting-Strings][Formatting Strings]]. 
****** Function: string-to-number string &optional base
		This function returns the numeric value of the characters in string. If base is
		non-nil, it must be an integer between 2 and 16 (inclusive), and integers are
		converted in that base. If base is nil, then base ten is used. Floating-point
		conversion only works in base ten; we have not implemented other radices for
		floating-point numbers, because that would be much more work and does not
		seem useful. If string looks like an integer but its value is too large to fit into a Lisp
		integer, string-to-number returns a floating-point result. 

		The parsing skips spaces and tabs at the beginning of string, then reads as much
		of string as it can interpret as a number in the given base. (On some systems it
		ignores other whitespace at the beginning, not just spaces and tabs.) If string
		cannot be interpreted as a number, this function returns 0. 

	 (string-to-number "256")
				=> 256
	 (string-to-number "25 is a perfect square.")
				=> 25
	 (string-to-number "X256")
				=> 0
	 (string-to-number "-4.5")
				=> -4.5
	 (string-to-number "1e5")
				=> 100000.0
		string-to-int is an obsolete alias for this function. 
****** Function: char-to-string character
		This function returns a new string containing one character, character. This
		function is semi-obsolete because the function string is more general. See
		[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Strings.html#Creating-Strings][Creating Strings]]. 
****** Function: string-to-char string
		This function returns the first character in string. This mostly identical to (aref string
		0), except that it returns 0 if the string is empty. (The value is also 0 when the first
		character of string is the null character, ASCII code 0.) This function may be
		eliminated in the future if it does not seem useful enough to retain. 
****** some other functions that can convert : 
	 Here are some other functions that can convert to or from a string: 
******* concat
		 This function converts a vector or a list into a string. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Strings.html#Creating-Strings][Creating Strings]]. 
******* vconcat
		 This function converts a string into a vector. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Vector-Functions.html#Vector-Functions][Vector Functions]]. 
******* append
		 This function converts a string into a list. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Building-Lists.html#Building-Lists][Building Lists]]. 
******* byte-to-string
		 This function converts a byte of character data into a unibyte string. See
		 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Converting-Representations.html#Converting-Representations][Converting Representations]]. 
**** 34.6.2 Simple Match Data Access
*****  section explains : 
 This section explains how to use the match data to find out what was matched by the
 last search or match operation, if it succeeded. 

 You can ask about the entire matching text, or about a particular parenthetical
 subexpression of a regular expression. The count argument in the functions below
 specifies which. If count is zero, you are asking about the entire match. If count is
 positive, it specifies which subexpression you want. 

 Recall that the subexpressions of a regular expression are those expressions grouped
 with escaped parentheses, ‘\(…\)’. The countth subexpression is found by counting
 occurrences of ‘\(’ from the beginning of the whole regular expression. The first
 subexpression is numbered 1, the second 2, and so on. Only regular expressions can
 have subexpressions—after a simple string search, the only information available is
 about the entire match. 

 Every successful search sets the match data. Therefore, you should query the match
 data immediately after searching, before calling any other function that might perform
 another search. Alternatively, you may save and restore the match data (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Saving-Match-Data.html#Saving-Match-Data][Saving]]
 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Saving-Match-Data.html#Saving-Match-Data][Match Data]]) around the call to functions that could perform another search. Or use the
 functions that explicitly do not modify the match data; e.g., string-match-p. 

 A search which fails may or may not alter the match data. In the current
 implementation, it does not, but we may change it in the future. Don’t try to rely on the
 value of the match data after a failing search. 
*****  Function: match-string count &optional in-string
	This function returns, as a string, the text matched in the last search or match
	operation. It returns the entire text if count is zero, or just the portion corresponding
	to the countth parenthetical subexpression, if count is positive. 

	If the last such operation was done against a string with string-match, then you
	should pass the same string as the argument in-string. After a buffer search or
	match, you should omit in-string or pass nil for it; but you should make sure that
	the current buffer when you call match-string is the one in which you did the
	searching or matching. Failure to follow this advice will lead to incorrect results. 

	The value is nil if count is out of range, or for a subexpression inside a ‘\|’
	alternative that wasn’t used or a repetition that repeated zero times. 
*****  Function: match-string-no-properties count &optional in-string

	This function is like match-string except that the result has no text properties. 
*****  Function: match-beginning count

	If the last regular expression search found a match, this function returns the
	position of the start of the matching text or of a subexpression of it. 

	If count is zero, then the value is the position of the start of the entire match.
	Otherwise, count specifies a subexpression in the regular expression, and the
	value of the function is the starting position of the match for that subexpression. 

	The value is nil for a subexpression inside a ‘\|’ alternative that wasn’t used or a
	repetition that repeated zero times. 
*****  Function: match-end count
	This function is like match-beginning except that it returns the position of the end
	of the match, rather than the position of the beginning. 
***** example of using the match data : 
 Here is an example of using the match data, with a comment showing the positions
 within the text: 

 (string-match "\\(qu\\)\\(ick\\)"
               "The quick fox jumped quickly.")
               ;0123456789
			=> 4


 (match-string 0 "The quick fox jumped quickly.")
			=> "quick"
 (match-string 1 "The quick fox jumped quickly.")
			=> "qu"
 (match-string 2 "The quick fox jumped quickly.")
			=> "ick"


 (match-beginning 1)       ; The beginning of the match
			=> 4                 ;   with ‘qu’ is at index 4.


 (match-beginning 2)       ; The beginning of the match
			=> 6                 ;   with ‘ick’ is at index 6.


 (match-end 1)             ; The end of the match
			=> 6                 ;   with ‘qu’ is at index 6.

 (match-end 2)             ; The end of the match
			=> 9                 ;   with ‘ick’ is at index 9.
*****  Here is another example : 
 Here is another example. Point is initially located at the beginning of the line.
 Searching moves point to between the space and the word ‘in’. The beginning of the
 entire match is at the 9th character of the buffer (‘T’), and the beginning of the match
 for the first subexpression is at the 13th character (‘c’). 

 (list
   (re-search-forward "The \\(cat \\)")
   (match-beginning 0)
   (match-beginning 1))
     => (17 9 13)


 ---------- Buffer: foo ----------
 I read "The cat ∗in the hat comes back" twice.
         ^   ^
         9  13
 ---------- Buffer: foo ----------

 (In this case, the index returned is a buffer position; the first character of the buffer
 counts as 1.) 

*** lists
**** plist 
***** get
 (plist-get '(x 1 y 2) 'y) ; 2
 (plist-get '(x 1 y 2) 'b) ; nil
***** set 
 ;; create a property list xx
 (setq xx '(a 1 b 2))

 ;; set value to a existing key
 (setq xx (plist-put xx 'b 9))

 (plist-get xx 'b) ; 3
 xx
 ;; (a 1 b 3)
***** cheak 
 (setq xx '(a 1 b 2))

 ;; check if a key exist
 (plist-member xx 'b)
 ;; (b 2)
***** keywords : 
 (setq tem '(:x 10 :y 20))
 (plist-get tem :y)
**** 5.3 Accessing Elements of Lists
***** Function: car cons-cell
	This function returns the value referred to by the first slot of the
	cons cell cons-cell.  In other words, it returns the CAR of
	cons-cell.

	As a special case, if cons-cell is nil, this function
	returns nil.  Therefore, any list is a valid argument.  An
	error is signaled if the argument is not a cons cell or nil.


	(car '(a b c))
			 => a
	(car '())
			 => nil
*****  Function: cdr cons-cell
	This function returns the value referred to by the second slot of the
	cons cell cons-cell.  In other words, it returns the CDR of
	cons-cell.

	As a special case, if cons-cell is nil, this function
	returns nil; therefore, any list is a valid argument.  An error
	is signaled if the argument is not a cons cell or nil.


	(cdr '(a b c))
			 => (b c)
	(cdr '())
			 => nil
*****  Function: car-safe object
	This function lets you take the CAR of a cons cell while avoiding
	errors for other data types.  It returns the CAR of object if
	object is a cons cell, nil otherwise.  This is in contrast
	to car, which signals an error if object is not a list.


	(car-safe object)
	≡
	(let ((x object))
		(if (consp x)
				(car x)
			nil))
*****  Function: cdr-safe object
	This function lets you take the CDR of a cons cell while
	avoiding errors for other data types.  It returns the CDR of
	object if object is a cons cell, nil otherwise.
	This is in contrast to cdr, which signals an error if
	object is not a list.


	(cdr-safe object)
	≡
	(let ((x object))
		(if (consp x)
				(cdr x)
			nil))




	Macro: pop listname
	This macro provides a convenient way to examine the CAR of a
	list, and take it off the list, all at once.  It operates on the list
	stored in listname.  It removes the first element from the list,
	saves the CDR into listname, then returns the removed
	element.

	In the simplest case, listname is an unquoted symbol naming a
	list; in that case, this macro is equivalent to (prog1 (car listname) (setq listname (cdr listname))).


	x
			 => (a b c)
	(pop x)
			 => a
	x
			 => (b c)


	More generally, listname can be a generalized variable.  In that
	case, this macro saves into listname using setf.
	See Generalized Variables.

	For the push macro, which adds an element to a list,
	See List Variables.
*****  Function: nth n list
	This function returns the nth element of list.  Elements
	are numbered starting with zero, so the CAR of list is
	element number zero.  If the length of list is n or less,
	the value is nil.



	(nth 2 '(1 2 3 4))
			 => 3
	(nth 10 '(1 2 3 4))
			 => nil

	(nth n x) ≡ (car (nthcdr n x))


	The function elt is similar, but applies to any kind of sequence.
	For historical reasons, it takes its arguments in the opposite order.
	See Sequence Functions.
*****  Function: nthcdr n list
	This function returns the nth CDR of list.  In other
	words, it skips past the first n links of list and returns
	what follows.

	If n is zero, nthcdr returns all of
	list.  If the length of list is n or less,
	nthcdr returns nil.


	(nthcdr 1 '(1 2 3 4))
			 => (2 3 4)
	(nthcdr 10 '(1 2 3 4))
			 => nil
	(nthcdr 0 '(1 2 3 4))
			 => (1 2 3 4)
*****  Function: last list &optional n
	This function returns the last link of list.  The car of
	this link is the list’s last element.  If list is null,
	nil is returned.  If n is non-nil, the
	nth-to-last link is returned instead, or the whole of list
	if n is bigger than list’s length.
*****  Function: safe-length list
	This function returns the length of list, with no risk of either
	an error or an infinite loop.  It generally returns the number of
	distinct cons cells in the list.  However, for circular lists,
	the value is just an upper bound; it is often too large.

	If list is not nil or a cons cell, safe-length
	returns 0.


	The most common way to compute the length of a list, when you are not
	worried that it may be circular, is with length.  See Sequence Functions.
*****  Function: caar cons-cell
	This is the same as (car (car cons-cell)).
*****  Function: cadr cons-cell
	This is the same as (car (cdr cons-cell))
	or (nth 1 cons-cell).
*****  Function: cdar cons-cell
	This is the same as (cdr (car cons-cell)).
*****  Function: cddr cons-cell
	This is the same as (cdr (cdr cons-cell))
	or (nthcdr 2 cons-cell).
	In addition to the above, 24 additional compositions of car and
	cdr are defined as cxxxr and cxxxxr,
	where each x is either a or d.  cadr,
	caddr, and cadddr pick out the second, third or fourth
	elements of a list, respectively.  cl-lib provides the same
	under the names cl-second, cl-third, and
	cl-fourth.  See List Functions in Common Lisp
	Extensions.
*****  Function: butlast x &optional n
	This function returns the list x with the last element,
	or the last n elements, removed.  If n is greater
	than zero it makes a copy of the list so as not to damage the
	original list.  In general, (append (butlast x n)
	(last x n)) will return a list equal to x.
*****  Function: nbutlast x &optional n
	This is a version of butlast that works by destructively
	modifying the cdr of the appropriate element, rather than
	making a copy of the list.

*** Lisp Symbol
**** Xah Lee. : 
***** The Concept of Symbols in Lisp : 
	 Lisp has symbols concept. Lisp's concept of “symbols” is somewhat like identifiers in other languages, except that:

			 lisp symbol can be held unevaluated, simply as itself, a inert name. In this sense, it's like a string.
			 lisp symbol stores more than one value.
	 The Concept of Symbols in Lisp

	 LISP differs from most programing languages such as C, Java, Ruby, Python, in that it deals with symbols, as opposed to just identifiers and values.

	 For example, in most languages, once you defined x=3, you cannot manipulate the variable “x” because it gets evaluated to 3 right away. If you want, you have to build a string "x" and manipulate this string, then use eval(lots string join here) to achieve the effect. (for example, you have a variable x, and it has integer 3 as value. you want to rename the variable so the new name is var_name + var_value.)

	 In lisp, after (setq x 3) then x would evaluate to 3, but (quote x) evaluates to the symbol x itself.

	 In practice, having a language dealing with “symbols” directly means that transformation of expressions in source code is possible at run-time. (In lisp, this is the lisp macro feature, which is a limited form of term rewriting languages such as Wolfram Language.) (info "(elisp) Macros")
	 Symbol's Cells
***** Each lisp symbol has the following “cells” to store things:

			 “print name” cell - a string, the same as the symbol. Automatically set, cannot be changed.
			 “value” cell - stores the symbol's value. When value cell is not void, the symbol is considered as a variable.
			 “function” cell - stores function definition object, lisp macros, or other objects that can act as function.
			 “property list” cell - hold a list of name/value pairs. Used for storing meta info about the symbol, such as function state, font face spec (for syntax coloring), deprecation flag, etc.

	 A symbol's value cell or function cell may be empty. If so, it's said to be “void”. When you try to get a cell's value that's void, it's a lisp error. (a empty cell is not the same as having value of nil.)

	 Normally, you don't need to worry about any of these tech details. The only thing that's useful for most elisp code is property list.

	 [see Elisp: Property List]

	 [see Elisp: Symbol Property List]

	 Understanding Lisp Symbol is important when you do advanced lisp programing. For example: macros, create and call functions at run-time, nested functions, manipulate evaluation, implementing a language, or any sort of meta-programing. If you don't have a need, you should not exploit these facilities in your program. Keep your code simple.

	 (info "(elisp) Symbols")
***** Quoting Symbol

	 A symbol, typically gets evaluated to its value. But you can stop this, by quote. e.g. (quote x). You can think of quote as “hold evaluation”.

	 quote has a shortcut syntax.

	 (quote x) is syntactically equivalent to 'x

	 (info "(elisp) Quoting")
****** 	When to Quote Symbol?

		Some functions, automatically quote the argument for you, as a convenience.

		For example, setq always automatically quotes its first argument. Because you basically always want the argument passed as a symbol. So, you write (setq x 3) instead of (set 'x 3).

		The function set is almost the same as setq, except that set does not automatically quote the first argument. So, you write (set 'x 3). (info "(elisp) Setting Variables")

		Some functions, require you to quote the argument yourself. Because sometimes you want a symbol's value passed, and sometimes the symbol itself.

		For example, mapcar's arguments are not automatically quoted. You may or may not want to quote them, depending on your use.

		Here's two examples of using mapcar, where in one example we want to quote the argument, and in the other example we do not want to quote the argument.

		;; suppose we have many functions
		(setq f '1+)
		(setq f 'cos)
		(setq f 'sqrt)
		;; we use f as a wrapper because we are not sure which function we want until run time

		;; here's our data
		(setq mylist '(1 2 3))

		;; normally, when using mapcar, we want first arg quoted
		(mapcar '1+ mylist) ; (2 3 4)

		;; here, we don't want first arg quoted
		(mapcar f mylist) ; (1.0 1.4142135623730951 1.7320508075688772)
***** Check If a Value is Symbol

		;; check if a variable eval to a lisp symbol

		;; make symbol x1's value cell to be 123
		(setq x1 123 )

		(symbolp x1) ; nil
		;; nil, because x1 is evaluated, and that value is 123, not a symbol

		(symbolp 'x1) ; t
***** Get Value of Symbol's Cells
		Here's how to get various cell's values.

		Here's a example of getting cell values, with symbol “sin” (sin is a builtin math function).

		;; get symbol's name cell value
		(symbol-name 'sin) ; "sin"

		;; get symbol's value cell value
		(symbol-value 'sin) ; void-variable error
		;; because the value cell of the symbol sin is void
		;; or, we just say that sin isn't a variable

		;; get symbol's function cell value
		(symbol-function 'sin) ;#<subr sin>
		;; the value is a primitive function (written in C), and has print form of #<subr sin>

		;; get symbol's property list cell value
		(symbol-plist 'sin) ; (side-effect-free t)

		Here's another example with a user defined symbol.

		;; get symbol cell values

		;; this makes symbol x1's value cell to contain the number 3
		(setq x1 3) ; 3

		;; get symbol's name cell value
		(symbol-name 'x1) ; "x1"

		;; get symbol's value cell value
		(symbol-value 'x1) ; 3

		;; get symbol's function cell value
		(symbol-function 'x1) ; nil
		;; in emacs 24.3.1, this is a void-function error
		;; in emacs 25.1, this returns nil
		;; elisp manual 24 and 25.1  say it should be error

		;; get symbol's property list cell value
		(symbol-plist 'x1) ;nil
***** Set Symbol's Name Cell
		Symbol's name cell is automatically set, as a string of the symbol name. Symbol name cell cannot be changed.
		Set Symbol's Value Cell

		The normal way to set a symbol's value cell is using setq.

		;; set a symbol's value cell
		(setq y "yes yes")

		;; get it
		(symbol-value 'y) ; "yes yes"

		(info "(elisp) Setting Variables")

		You can also check if a symbol's value cell is not empty, by boundp. (we think of it as checking if a variable is defined.)

		(boundp 'h) ; nil

		(setq h 4)

		(boundp 'h) ; t
***** Set Symbol's Function Cell
		The normal way to set a symbol's function cell is using defun or defmacro.

		;; a function that returns 4
		(defun z () 4)
		;; Note: return value of defun is not defined

		;; get a symbol's function cell value
		(symbol-function 'z) ; (lambda nil 4)

		(info "(elisp) Defining Functions")

		(info "(elisp) Function Cells")

		You can check if a symbol's function cell is not empty, by fboundp.

		(fboundp 'f) ; nil

		;; define a function that return 3
		(defun f () 3)

		;; now the fuction cell is filled
		(fboundp 'f) ; t

		Because a symbol can both hold a value and a function, a symbol can be both a variable and function. For example, the symbol buffer-file-name is both a variable and function. (you can try describe-function and describe-variable on it.)
***** Convert Symbol to String
		;; convert a symbol to string
		(symbol-name 'defun)
***** Convert String to Symbol
		;; convert a string to symbol

		;; if the symbol does not already exist in obarray, create it, put it in obarray
		(intern "x")

		;; if the symbol does not already exist in obarray, return nil
		(intern-soft "x")

**** fset : 
 (fset 'baz 'bar)
       bar

 (symbol-function 'baz)
       bar

***** Function: fset symbol definition

			This function stores definition in the function cell of symbol. The result is definition. Normally definition should be a function or the name of a function, but this is not checked. The argument symbol is an ordinary evaluated argument.

			The primary use of this function is as a subroutine by constructs that define or alter functions, like defun or advice-add (see Advising Functions). You can also use it to give a symbol a function definition that is not a function, e.g., a keyboard macro (see Keyboard Macros):

			;; Define a named keyboard macro.
			(fset 'kill-two-lines "\^u2\^k")
					 => "\^u2\^k"

			It you wish to use fset to make an alternate name for a function, consider using defalias instead. See Definition of defalias. 
**** 12.11 Advising Emacs Lisp Functions
 [[http://ergoemacs.org/emacs/elisp.html][Xah Emacs Lisp Tutorial]]
 Next: [[http://ergoemacs.org/emacs_manual/elisp/Obsolete-Functions.html#Obsolete-Functions][Obsolete Functions]], Previous: [[http://ergoemacs.org/emacs_manual/elisp/Closures.html#Closures][Closures]], Up: [[http://ergoemacs.org/emacs_manual/elisp/Functions.html#Functions][Functions]]   [[[http://ergoemacs.org/emacs_manual/elisp/index.html#SEC_Contents][Contents]]][[[http://ergoemacs.org/emacs_manual/elisp/index_index.html#Index][Index]]]
 When you need to modify a function defined in another library, or when you need to
 modify a hook like foo-function, a process filter, or basically any variable or object field
 which holds a function value, you can use the appropriate setter function, such as fset
 or defun for named functions, setq for hook variables, or set-process-filter for process
 filters, but those are often too blunt, completely throwing away the previous value. 

 The advice feature lets you add to the existing definition of a function, by advising the
 function. This is a cleaner method than redefining the whole function. 

 Emacs’s advice system provides two sets of primitives for that: the core set, for
 function values held in variables and object fields (with the corresponding primitives
 being add-function and remove-function) and another set layered on top of it for named
 functions (with the main primitives being advice-add and advice-remove). 

 For example, in order to trace the calls to the process filter of a process proc, you
 could use: 

 (defun my-tracing-function (proc string)
   (message "Proc %S received %S" proc string))

 (add-function :before (process-filter proc) #'my-tracing-function)

 This will cause the process’s output to be passed to my-tracing-function before being
 passed to the original process filter. my-tracing-function receives the same arguments
 as the original function. When you’re done with it, you can revert to the untraced
 behavior with: 

 (remove-function (process-filter proc) #'my-tracing-function)

 Similarly, if you want to trace the execution of the function named display-buffer, you
 could use: 

 (defun his-tracing-function (orig-fun &rest args)
   (message "display-buffer called with args %S" args)
   (let ((res (apply orig-fun args)))
     (message "display-buffer returned %S" res)
     res))

 (advice-add 'display-buffer :around #'his-tracing-function)

 Here, his-tracing-function is called instead of the original function and receives the
 original function (additionally to that function’s arguments) as argument, so it can call it
 if and when it needs to. When you’re tired of seeing this output, you can revert to the
 untraced behavior with: 

 (advice-remove 'display-buffer #'his-tracing-function)

 The arguments :before and :around used in the above examples specify how the two
 functions are composed, since there are many different ways to do it. The added
 function is also called a piece of advice. 

	• [[http://ergoemacs.org/emacs_manual/elisp/Core-Advising-Primitives.html#Core-Advising-Primitives][Core Advising Primitives]]:      Primitives to manipulate advice.   
	• [[http://ergoemacs.org/emacs_manual/elisp/Advising-Named-Functions.html#Advising-Named-Functions][Advising Named Functions]]:      Advising named functions.   
	• [[http://ergoemacs.org/emacs_manual/elisp/Advice-combinators.html#Advice-combinators][Advice combinators]]:      Ways to compose advice.   
	• [[http://ergoemacs.org/emacs_manual/elisp/Porting-old-advice.html#Porting-old-advice][Porting old advice]]:      Adapting code using the old  
			defadvice.   

 Next: [[http://ergoemacs.org/emacs_manual/elisp/Obsolete-Functions.html#Obsolete-Functions][Obsolete Functions]], Previous: [[http://ergoemacs.org/emacs_manual/elisp/Closures.html#Closures][Closures]], Up: [[http://ergoemacs.org/emacs_manual/elisp/Functions.html#Functions][Functions]]   [[[http://ergoemacs.org/emacs_manual/elisp/index.html#SEC_Contents][Contents]]][[[http://ergoemacs.org/emacs_manual/elisp/index_index.html#Index][Index]]]

**** Elisp: Symbol Property List
 Each lisp symbol is associated with a “property list”.

 This property list is stored in the symbol's property list cell. [see Elisp: Lisp Symbol]

 Emacs lisp property list is used extensively in emacs. It is also very useful if you want to write a function with state. You can store the state info with the symbol itself, instead of using a global variable.
 Set Whole Plist

 (setplist SYMBOL NEWPLIST) - Set SYMBOL's property list to NEWPLIST, and return NEWPLIST.

 ;; set the value of symbol ff's property list
 (setplist 'ff '(a 1 b 2))

 Get Whole Plist

 (symbol-plist SYMBOL) - Return SYMBOL's property list.

 ;; get the value of symbol ff's property list
 (symbol-plist 'ff )

 Add/Set a Key's Value

 (put SYMBOL PROPNAME VALUE) - Store SYMBOL's PROPNAME property with value VALUE.

 ;; set the value of key xx, of symbol ff's property list
 (put 'ff 'xx 5)

 Get a Key's Value

 (get SYMBOL PROPNAME) - Return the value of SYMBOL's PROPNAME property.

 ;; get the value of key xx, of symbol ff's property list
 (get 'ff 'xx)

**** 11.4 When a Variable is Void
***** is void if : 
	We say that a variable is void if its symbol has an unassigned value
	cell (see Symbol Components).

	Under Emacs Lisp’s default dynamic scoping rule (see Variable Scoping), the value cell stores the variable’s current (local or
	global) value.  Note that an unassigned value cell is not the
	same as having nil in the value cell.  The symbol nil is
	a Lisp object and can be the value of a variable, just as any other
	object can be; but it is still a value.  If a variable is void, trying
	to evaluate the variable signals a void-variable error, instead
	of returning a value.

	Under the optional lexical scoping rule, the value cell only holds
	the variable’s global value—the value outside of any lexical binding
	construct.  When a variable is lexically bound, the local value is
	determined by the lexical environment; hence, variables can have local
	values even if their symbols’ value cells are unassigned.
*****  Function: makunbound symbol
	This function empties out the value cell of symbol, making the
	variable void.  It returns symbol.

	If symbol has a dynamic local binding, makunbound voids
	the current binding, and this voidness lasts only as long as the local
	binding is in effect.  Afterwards, the previously shadowed local or
	global binding is reexposed; then the variable will no longer be void,
	unless the reexposed binding is void too.

	Here are some examples (assuming dynamic binding is in effect):


	(setq x 1)               ; Put a value in the global binding.
			 => 1
	(let ((x 2))             ; Locally bind it.
		(makunbound 'x)        ; Void the local binding.
		x)
	error Symbol's value as variable is void: x
	x                        ; The global binding is unchanged.
			 => 1

	(let ((x 2))             ; Locally bind it.
		(let ((x 3))           ; And again.
			(makunbound 'x)      ; Void the innermost-local binding.
			x))                  ; And refer: it’s void.
	error Symbol's value as variable is void: x

	(let ((x 2))
		(let ((x 3))
			(makunbound 'x))     ; Void inner binding, then remove it.
		x)                     ; Now outer let binding is visible.
			 => 2
*****  Function: boundp variable
	This function returns t if variable (a symbol) is not
	void, and nil if it is void.

	Here are some examples (assuming dynamic binding is in effect):


	(boundp 'abracadabra)          ; Starts out void.
			 => nil
	(let ((abracadabra 5))         ; Locally bind it.
		(boundp 'abracadabra))
			 => t
	(boundp 'abracadabra)          ; Still globally void.
			 => nil
	(setq abracadabra 5)           ; Make it globally nonvoid.
			 => 5
	(boundp 'abracadabra)
			 => t
**** 11.7 Accessing Variable Values
 The usual way to reference a variable is to write the symbol which
 names it.  See Symbol Forms.

 Occasionally, you may want to reference a variable which is only
 determined at run time.  In that case, you cannot specify the variable
 name in the text of the program.  You can use the symbol-value
 function to extract the value.


 Function: symbol-value symbol
 This function returns the value stored in symbol’s value cell.
 This is where the variable’s current (dynamic) value is stored.  If
 the variable has no local binding, this is simply its global value.
 If the variable is void, a void-variable error is signaled.

 If the variable is lexically bound, the value reported by
 symbol-value is not necessarily the same as the variable’s
 lexical value, which is determined by the lexical environment rather
 than the symbol’s value cell.  See Variable Scoping.


 (setq abracadabra 5)
			=> 5
 (setq foo 9)
			=> 9

 ;; Here the symbol abracadabra
 ;;   is the symbol whose value is examined.
 (let ((abracadabra 'foo))
   (symbol-value 'abracadabra))
			=> foo

 ;; Here, the value of abracadabra,
 ;;   which is foo,
 ;;   is the symbol whose value is examined.
 (let ((abracadabra 'foo))
   (symbol-value abracadabra))
			=> 9

 (symbol-value 'abracadabra)
			=> 5
*** Vectors
**** Xah Emacs
***** Elisp: Vector
 Emacs lisp vector datatype is
	 a ordered sequence of values, with fixed number of elements.


	Vector is a ordered sequence of values.
	Each element can be any type.
	Element's value can be changed.
	Number of elements cannot change. (i.e. Vector's length is fixed.)
	Read/Write to any position has constant access time.
***** Create Vector
	(make-vector 5 0)Create a vector of length 5, value 0 for all elements.

	;; create a vector of length 5, value 0 for all elements
	(make-vector 5 0) ;; [0 0 0 0 0]


	(vector a b …)Create a vector with elements, the elements are evaluated.


	;; create a vector and set to var v
	(setq v (vector 3 4 5))

	(setq x 7)

	;; each element will be evaluated
	(setq v (vector 3 x 5))

	v ; [3 7 5]


	[a b …]Create a vector, do not evaluate elements.


	(setq n 7)

	;; create a vector of elements 3 n 5. each element is NOT evaluated
	(setq v [3 n 5])

	v ; [3 n 5]
	;; the n remains a symbol, not 7
***** Fill Vector
	(fillarray array val)Make all elements of array to have value val
	.


	(setq aa [3 4 5])
	(fillarray aa nil) ;; [nil nil nil]

	Length

	(length (vector 7 4 5)) ; 3
*****  Get Element
	(aref array n)Return the element of array at index n.
	(elt sequence n)Return element of sequence at index n.


	When emacs doc mentions “ARRAY”, you can think of it as “vector or string”.

	When emacs doc mentions “SEQUENCE”, you can think of it as “list or array”.

	;; get a element from vector
	(aref ["a" "b" "c"] 0) ; => "a"

	;; get a element from vector
	(elt ["a" "b" "c"] 0) ; => "a"



	What's the difference between aref and elt?

	elt is more general. It works on vector and list.
	But if you know it's vector, you should use aref, because it's precise and faster.
	[see Elisp: Sequence Type]
*****  Change Element
	(aset ARRAY IDX NEWELT)Store into the element of ARRAY at index IDX the value NEWELT. Return NEWELT.


	(setq v [3 4 5])
	(aset v 0 "b")
	v  ; => ["b" 4 5]

*****  Nested Vector
	Vector can be nested in any way, because the elements can be any type.

	;; nested vector
	[[1 2] [3 4]] ; 2 by 2 matrix

	;; random nested vector
	[8 [3 [2 9] c] 7 [4 "b"]]
*****  Join Vectors, Convert List to Vector
	(vconcat sequence1 sequence2 …)Join any sequence types and return a vector. (List and vector are both sequence types.)


	;; join any sequence types
	(vconcat [3 4] ["a" "b"]) ; => [3 4 "a" "b"]

	(vconcat [3 4] '("a" "b")) ; => [3 4 "a" "b"]

	(vconcat [3 4] "ab") ; => [3 4 97 98]
	;; string elements are converted to char.
	;; 97 is the codepoint for the char a
*****  Convert Vector to List
	(append sequence1 sequence2 …)Join any sequence types and return a list. (List and vector are both sequence types.)
	Warning: if you want it to return a propert list, the last element must be a list, or nil.

	;; convert vector to list
	(append [1 2 3] nil)
	; => (1 2 3)

	(append [1 2 3] [4 5] )
	;; (1 2 3 . [4 5])
	;; this is improper list

	(append [1 2 3] [4 5] nil)
	;; (1 2 3 4 5)
	;; proper list

	(append [1 2 3] [4 5] '(6))
	;; (1 2 3 4 5 6)
	;; proper list
**** Functions That Operate on Vectors
 Here are some functions that relate to vectors:
***** Function: vectorp object
			This function returns t if object is a vector.

			(vectorp [a])
					 => t
			(vectorp "asdf")
					 => nil

	Function: vector &rest objects
			This function creates and returns a vector whose elements are the arguments, objects.

			(vector 'foo 23 [bar baz] "rats")
					 => [foo 23 [bar baz] "rats"]
			(vector)
					 => []
***** Function: make-vector length object
			This function returns a new vector consisting of length elements, each initialized to object.

			(setq sleepy (make-vector 9 'Z))
					 => [Z Z Z Z Z Z Z Z Z]
***** Function: vconcat &rest sequences
			This function returns a new vector containing all the elements of the sequences. The arguments sequences may be lists, vectors, or strings. If no sequences are given, an empty vector is returned.
****** constructed vector : 
			 The value is a newly constructed vector that is not eq to any existing vector.

			 (setq a (vconcat '(A B C) '(D E F)))
						=> [A B C D E F]
			 (eq a (vconcat a))
						=> nil
			 (vconcat)
						=> []
			 (vconcat [A B C] "aa" '(foo (6 7)))
						=> [A B C 97 97 foo (6 7)]
****** integers as arguments : 
			 The vconcat function also allows integers as arguments. It converts them to strings of digits, making up the decimal print representation of the integer, and then uses the strings instead of the original integers. Don't use this feature; we plan to eliminate it. If you already use this feature, change your programs now! The proper way to convert an integer to a decimal number in this way is with format (see section Formatting Strings) or number-to-string (see section Conversion of Characters and Strings).
****** other concatenation : 
			 For other concatenation functions, see mapconcat in section Mapping Functions, concat in section Creating Strings, and append in section Building Cons Cells and Lists. 
****** convert a vector into : 
	 The append function provides a way to convert a vector into a list with the same elements (see section Building Cons Cells and Lists):
	 (setq avector [1 two (quote (three)) "four" [five]])
				=> [1 two (quote (three)) "four" [five]]
	 (append avector nil)
				=> (1 two (quote (three)) "four" [five])
**** VectorUsage
***** https://www.emacswiki.org/emacs/VectorUsage
 Usually you should not be trying to modify vectors themselves, only the elements stored
 in the vector, because vectors are designed for random access. They are fast. They
 are not designed to be searched or sorted. They are also immutable, so you cannot
 change them (only the elements). If you want change them (change their size), you
 must create a copy instead.
***** Sorting/Randomizing/Shuffling
     (defun shuffle-vector (vector)
       "Randomly permute the elements of VECTOR (all permutations equally likely)."
       (let ((i 0)
    	 j
    	 temp
    	 (len (length vector)))
         (while (< i len)
           (setq j (+ i (random (- len i))))
           (setq temp (aref vector i))
           (aset vector i (aref vector j))
           (aset vector j temp)
           (setq i (1+ i))))
       vector)

 Example output:

     [1 5 3 2 4]
     [3 2 5 1 4]
     [3 4 1 5 2]
***** Searching Vectors for Values
 You can search lists using member or memq, and you can search alists using assoc
 and assq.
 Here is how to search a vector for a value:

     (position 'c [a b c])
     => 2
 The position is a function from the CL package.

 Here is how to search a vector v for a value b using the loop macro. This may be more
 useful if you need to do things with the elements as you search.

     (let ((v [4 5 6 7 8])
           (b 7))
       (loop for i from 0 for a across v if (equal a b) return i))
			=> 3

 The distinction may also be important if you’re trying to avoid loading the CL package
 (it is always loaded in XEmacs): Functions require loading the CL package, macros
 only require loading the CL package at compile-time:
     (eval-when-compile (require 'cl))
*****  Library Ring+

 [[https://www.emacswiki.org/emacs/DrewAdams][DrewAdams]] has written library [[https://www.emacswiki.org/emacs/ring+.el][Lisp:ring+.el]], which extends standard library ring.el to
 provides feature for using vectors as cyclic structures (“rings”). See [[https://www.emacswiki.org/emacs/RingPlus][RingPlus]].

 This library includes function ‘ring-convert-sequence-to-ring’, which converts any
 sequence to a ring, which is a vector. A sequence is any of these:

 ,* list
 ,* array, which is any of these:

	* string
	* vector
	* char-table (like a vector, but indexed by character codes)
	* bool-vector (like a vector, but with only ‘t’ and ‘nil’ entries)
*****  A Gotcha!
 Don’t try to treat an [[https://www.emacswiki.org/emacs/obarray][obarray]] as a normal vector! The [[http://www.emacswiki.org/cgi-bin/info-ref?find=Creating%20Symbols][Elisp manual]] tells you this clearly,
 but I nevertheless tried to do this (programming idiom pointed out in the discussion of
 vectors in the same manual):

   (setq my-list (append minibuffer-completion-table nil)) ; Convert vector to list.

 Wrong! And it took me while to figure the problem out…

 When dealing with obarrays, use ‘mapatoms’ – always. – [[https://www.emacswiki.org/emacs/DrewAdams][DrewAdams]]
*****  See Also
 ,* [[https://www.emacswiki.org/emacs/LevenshteinDistance][LevenshteinDistance]] - Uses vectors for determining the edit distance between two
	strings.
 For more info on sequences, see the Elisp manual, Info node Sequences Arrays
 Vectors.

*** Sequences 
**** 6.1 Sequences
	Next: [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Arrays.html#Arrays][Arrays]], Up: [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequences-Arrays-Vectors.html#Sequences-Arrays-Vectors][Sequences Arrays Vectors]]   [[[https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html#SEC_Contents][Contents]]][[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Index.html#Index][Index]]]
	This section describes functions that accept any kind of sequence. 
***** Function: sequencep object

		This function returns t if object is a list, vector, string, bool-vector, or char-table, nil
		otherwise. See also seqp below. 
***** Function: length sequence

		This function returns the number of elements in sequence. The function signals the
		wrong-type-argument error if the argument is not a sequence or is a dotted list; it
		signals the circular-list error if the argument is a circular list. For a char-table, the
		value returned is always one more than the maximum Emacs character code. 

		See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/List-Elements.html#Definition-of-safe_002dlength][Definition of safe-length]], for the related function safe-length. 

	 (length '(1 2 3))
			 => 3
	 (length ())
			 => 0
	 (length "foobar")
			 => 6
	 (length [1 2 3])
			 => 3
	 (length (make-bool-vector 5 nil))
			 => 5

	 See also string-bytes, in [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Representations.html#Text-Representations][Text Representations]]. 

	 If you need to compute the width of a string on display, you should use string-width
	 (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Size-of-Displayed-Text.html#Size-of-Displayed-Text][Size of Displayed Text]]), not length, since length only counts the number of
	 characters, but does not account for the display width of each character. 
***** Function: elt sequence index

		This function returns the element of sequence indexed by index. Legitimate values
		of index are integers ranging from 0 up to one less than the length of sequence. If
		sequence is a list, out-of-range values behave as for nth. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/List-Elements.html#Definition-of-nth][Definition of nth]].
		Otherwise, out-of-range values trigger an args-out-of-range error. 

	 (elt [1 2 3 4] 2)
				=> 3
	 (elt '(1 2 3 4) 2)
				=> 3
	 ;; We use string to show clearly which character elt returns.
	 (string (elt "1234" 2))
				=> "3"
	 (elt [1 2 3 4] 4)
				error-> Args out of range: [1 2 3 4], 4
	 (elt [1 2 3 4] -1)
				error-> Args out of range: [1 2 3 4], -1

		This function generalizes aref (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Array-Functions.html#Array-Functions][Array Functions]]) and nth (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/List-Elements.html#Definition-of-nth][Definition of]]
		[[https://www.gnu.org/software/emacs/manual/html_node/elisp/List-Elements.html#Definition-of-nth][nth]]). 
***** Function: copy-sequence seqr

		This function returns a copy of seqr, which should be either a sequence or a
		record. The copy is the same type of object as the original, and it has the same
		elements in the same order. However, if seqr is empty, like a string or a vector of
		zero length, the value returned by this function might not be a copy, but an empty
		object of the same type and identical to seqr. 

		Storing a new element into the copy does not affect the original seqr, and vice
		versa. However, the elements of the copy are not copies; they are identical (eq) to
		the elements of the original. Therefore, changes made within these elements, as
		found via the copy, are also visible in the original. 

		If the argument is a string with text properties, the property list in the copy is itself
		a copy, not shared with the original’s property list. However, the actual values of
		the properties are shared. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties][Text Properties]]. 

		This function does not work for dotted lists. Trying to copy a circular list may cause
		an infinite loop. 

		See also append in [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Building-Lists.html#Building-Lists][Building Lists]], concat in [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Strings.html#Creating-Strings][Creating Strings]], and vconcat in
		[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Vector-Functions.html#Vector-Functions][Vector Functions]], for other ways to copy sequences. 

	 (setq bar (list 1 2))
				=> (1 2)
	 (setq x (vector 'foo bar))
				=> [foo (1 2)]
	 (setq y (copy-sequence x))
				=> [foo (1 2)]


	 (eq x y)
				=> nil
	 (equal x y)
				=> t
	 (eq (elt x 1) (elt y 1))
				=> t


	 ;; Replacing an element of one sequence.
	 (aset x 0 'quux)
	 x => [quux (1 2)]
	 y => [foo (1 2)]


	 ;; Modifying the inside of a shared element.
	 (setcar (aref x 1) 69)
	 x => [quux (69 2)]
	 y => [foo (69 2)]
***** Function: reverse sequence

		This function creates a new sequence whose elements are the elements of
		sequence, but in reverse order. The original argument sequence is not altered.
		Note that char-tables cannot be reversed. 

	 (setq x '(1 2 3 4))
				=> (1 2 3 4)
	 (reverse x)
				=> (4 3 2 1)
	 x
				=> (1 2 3 4)
	 (setq x [1 2 3 4])
				=> [1 2 3 4]
	 (reverse x)
				=> [4 3 2 1]
	 x
				=> [1 2 3 4]
	 (setq x "xyzzy")
				=> "xyzzy"
	 (reverse x)
				=> "yzzyx"
	 x
				=> "xyzzy"
***** Function: nreverse sequence

		This function reverses the order of the elements of sequence. Unlike reverse the
		original sequence may be modified. 

		For example: 

	 (setq x (list 'a 'b 'c))
				=> (a b c)
	 x
				=> (a b c)
	 (nreverse x)
				=> (c b a)
	 ;; The cons cell that was first is now last.
	 x
				=> (a)

		To avoid confusion, we usually store the result of nreverse back in the same
		variable which held the original list: 

	 (setq x (nreverse x))

		Here is the nreverse of our favorite example, (a b c), presented graphically: 

	 Original list head:                       Reversed list:
		-------------        -------------        ------------
	 | car  | cdr  |      | car  | cdr  |      | car | cdr  |
	 |   a  |  nil |<--   |   b  |   o  |<--   |   c |   o  |
	 |      |      |   |  |      |   |  |   |  |     |   |  |
		-------------    |   --------- | -    |   -------- | -
										 |             |      |            |
											-------------        ------------

		For the vector, it is even simpler because you don’t need setq: 

	 (setq x (copy-sequence [1 2 3 4]))
				=> [1 2 3 4]
	 (nreverse x)
				=> [4 3 2 1]
	 x
				=> [4 3 2 1]

		Note that unlike reverse, this function doesn’t work with strings. Although you can
		alter string data by using aset, it is strongly encouraged to treat strings as
		immutable even when they are mutable. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Mutability.html#Mutability][Mutability]]. 
***** Function: sort sequence predicate

		This function sorts sequence stably. Note that this function doesn’t work for all
		sequences; it may be used only for lists and vectors. If sequence is a list, it is
		modified destructively. This functions returns the sorted sequence and compares
		elements using predicate. A stable sort is one in which elements with equal sort
		keys maintain their relative order before and after the sort. Stability is important
		when successive sorts are used to order elements according to different criteria. 

		The argument predicate must be a function that accepts two arguments. It is
		called with two elements of sequence. To get an increasing order sort, the
		predicate should return non-nil if the first element is “less” than the second, or nil if
		not. 

		The comparison function predicate must give reliable results for any given pair of
		arguments, at least within a single call to sort. It must be antisymmetric; that is, if
		a is less than b, b must not be less than a. It must be transitive—that is, if a is less
		than b, and b is less than c, then a must be less than c. If you use a comparison
		function which does not meet these requirements, the result of sort is
		unpredictable. 

		The destructive aspect of sort for lists is that it rearranges the cons cells forming
		sequence by changing CDRs. A nondestructive sort function would create new
		cons cells to store the elements in their sorted order. If you wish to make a sorted
		copy without destroying the original, copy it first with copy-sequence and then
		sort. 

		Sorting does not change the CARs of the cons cells in sequence; the cons cell
		that originally contained the element a in sequence still has a in its CAR after
		sorting, but it now appears in a different position in the list due to the change of
		CDRs. For example: 

	 (setq nums (list 1 3 2 6 5 4 0))
				=> (1 3 2 6 5 4 0)
	 (sort nums #'<)
				=> (0 1 2 3 4 5 6)
	 nums
				=> (1 2 3 4 5 6)

		Warning: Note that the list in nums no longer contains 0; this is the same cons
		cell that it was before, but it is no longer the first one in the list. Don’t assume a
		variable that formerly held the argument now holds the entire sorted list! Instead,
		save the result of sort and use that. Most often we store the result back into the
		variable that held the original list: 

	 (setq nums (sort nums #'<))

		For the better understanding of what stable sort is, consider the following vector
		example. After sorting, all items whose car is 8 are grouped at the beginning of
		vector, but their relative order is preserved. All items whose car is 9 are grouped
		at the end of vector, but their relative order is also preserved: 

	 (setq
		 vector
		 (vector '(8 . "xxx") '(9 . "aaa") '(8 . "bbb") '(9 . "zzz")
						 '(9 . "ppp") '(8 . "ttt") '(8 . "eee") '(9 . "fff")))
				=> [(8 . "xxx") (9 . "aaa") (8 . "bbb") (9 . "zzz")
						(9 . "ppp") (8 . "ttt") (8 . "eee") (9 . "fff")]
	 (sort vector (lambda (x y) (< (car x) (car y))))
				=> [(8 . "xxx") (8 . "bbb") (8 . "ttt") (8 . "eee")
						(9 . "aaa") (9 . "zzz") (9 . "ppp") (9 . "fff")]

		See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sorting.html#Sorting][Sorting]], for more functions that perform sorting. See documentation in
		[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Accessing-Documentation.html#Accessing-Documentation][Accessing Documentation]], for a useful example of sort. 

	 The seq.el library provides the following additional sequence manipulation macros and
	 functions, prefixed with seq-. To use them, you must first load the seq library. 

	 All functions defined in this library are free of side-effects; i.e., they do not modify any
	 sequence (list, vector, or string) that you pass as an argument. Unless otherwise
	 stated, the result is a sequence of the same type as the input. For those functions that
	 take a predicate, this should be a function of one argument. 

	 The seq.el library can be extended to work with additional types of sequential
	 data-structures. For that purpose, all functions are defined using cl-defgeneric. See
	 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html#Generic-Functions][Generic Functions]], for more details about using cl-defgeneric for adding extensions. 
***** Function: seq-elt sequence index

		This function returns the element of sequence at the specified index, which is an
		integer whose valid value range is zero to one less than the length of sequence.
		For out-of-range values on built-in sequence types, seq-elt behaves like elt. For
		the details, see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequence-Functions.html#Definition-of-elt][Definition of elt]]. 

	 (seq-elt [1 2 3 4] 2)
	 => 3

		seq-elt returns places settable using setf (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Setting-Generalized-Variables.html#Setting-Generalized-Variables][Setting Generalized Variables]]). 

	 (setq vec [1 2 3 4])
	 (setf (seq-elt vec 2) 5)
	 vec
	 => [1 2 5 4]
***** Function: seq-length sequence
		This function returns the number of elements in sequence. For built-in sequence
		types, seq-length behaves like length. See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequence-Functions.html#Definition-of-length][Definition of length]]. 
***** Function: seqp object

		This function returns non-nil if object is a sequence (a list or array), or any
		additional type of sequence defined via seq.el generic functions. This is an
		extensible variant of sequencep. 

	 (seqp [1 2])
	 => t
	 (seqp 2)
	 => nil
***** Function: seq-drop sequence n

		This function returns all but the first n (an integer) elements of sequence. If n is
		negative or zero, the result is sequence. 

	 (seq-drop [1 2 3 4 5 6] 3)
	 => [4 5 6]
	 (seq-drop "hello world" -4)
	 => "hello world"
***** Function: seq-take sequence n

		This function returns the first n (an integer) elements of sequence. If n is negative
		or zero, the result is nil. 

	 (seq-take '(1 2 3 4) 3)
	 => (1 2 3)
	 (seq-take [1 2 3 4] 0)
	 => []
***** Function: seq-take-while predicate sequence

		This function returns the members of sequence in order, stopping before the first
		one for which predicate returns nil. 

	 (seq-take-while (lambda (elt) (> elt 0)) '(1 2 3 -1 -2))
	 => (1 2 3)
	 (seq-take-while (lambda (elt) (> elt 0)) [-1 4 6])
	 => []
***** Function: seq-drop-while predicate sequence

		This function returns the members of sequence in order, starting from the first one
		for which predicate returns nil. 

	 (seq-drop-while (lambda (elt) (> elt 0)) '(1 2 3 -1 -2))
	 => (-1 -2)
	 (seq-drop-while (lambda (elt) (< elt 0)) [1 4 6])
	 => [1 4 6]
***** Function: seq-do function sequence

		This function applies function to each element of sequence in turn (presumably for
		side effects), and returns sequence. 
***** Function: seq-map function sequence
		This function returns the result of applying function to each element of sequence.
		The returned value is a list. 

	 (seq-map #'1+ '(2 4 6))
	 => (3 5 7)
	 (seq-map #'symbol-name [foo bar])
	 => ("foo" "bar")
***** Function: seq-map-indexed function sequence

		This function returns the result of applying function to each element of sequence
		and its index within seq. The returned value is a list. 

	 (seq-map-indexed (lambda (elt idx)
											(list idx elt))
										'(a b c))
	 => ((0 a) (b 1) (c 2))
***** Function: seq-mapn function &rest sequences

		This function returns the result of applying function to each element of sequences.
		The arity (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/What-Is-a-Function.html#What-Is-a-Function][subr-arity]]) of function must match the number of sequences.
		Mapping stops at the end of the shortest sequence, and the returned value is a
		list. 

	 (seq-mapn #'+ '(2 4 6) '(20 40 60))
	 => (22 44 66)
	 (seq-mapn #'concat '("moskito" "bite") ["bee" "sting"])
	 => ("moskitobee" "bitesting")
***** Function: seq-filter predicate sequence

		This function returns a list of all the elements in sequence for which predicate
		returns non-nil. 

	 (seq-filter (lambda (elt) (> elt 0)) [1 -1 3 -3 5])
	 => (1 3 5)
	 (seq-filter (lambda (elt) (> elt 0)) '(-1 -3 -5))
	 => nil
***** Function: seq-remove predicate sequence

		This function returns a list of all the elements in sequence for which predicate
		returns nil. 

	 (seq-remove (lambda (elt) (> elt 0)) [1 -1 3 -3 5])
	 => (-1 -3)
	 (seq-remove (lambda (elt) (< elt 0)) '(-1 -3 -5))
	 => nil
***** Function: seq-reduce function sequence initial-value

		This function returns the result of calling function with initial-value and the first
		element of sequence, then calling function with that result and the second element
		of sequence, then with that result and the third element of sequence, etc. function
		should be a function of two arguments. If sequence is empty, this returns
		initial-value without calling function. 

	 (seq-reduce #'+ [1 2 3 4] 0)
	 => 10
	 (seq-reduce #'+ '(1 2 3 4) 5)
	 => 15
	 (seq-reduce #'+ '() 3)
	 => 3
***** Function: seq-some predicate sequence

		This function returns the first non-nil value returned by applying predicate to each
		element of sequence in turn. 

	 (seq-some #'numberp ["abc" 1 nil])
	 => t
	 (seq-some #'numberp ["abc" "def"])
	 => nil
	 (seq-some #'null ["abc" 1 nil])
	 => t
	 (seq-some #'1+ [2 4 6])
	 => 3
***** Function: seq-find predicate sequence &optional default

		This function returns the first element in sequence for which predicate returns
		non-nil. If no element matches predicate, the function returns default. 

		Note that this function has an ambiguity if the found element is identical to default,
		as in that case it cannot be known whether an element was found or not. 

	 (seq-find #'numberp ["abc" 1 nil])
	 => 1
	 (seq-find #'numberp ["abc" "def"])
	 => nil
***** Function: seq-every-p predicate sequence

		This function returns non-nil if applying predicate to every element of sequence
		returns non-nil. 

	 (seq-every-p #'numberp [2 4 6])
	 => t
	 (seq-every-p #'numberp [2 4 "6"])
	 => nil
***** Function: seq-empty-p sequence

		This function returns non-nil if sequence is empty. 

	 (seq-empty-p "not empty")
	 => nil
	 (seq-empty-p "")
	 => t
***** Function: seq-count predicate sequence

		This function returns the number of elements in sequence for which predicate
		returns non-nil. 

	 (seq-count (lambda (elt) (> elt 0)) [-1 2 0 3 -2])
	 => 2
***** Function: seq-sort function sequence

		This function returns a copy of sequence that is sorted according to function, a
		function of two arguments that returns non-nil if the first argument should sort
		before the second. 
***** Function: seq-sort-by function predicate sequence

		This function is similar to seq-sort, but the elements of sequence are transformed
		by applying function on them before being sorted. function is a function of one
		argument. 

	 (seq-sort-by #'seq-length #'> ["a" "ab" "abc"])
	 => ["abc" "ab" "a"]
***** Function: seq-contains-p sequence elt &optional function

		This function returns non-nil if at least one element in sequence is equal to elt. If
		the optional argument function is non-nil, it is a function of two arguments to use
		instead of the default equal. 

	 (seq-contains '(symbol1 symbol2) 'symbol1)
	 => symbol1
	 (seq-contains '(symbol1 symbol2) 'symbol3)
	 => nil
***** Function: seq-set-equal-p sequence1 sequence2 &optional testfn

		This function checks whether sequence1 and sequence2 contain the same
		elements, regardless of the order. If the optional argument testfn is non-nil, it is a
		function of two arguments to use instead of the default equal. 

	 (seq-set-equal-p '(a b c) '(c b a))
	 => t
	 (seq-set-equal-p '(a b c) '(c b))
	 => nil
	 (seq-set-equal-p '("a" "b" "c") '("c" "b" "a"))
	 => t
	 (seq-set-equal-p '("a" "b" "c") '("c" "b" "a") #'eq)
	 => nil
***** Function: seq-position sequence elt &optional function

		This function returns the index of the first element in sequence that is equal to elt.
		If the optional argument function is non-nil, it is a function of two arguments to use
		instead of the default equal. 

	 (seq-position '(a b c) 'b)
	 => 1
	 (seq-position '(a b c) 'd)
	 => nil
***** Function: seq-uniq sequence &optional function

		This function returns a list of the elements of sequence with duplicates removed.
		If the optional argument function is non-nil, it is a function of two arguments to use
		instead of the default equal. 

	 (seq-uniq '(1 2 2 1 3))
	 => (1 2 3)
	 (seq-uniq '(1 2 2.0 1.0) #'=)
	 => (1 2)
***** Function: seq-subseq sequence start &optional end

		This function returns a subset of sequence from start to end, both integers (end
		defaults to the last element). If start or end is negative, it counts from the end of
		sequence. 

	 (seq-subseq '(1 2 3 4 5) 1)
	 => (2 3 4 5)
	 (seq-subseq '[1 2 3 4 5] 1 3)
	 => [2 3]
	 (seq-subseq '[1 2 3 4 5] -3 -1)
	 => [3 4]
***** Function: seq-concatenate type &rest sequences

		This function returns a sequence of type type made of the concatenation of
		sequences. type may be: vector, list or string. 

	 (seq-concatenate 'list '(1 2) '(3 4) [5 6])
	 => (1 2 3 4 5 6)
	 (seq-concatenate 'string "Hello " "world")
	 => "Hello world"
***** Function: seq-mapcat function sequence &optional type

		This function returns the result of applying seq-concatenate to the result of
		applying function to each element of sequence. The result is a sequence of type
		type, or a list if type is nil. 

	 (seq-mapcat #'seq-reverse '((3 2 1) (6 5 4)))
	 => (1 2 3 4 5 6)
***** Function: seq-partition sequence n

		This function returns a list of the elements of sequence grouped into
		sub-sequences of length n. The last sequence may contain less elements than n.
		n must be an integer. If n is a negative integer or 0, the return value is nil. 

	 (seq-partition '(0 1 2 3 4 5 6 7) 3)
	 => ((0 1 2) (3 4 5) (6 7))
***** Function: seq-intersection sequence1 sequence2 &optional function

		This function returns a list of the elements that appear both in sequence1 and
		sequence2. If the optional argument function is non-nil, it is a function of two
		arguments to use to compare elements instead of the default equal. 

	 (seq-intersection [2 3 4 5] [1 3 5 6 7])
	 => (3 5)
***** Function: seq-difference sequence1 sequence2 &optional function

		This function returns a list of the elements that appear in sequence1 but not in
		sequence2. If the optional argument function is non-nil, it is a function of two
		arguments to use to compare elements instead of the default equal. 

	 (seq-difference '(2 3 4 5) [1 3 5 6 7])
	 => (2 4)
***** Function: seq-group-by function sequence

		This function separates the elements of sequence into an alist whose keys are the
		result of applying function to each element of sequence. Keys are compared
		using equal. 

	 (seq-group-by #'integerp '(1 2.1 3 2 3.2))
	 => ((t 1 3 2) (nil 2.1 3.2))
	 (seq-group-by #'car '((a 1) (b 2) (a 3) (c 4)))
	 => ((b (b 2)) (a (a 1) (a 3)) (c (c 4)))
***** Function: seq-into sequence type

		This function converts the sequence sequence into a sequence of type type. type
		can be one of the following symbols: vector, string or list. 

	 (seq-into [1 2 3] 'list)
	 => (1 2 3)
	 (seq-into nil 'vector)
	 => []
	 (seq-into "hello" 'vector)
	 => [104 101 108 108 111]
***** Function: seq-min sequence

		This function returns the smallest element of sequence. The elements of sequence
		must be numbers or markers (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Markers.html#Markers][Markers]]). 

	 (seq-min [3 1 2])
	 => 1
	 (seq-min "Hello")
	 => 72
***** Function: seq-max sequence

		This function returns the largest element of sequence. The elements of sequence
		must be numbers or markers. 

	 (seq-max [1 3 2])
	 => 3
	 (seq-max "Hello")
	 => 111

	 Macro: seq-doseq (var sequence) body…

		This macro is like dolist (see [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Iteration.html#Iteration][dolist]]), except that sequence can be a list, vector or
		string. This is primarily useful for side-effects. 

	 Macro: seq-let var-sequence val-sequence body…

		This macro binds the variables defined in var-sequence to the values that are the
		corresponding elements of val-sequence. This is known as destructuring
		binding. The elements of var-sequence can themselves include sequences,
		allowing for nested destructuring. 

		The var-sequence sequence can also include the &rest marker followed by a
		variable name to be bound to the rest of val-sequence. 

	 (seq-let [first second] [1 2 3 4]
		 (list first second))
	 => (1 2)
	 (seq-let (_ a _ b) '(1 2 3 4)
		 (list a b))
	 => (2 4)
	 (seq-let [a [b [c]]] [1 [2 [3]]]
		 (list a b c))
	 => (1 2 3)
	 (seq-let [a b &rest others] [1 2 3 4]
		 others)
	 => [3 4]

		The pcase patterns provide an alternative facility for destructuring binding, see
		[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Destructuring-with-pcase-Patterns.html#Destructuring-with-pcase-Patterns][Destructuring with pcase Patterns]]. 
***** Function: seq-random-elt sequence

		This function returns an element of sequence taken at random. 

	 (seq-random-elt [1 2 3 4])
	 => 3
	 (seq-random-elt [1 2 3 4])
	 => 2
	 (seq-random-elt [1 2 3 4])
	 => 4
	 (seq-random-elt [1 2 3 4])
	 => 2
	 (seq-random-elt [1 2 3 4])
	 => 1

		If sequence is empty, this function signals an error. 

	 Next: [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Arrays.html#Arrays][Arrays]], Up: [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequences-Arrays-Vectors.html#Sequences-Arrays-Vectors][Sequences Arrays Vectors]]   [[[https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html#SEC_Contents][Contents]]][[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Index.html#Index][Index]]]
*** map over 
**** [[https://emacs.stackexchange.com/questions/2961/how-can-i-map-over-a-vector-and-get-a-vector][How can I map over a vector and get a vector?]]
***** The only thing I've found that works is
(eval `(vector ,@(mapcar #'1+ [1 2 3 4])))
=> [2 3 4 5]
but that seems far too complicated to be the 'right' way.
***** Use [[https://www.gnu.org/software/emacs/manual/html_node/cl/Mapping-over-Sequences.html][cl-map]], instead:
(cl-map 'vector #'1+ [1 2 3 4])

A little extra background: cl-map is the [[http://clhs.lisp.se/Body/f_map.htm][Common Lisp map function]] that generalizes to
sequence types:

(cl-map 'vector #'1+ '[1 2 3 4]) ;; ==> [2 3 4 5]
(cl-map 'list   #'1+ '(1 2 3 4)) ;; ==> (2 3 4 5)
(cl-map 'string #'upcase "abc")  ;; ==> "ABC"

It can also convert between sequence types (eg, here, the input is a list and the output
is a vector):

(cl-map 'vector #'1+ '(1 2 3 4)) ;; ==> [2 3 4 5]
***** :) Don't the cl libraries give compiler : 
 18 seconds the 'winner' :) Don't the cl libraries give compiler warnings, though?
 (Mostly because the FSF is obnoxious?) – [[https://emacs.stackexchange.com/users/2264/sean-allred][Sean Allred]] Nov 1 '14 at 14:51 

 FWIW, I think the byte compilation problems were related to the old cl library rather
 than the rejiggered cl-lib library. I don't for example, get any warnings when I (defun
 fnx () (cl-map 'vector #'1+ '[1 2 3 4])) and then (byte-compile 'fnx). –  Nov 1 '14
 
,* 2 
 Even if you use the compatibility cl-lib, I think you'll get warnings on older emacs
 (24.2). I wouldn't worry about it though, you have to pick your battles. – [[https://emacs.stackexchange.com/users/50/malabarba][Malabarba]]
,* Note that this dynamically creates a list, then converts that to a vector and discards
 the temporary list. – [[https://emacs.stackexchange.com/users/2429/cl%c3%a9ment][Clément]] Apr 13 at 22:05 

***** without the cl : 
Since I was beat by 18 seconds, here's a simpler and safer way to do it without the cl
library. It also doesn't evaluate the elements. 

(apply #'vector (mapcar #'1+ [1 2 3 4])) ;; => [2 3 4 5]

 ,* That's also quite nice! Re: your earlier comment about older Emacs: it seems
	especially helpful if you have to anticipate legacy users. It seems most helpful if you
	only have to use it in a couple of spots, at which point you can trade off the slight
	inconvenience against avoiding the cl-lib dependency. – [[https://emacs.stackexchange.com/users/253/dan][Dan♦]] Nov 1 '14 at 15:27 
 ,* 1 
	Very nifty!! I didn't think about using apply. – [[https://emacs.stackexchange.com/users/2264/sean-allred][Sean Allred]] Nov 1 '14 at 22:51 
 ,* I think (apply #'vector ...) might be ever so slightly faster, but for completeness, it can
	also be replaced with (vconcat ...). – [[https://emacs.stackexchange.com/users/15748/basil][Basil]] Nov 12 '18 at 20:03 

***** not so elegant inplace-variant : 
 The not so elegant inplace-variant for the case that the original vector is no longer
 needed afterwards and memory allocation is time-critical (e.g. the vector is big).

 (setq x [1 2 3 4])

 (cl-loop for var across-ref x do
					(setf var (1+ var)))

 The result is stored in x. If you need the form to return x in the end you can add finally
 return x as follows:

 (cl-loop for var across-ref x do
					(setf var (1+ var))
					finally return x)

***** For completeness, using seq:
	(require 'seq)
	(seq-into (seq-map #'1+ [1 2 3 4]) 'vector)

	,* There is a deleted answer from [[https://emacs.stackexchange.com/users/19761/f%c3%b3lkvangr][Fólkvangr]] 2018-11-12 with the exact same seq-into
	 line. The user has deleted his answer for the following reason: " My solution is less
	 relevant because the seq library uses the underlying Common Lisp extensions. –
	 Fólkvangr May 16 at 8:53" – [[https://emacs.stackexchange.com/users/2370/tobias][Tobias]] Jun 19 '19 at 7:28 
	,* @Tobias I guess I'd disagree with that logic. Everything is going to end up using
	 vconcat or vector anyway, but the different interface paradigms are useful to have on
	 record. – [[https://emacs.stackexchange.com/users/2264/sean-allred][Sean Allred]] Jun 19 '19 at 10:31 
	,* No problem. I just saw the deleted answer of Fólkvangr (almost) matching yours and
	 wanted to notify you. For whatever reason seeing deleted answers requires 10000
	 rep:-(. – [[https://emacs.stackexchange.com/users/2370/tobias][Tobias]] Jun 19 '19 at 11:02 
	,* @Tobias yeah, I never really understood why those privileges were site-specific :-) –

***** You can use loop

	(let ((v (vector 1 2 3 4)))
		(dotimes (i (length v))
			(aset v i (1+ (aref v i))))
		v)
	;; => [2 3 4 5]

	Sometimes you don't want to modify the original vector, you can make a copy

	(let* ((v0 (vector 1 2 3 4))
				 (v (copy-sequence v0)))
		(dotimes (i (length v))
			(aset v i (1+ (aref v i))))
		(list v0 v))
	;; => ([1 2 3 4] [2 3 4 5])

	or create a new vector from scratch

	(let* ((v0 (vector 1 2 3 4))
				 (v (make-vector (length v0) nil)))
		(dotimes (i (length v))
			(aset v i (1+ (aref v0 i))))
		(list v0 v))
	;; => ([1 2 3 4] [2 3 4 5])
	[[https://emacs.stackexchange.com/a/45946][share]]
** Comparison : 
*** 4.5 Comparison of Characters and Strings
**** Function: char-equal character1 character2

		 This function returns t if the arguments represent the same character, nil otherwise. This function ignores differences in case if case-fold-search is non-nil.

		 (char-equal ?x ?x)
					=> t
		 (let ((case-fold-search nil))
			 (char-equal ?x ?X))
					=> nil
**** Function: string= string1 string2

		 This function returns t if the characters of the two strings match exactly. Symbols are also allowed as arguments, in which case the symbol names are used. Case is always significant, regardless of case-fold-search.

		 This function is equivalent to equal for comparing two strings (see Equality Predicates). In particular, the text properties of the two strings are ignored; use equal-including-properties if you need to distinguish between strings that differ only in their text properties. However, unlike equal, if either argument is not a string or symbol, string= signals an error.

		 (string= "abc" "abc")
					=> t
		 (string= "abc" "ABC")
					=> nil
		 (string= "ab" "ABC")
					=> nil

		 For technical reasons, a unibyte and a multibyte string are equal if and only if they contain the same sequence of character codes and all these codes are either in the range 0 through 127 (ASCII) or 160 through 255 (eight-bit-graphic). However, when a unibyte string is converted to a multibyte string, all characters with codes in the range 160 through 255 are converted to characters with higher codes, whereas ASCII characters remain unchanged. Thus, a unibyte string and its conversion to multibyte are only equal if the string is all ASCII. Character codes 160 through 255 are not entirely proper in multibyte text, even though they can occur. As a consequence, the situation where a unibyte and a multibyte string are equal without both being all ASCII is a technical oddity that very few Emacs Lisp programmers ever get confronted with. See Text Representations. 
**** Function: string-equal string1 string2
		 string-equal is another name for string=. 

 Function: string-collate-equalp string1 string2 &optional locale ignore-case

		 This function returns t if string1 and string2 are equal with respect to collation rules. A collation rule is not only determined by the lexicographic order of the characters contained in string1 and string2, but also further rules about relations between these characters. Usually, it is defined by the locale environment Emacs is running with.

		 For example, characters with different coding points but the same meaning might be considered as equal, like different grave accent Unicode characters:

		 (string-collate-equalp (string ?\uFF40) (string ?\u1FEF))
					=> t

		 The optional argument locale, a string, overrides the setting of your current locale identifier for collation. The value is system dependent; a locale "en_US.UTF-8" is applicable on POSIX systems, while it would be, e.g., "enu_USA.1252" on MS-Windows systems.

		 If ignore-case is non-nil, characters are converted to lower-case before comparing them.

		 To emulate Unicode-compliant collation on MS-Windows systems, bind w32-collate-ignore-punctuation to a non-nil value, since the codeset part of the locale cannot be "UTF-8" on MS-Windows.

		 If your system does not support a locale environment, this function behaves like string-equal.

		 Do not use this function to compare file names for equality, as filesystems generally don’t honor linguistic equivalence of strings that collation implements. 
**** Function: string< string1 string2
		 This function compares two strings a character at a time. It scans both the strings at the same time to find the first pair of corresponding characters that do not match. If the lesser character of these two is the character from string1, then string1 is less, and this function returns t. If the lesser character is the one from string2, then string1 is greater, and this function returns nil. If the two strings match entirely, the value is nil.

		 Pairs of characters are compared according to their character codes. Keep in mind that lower case letters have higher numeric values in the ASCII character set than their upper case counterparts; digits and many punctuation characters have a lower numeric value than upper case letters. An ASCII character is less than any non-ASCII character; a unibyte non-ASCII character is always less than any multibyte non-ASCII character (see Text Representations).

		 (string< "abc" "abd")
					=> t
		 (string< "abd" "abc")
					=> nil
		 (string< "123" "abc")
					=> t

		 When the strings have different lengths, and they match up to the length of string1, then the result is t. If they match up to the length of string2, the result is nil. A string of no characters is less than any other string.

		 (string< "" "abc")
					=> t
		 (string< "ab" "abc")
					=> t
		 (string< "abc" "")
					=> nil
		 (string< "abc" "ab")
					=> nil
		 (string< "" "")
					=> nil

		 Symbols are also allowed as arguments, in which case their print names are compared. 
**** Function: string-lessp string1 string2

		 string-lessp is another name for string<. 
**** Function: string-greaterp string1 string2

		 This function returns the result of comparing string1 and string2 in the opposite order, i.e., it is equivalent to calling (string-lessp string2 string1). 
**** Function: string-collate-lessp string1 string2 &optional locale ignore-case

		 This function returns t if string1 is less than string2 in collation order. A collation order is not only determined by the lexicographic order of the characters contained in string1 and string2, but also further rules about relations between these characters. Usually, it is defined by the locale environment Emacs is running with.

		 For example, punctuation and whitespace characters might be ignored for sorting (see Sequence Functions):

		 (sort (list "11" "12" "1 1" "1 2" "1.1" "1.2") 'string-collate-lessp)
					=> ("11" "1 1" "1.1" "12" "1 2" "1.2")

		 This behavior is system-dependent; e.g., punctuation and whitespace are never ignored on Cygwin, regardless of locale.

		 The optional argument locale, a string, overrides the setting of your current locale identifier for collation. The value is system dependent; a locale "en_US.UTF-8" is applicable on POSIX systems, while it would be, e.g., "enu_USA.1252" on MS-Windows systems. The locale value of "POSIX" or "C" lets string-collate-lessp behave like string-lessp:

		 (sort (list "11" "12" "1 1" "1 2" "1.1" "1.2")
					 (lambda (s1 s2) (string-collate-lessp s1 s2 "POSIX")))
					=> ("1 1" "1 2" "1.1" "1.2" "11" "12")

		 If ignore-case is non-nil, characters are converted to lower-case before comparing them.

		 To emulate Unicode-compliant collation on MS-Windows systems, bind w32-collate-ignore-punctuation to a non-nil value, since the codeset part of the locale cannot be "UTF-8" on MS-Windows.

		 If your system does not support a locale environment, this function behaves like string-lessp. 
**** Function: string-version-lessp string1 string2

		 This function compares strings lexicographically, except it treats sequences of numerical characters as if they comprised a base-ten number, and then compares the numbers. So ‘foo2.png’ is “smaller” than ‘foo12.png’ according to this predicate, even if ‘12’ is lexicographically “smaller” than ‘2’. 
**** Function: string-prefix-p string1 string2 &optional ignore-case

		 This function returns non-nil if string1 is a prefix of string2; i.e., if string2 starts with string1. If the optional argument ignore-case is non-nil, the comparison ignores case differences. 
**** Function: string-suffix-p suffix string &optional ignore-case

		 This function returns non-nil if suffix is a suffix of string; i.e., if string ends with suffix. If the optional argument ignore-case is non-nil, the comparison ignores case differences. 
**** Function: compare-strings string1 start1 end1 string2 start2 end2 &optional ignore-case

		 This function compares a specified part of string1 with a specified part of string2. The specified part of string1 runs from index start1 (inclusive) up to index end1 (exclusive); nil for start1 means the start of the string, while nil for end1 means the length of the string. Likewise, the specified part of string2 runs from index start2 up to index end2.

		 The strings are compared by the numeric values of their characters. For instance, str1 is considered less than str2 if its first differing character has a smaller numeric value. If ignore-case is non-nil, characters are converted to upper-case before comparing them. Unibyte strings are converted to multibyte for comparison (see Text Representations), so that a unibyte string and its conversion to multibyte are always regarded as equal.

		 If the specified portions of the two strings match, the value is t. Otherwise, the value is an integer which indicates how many leading characters agree, and which string is less. Its absolute value is one plus the number of characters that agree at the beginning of the two strings. The sign is negative if string1 (or its specified portion) is less. 
**** Function: string-distance string1 string2 &optional bytecompare

		 This function returns the Levenshtein distance between the source string string1 and the target string string2. The Levenshtein distance is the number of single-character changes—deletions, insertions, or replacements—required to transform the source string into the target string; it is one possible definition of the edit distance between strings.

		 Letter-case of the strings is significant for the computed distance, but their text properties are ignored. If the optional argument bytecompare is non-nil, the function calculates the distance in terms of bytes instead of characters. The byte-wise comparison uses the internal Emacs representation of characters, so it will produce inaccurate results for multibyte strings that include raw bytes (see Text Representations); make the strings unibyte by encoding them (see Explicit Encoding) if you need accurate results with raw bytes. 
**** Function: assoc-string key alist &optional case-fold
		 This function works like assoc, except that key must be a string or symbol, and comparison is done using compare-strings. Symbols are converted to strings before testing. If case-fold is non-nil, key and the elements of alist are converted to upper-case before comparison. Unlike assoc, this function can also match elements of the alist that are strings or symbols rather than conses. In particular, alist can be a list of strings or symbols rather than an actual alist. See Association Lists. 

 See also the function compare-buffer-substrings in Comparing Text, for a way to compare text in buffers. The function string-match, which matches a regular expression against a string, can be used for a kind of string comparison; see Regexp Search. 
*** check whether minor modes is enabled : 
Most minor modes are defined using the define-minor-mode macro. For buffer-local modes, that macro creates a buffer-local variable of the same name as the mode itself1. The variable is non-nil when the mode is enabled for the current buffer.
Therefore to check whether flymake-mode is enabled, you can test the variable flymake-mode (noting that this variable might not be defined at all if the mode has not been enabled):

(and (boundp 'flymake-mode) flymake-mode)

Which, as Thom point out in the comments, can be expressed using the convenient macro:

(bound-and-true-p flymake-mode)

Which we can use as the condition for an if or when or unless expression:

(if (bound-and-true-p flymake-mode)
    (message "flymake-mode is on")
  (message "flymake-mode is off"))

** Text 
*** By Xah Lee : 
**** Elisp: Text Properties
 Elisp: Text Properties
 By Xah Lee. Date: 2017-06-17. Last updated: 2020-09-04.

 Text in a buffer can have “text properties”.

 Text properties is used to color text, or add keybinding to that text (for example, pressing Enter on a link in HTML opens the link instead of insert newline.), and other purposes.

 Here's a command that makes a region red, by adding a text property of 'font-lock-face to it.

 (defun x-make-word-red (begin end)
	 "make current region colored red, using text properties"
	 (interactive (list (region-beginning) (region-end)))
	 (put-text-property begin end 'font-lock-face '(:foreground "red")))

 Select a region, then
 Alt+x
 x-make-word-red

 Here's example of adding a keymap to text, so that when Enter is pressed, it tries to open the file, taking current line as file name/path.

 (setq x-keymap (make-sparse-keymap))
 (define-key x-keymap (kbd "RET") (lambda () (find-file (thing-at-point 'filename) )))

 (defun x-add-prop (begin end)
	 "add text properties to a region."
	 (interactive "r")
		 (put-text-property begin end 'font-lock-face '(:foreground "blue"))
		 (put-text-property begin end 'keymap x-keymap))


 try it:


 Open a new file, insert some text that contains file path.
 Go to a line that's a file path, select it, then Alt+x x-add-prop. The region will be colored blue, and pressing Enter key on it will call x-open-me


 What's Text Property

 Text Property is a property list attached to text.

 A property list is a list but interpreted as key and value pairs. Like this:

 '(key1 val1 key2 val2 …)

 [see Elisp: Property List]

 When a property list is attached to text, some keys have special meaning that are predefined by emacs.

 Here are some of the most useful property keys for writing a major/minor mode:


 'font-lock-face -> for syntax coloring. Value is a face. [see Elisp: How to Define Face]
 'face -> for syntax coloring. Value is a face. It overrides the 'font-lock-face property. This property is automatically updated/managed by font-lock-mode. [see Elisp: Font Lock Mode Basics]
 'syntax-table -> add syntax table to text. Value is a syntax table. This is useful for example, in a major mode for programing language, you want to make regex delimiter character such as SOLIDUS / to have string syntax, so regex string are colored as string. [see Elisp: Syntax Table]
 'keymap -> Add keybinding to text. Value is a keymap. When cursor is on the text, the keymap has priority in determining keystroke action. [see Elisp: How to Create Keymap for Major Mode]


 For a complete list, see
 (info "(elisp) Special Properties")

 Functions for Working with Text Property

 There are many functions to get values of text properties, add/change/delete them, or find out where a property begins, etc.
 See


 (info "(elisp) Text Properties")
*** [[https://stackoverflow.com/questions/2419225/printing-colored-characters-in-lisp-emacs][Printing Colored Characters in Lisp / Emacs]]
**** use a graphical toolkit : 
 what Lisp? Emacs Lisp? The 'HyperSpec' is not for Emacs Lisp, but Common
 Lisp. Printing colored text from Emacs Lisp should be covered in the Emacs
 manual. Common Lisp has no built-in facilities for colored text, because the user
 interface is outside the scope of the Common Lisp standard. Typically one would
 use a graphical toolkit (like CAPI, CLIM, ...) or something like a 'curses' interface. If
 you are using Emacs Lisp, then you can use Emacs built-in functionality. I guess you
 could also look at some of the games that are coming with Emacs for inspiration. –
 [[https://stackoverflow.com/users/69545/rainer-joswig][Rainer Joswig]] Mar 10 '10 at 17:57 SVG Image 
**** ,* It is possible that [[http://en.wikipedia.org/wiki/ANSI_escape_code][en.wikipedia.org/wiki/ANSI_escape_code]] is the simple solution
 you are looking for, depending on what you mean by "Lisp" as Rainer commented. –
 [[https://stackoverflow.com/users/139746/pascal-cuoq][Pascal Cuoq]] Mar 10 '10 at 18:04 SVG Image 
****  ,* I'm using SBCL which is one of the many flavors of CL, although it's running on
 SLIME in emacs. This should be covered by the emacs manual though, right?
 Thanks for the input, my world of lisp broadens daily. – [[https://stackoverflow.com/users/290763/limpoch][Limpoch]] Mar 10 '10 at 18:29
,* You have two very different choices: you can write the game in SBCL, in which case
 you'll need a Common Lisp user interface library, or you can write it in Emacs Lisp
 and use Emacs' built-in functionality. SLIME is what you use to edit Common Lisp
 code in emacs - like a text editor but with many more features. Your Lisp code is
 not running in Emacs. If you want code to run in Emacs (and use Emacs' built-in
 color text ability), it'll have to be Emacs Lisp. You'll need to decide which way you
 want to do things before you can solve this problem. – [[https://stackoverflow.com/users/446918/noah-lavine][Noah Lavine]] Mar 10 '10 at
 22:17 
,* did you find the solution you were looking for? – [[https://stackoverflow.com/users/3758484/johnbakers][johnbakers]] Nov 30 '13 at 15:08 
**** propertize : 
The appearance of text in Emacs is controlled by faces. Face can be changed through
either overlay or text properties. Here is an example using the latter:


;; Emacs-Lisp
(insert (propertize "foo" 'font-lock-face '(:foreground "red")))

However, if the game is implemented in SBCL, you'll need a way to communicate with
Emacs from your SBCL program. As it seems that you're using Slime, using Swank,
which is a part of Slime, might be the most convenient:


;; Common-Lisp
(swank::eval-in-emacs
 '(with-current-buffer (slime-repl-buffer)
    (insert (propertize "foo" 'font-lock-face '(:foreground "red")))))
[[https://stackoverflow.com/a/2421008][share]] | Submit | 
answered Mar 10 '10 at 22:10 
[[https://stackoverflow.com/users/16240/huaiyuan][*]][[https://stackoverflow.com/users/16240/huaiyuan][huaiyuan]]huaiyuan 
24.7k55 gold badges5252 silver badges6161 bronze badges 

**** self plug : 
Shameless self plug: you might want to try [[http://www.martin-loetzsch.de/gtfl/][this]], which is a graphical terminal for
Common Lisp running in a web browser. It uses html for printing stuff, so you could do
something like:

(gtfl-out (:p :style "color:red;" "some characters"))
****  wrote an Elisp defun : 
I just wrote an Elisp defun to test the colors. It could be useful for example when setting
up the general colors of the Linux VTs. Note that the color list ("black", "red", etc.) is
only how it is conventionally and usually defined - if you set them up as other colors,
perhaps red won't be red anymore. Still, it can be useful to test.

;;;; insert colored and/or bright text
(defun insert-colored-text (str clr bright)
  "Inserts str at point, in color clr, bright or not."
  (interactive (list (read-string " String: ")
										 (read-string " Color: ")
										 (y-or-n-p    " Bright? ") ))
  (insert (propertize str 'font-lock-face
          `(:weight ,(if bright 'bold 'normal) :foreground ,clr) )))
(defalias 'ict 'insert-colored-text)

(defun test-all-faces ()
  "Prints a test string in al colors, both normal and bright."
  (interactive)
  (let ((str "This is what it looks like"))
    (dolist (bold '(nil t) nil)
      (dolist (color
							 '("black" "red" "green" "yellow" "blue"
								 "magenta" "cyan" "white") nil)
        (insert-colored-text
				 (format "%s in %s (that is %sbold)\n" str color
								 (if bold "" "not ")) color bold) ))))
(defalias 'taf 'test-all-faces)

[[http://user.it.uu.se/~embe8573/cols.png][example output http://user.it.uu.se/~embe8573/cols.png]]


**** [[https://stackoverflow.com/questions/19208933/change-the-color-of-the-text-in-the-common-lisp-repl\]][Change the color of the text in the Common Lisp REPL]] : 
I am looking for the same answer and been here, and after a while found the answer
from another link[[[https://stackoverflow.com/questions/19208933/change-the-color-of-the-text-in-the-common-lisp-repl\]][Change the color of the text in the Common Lisp REPL]].

I think maybe you need it,the answer is:

 Blockquote
**** ANSI escape code : 
You can use ANSI escape code to print colorful texts:

(format t "~c[31mabc~c[0m~%" #\ESC #\ESC) ; this prints a red "abc" for most
modern terminals I'm not sure whether this works in slime, although.

shareimprove this answer answered Oct 6 '13 at 16:06

SaltyEgg 626412


**** #\ESC is not in the standard : 
,* Thank You This post lead me to a deeper understanding of how the format function
 works! Do you know where the #\ESC function is documented? – [[https://stackoverflow.com/users/2962623/rmoro][rmoro]] Oct 9 '16
 at 6:14 
,* #\ESC is not in the standard, a more portable expression might be (format t "~c
 [31mRed~:*~c[32mGreen~:*~c[34mBlue~:*~c[mPlain~%" (code-char 27)) – [[https://stackoverflow.com/users/3008405/devon][devon]]
 Jul 12 at 15:20 
*** face : 
(insert (propertize "bar" 'face '(:foreground "red")))
**** :background "gray30" : 
 (insert (propertize "bar" 'face '(:background "gray30")))
**** :foreground "#33AAFF" : 
 (insert (propertize "bar" 'face '(:foreground "#33AAFF")))
**** background : 
 (insert (propertize "bar" 'face '(:foreground "orange" :background "purple")))
** show maseges
*** message
(message "Load of init.el is ended")
показывает сообшение прям из проверки
(if nil "yes" "no")
*** format
	 (format "sdfsdf")
*** (defun min-to-houre (min)
(defun min-to-houre (min)
		(setq min (+ min 10))
		 (message "value is %s" min))
** Input 
*** read : 
	 (read)

** return 
*** How do you return from a function at an arbitrary point?
**** How do you return early from a function before it's ended? For example:

 (defun my-func () 
	"for example."
	(unless something (return nil))
	; continue as usual...
	(+ 42 1))
 elisp
 functions
 share  improve this question   follow  
 edited Feb 1 '15 at 1:03
 asked Jan 31 '15 at 2:53

 ocodo
 81266 silver badges1717 bronze badges
 add a comment
 2 Answers
 
 19
****  We have a number of options available.
***** Throw
	 You can catch / throw to exit the function.

	 example:

	 (defun my-func ()
		 "thrown error"
		 (catch 'my-catch
			 (when t
				 (throw 'my-catch "always going to throw"))
			 (+ 42 1)))
***** Block
		You can also use block and return-from (although you will need to require cl-macs)

		example:

		(require 'cl-macs)

		(defun my-func ()
			"block / return-from"
			(block my-func
				(when t
					(return-from my-func))
				(+ 42 1)))
***** cl-defun
		We also have cl-defun which has an implicit block with the same name as the function, so we can do the block style with less.

		example:

		(require 'cl-macs)

		(cl-defun my-func ()
			"cl-defun implicit block"
			(when t
				(return-from my-func)) ; my-func is an implicit block.
			(+ 42 1)))
***** defun*
		cl-defun is also available as an alias defun* which is defined in cl.el so:

		(require 'cl)

		(defun* my-func ()
			"defun* implicit block"
			(when t
				(return-from my-func)) ; my-func is an implicit block.
			(+ 42 1)))
		share  improve this answer   follow  
		edited Jan 31 '15 at 3:23
		answered Jan 31 '15 at 3:07
***** 	ocodo
		81266 silver badges1717 bronze badges
		4
		Note that if you don't have a preference for the CL syntax, catch/throw is more idiomatic in elisp, as other approaches are ultimately implemented in terms of catch/throw. The elisp manual says: "Most other versions of Lisp, including Common Lisp, have several ways of transferring control nonsequentially: return, return-from, and go, for example. Emacs Lisp has only throw." – phils Jan 31 '15 at 5:28
***** 		In addition to what @EmacsFodder covered, just raise an error.

		This will not help if the code is called within (dynamically, not lexically) the extent of error-handling constructs such as ignore-errors or condition-case, but otherwise it is a fine way to exit a function. It is in fact what is done most of the time.

		(defun my-func () 
		 "..."
		 (unless something (error "Whoops!"))
		 ; continue as usual...
		 (+ 42 1))
		If you want to handle the error yourself then you can put the calling code (e.g. the call to something that ulimately calls my-func) inside a condition-case. Again, this is what is done most of the time, at least as often as using catch + throw. It all depends on what behavior you want.

		share  improve this answer   follow  
		edited May 9 '15 at 20:26
		answered Jan 31 '15 at 18:48
**** 	Drew
		59.3k55 gold badges8080 silver badges152152 bronze badges
		Thanks for the answer Drew, I agree this is quite a common method. However, just doing an early return in a lot of other languages, doesn't incur the complexity of having to then deal with an error. When researching the question/answer set. I was specifically looking for alternatives to the "erroring out" style which always feels kludgy to me. I didn't specify this explicitly in the question text mind you. – ocodo Feb 1 '15 at 1:00 
***** 	1
		 It all depends on what you want to do. If you want to end immediately, with no further processing/handling, then raising an error is a good way to go for a nonlocal exit, in Emacs. If you want to do something during a nonlocal exit, i.e., handle it in some way, then catch, unwind-protect, condition-case and the like are useful. There is a whole section of the Elisp manual devoted to nonlocal exits. (And there is nothing particularly kludgy about any of them, IMO.) – Drew Feb 1 '15 at 2:54 
		 "Feels" is entirely subjective of course. Thanks for the nonlocal manual ref. – ocodo Feb 1 '15 at 2:56
		 add a comment
		 Your Answer
** compile
Emacs 24.3 or below

There's no built-in way of preventing these old files from being loaded, but there are easy ways to get rid of them.

***    You can recompile the entire elpa directory by calling:
   M-x byte-recompile-directory RET ~/.emacs.d/elpa/.
   This should get rid of outdated files.
***    You can use the auto-compile package
and activate auto-compile-on-load-mode which can compile files before they are loaded.

Emacs 24.4

Yes, and it turns out to be rather simple. The
***    load-prefer-newer
variable serves precisely this purpose.

(setq load-prefer-newer t)

Unfortunately, it won't work when some code specifically targets the .elc file, such as (load "server.elc"). But it should be enough as long as you're using requires or calling load without a suffix, which you should.

From the doc:

    load-prefer-newer is a variable defined in lread.c.
    Its value is nil

    Documentation:
    Non-nil means load prefers the newest version of a file.
    This applies when a filename suffix is not explicitly specified and load is trying various possible suffixes (see load-suffixes and load-file-rep-suffixes). Normally, it stops at the first file that exists unless you explicitly specify one or the other. If this option is non-nil, it checks all suffixes and uses whichever file is newest.
    Note that if you customize this, obviously it will not affect files that are loaded before your customizations are read!
** interactive
*** (interactive (list (region-beginning) (region-end))) : 
 Text in a buffer can have “text properties”.

 Text properties is used to color text, or add keybinding to that text (for example, pressing Enter on a link in HTML opens the link instead of insert newline.), and other purposes.

 Here's a command that makes a region red, by adding a text property of 'font-lock-face to it.

 (defun x-make-word-red (begin end)
   "make current region colored red, using text properties"
   (interactive (list (region-beginning) (region-end)))
   (put-text-property begin end 'font-lock-face '(:foreground "red")))

 Select a region, then Alt+x x-make-word-red

*** (interactive "r") : 
 Here's example of adding a keymap to text, so that when Enter is pressed, it tries to open the file, taking current line as file name/path.

 (setq x-keymap (make-sparse-keymap))
 (define-key x-keymap (kbd "RET") (lambda () (find-file (thing-at-point 'filename) )))

 (defun x-add-prop (begin end)
   "add text properties to a region."
   (interactive "r")
     (put-text-property begin end 'font-lock-face '(:foreground "blue"))
     (put-text-property begin end 'keymap x-keymap))

 try it:

     Open a new file, insert some text that contains file path.
     Go to a line that's a file path, select it, then Alt+x x-add-prop. The region will be colored blue, and pressing Enter key on it will call x-open-me
** Docs
*** Pdfs
**** Land of lisp
https://drive.google.com/file/d/10mKcsFB0pDeLRM15T6QlmG4Rn979rBDl/view?usp=sharing
*** Cheat sheet 
**** from 

 https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html

	43
	3.0
	"foo!"
**** ;; FUNCTIONS
	(+ 1 2 3 4 5)
**** ;; LISt Processing Language
		 #+begin_src emacs-lisp :tangle yes
	 (1 2 3)

	 `(1 2 3)

	 (list 1 2 3 4 5)

	 ;; "car" -- returns the first element of the list

	 (car
		(list 1 2 3))

	 ;; "cdr" -- returns the entire list except the first element

	 (cdr
		`(1 2 3 4 5))

	 ;; "cons" -- construct a list

	 (cons 1 `(2 3))

	 ;; "append" -- takes two lists and joins them together

	 (append `(1 2) `(3 4))
		 #+end_src
**** ;; VARIABLES
		 #+begin_src emacs-lisp :tangle yes
	 (setq my-list `(mac linux))

	 ;; TODO: READ ABOUT MACROS IN ELISP
	 ;; local variables
	 (let ((a 1)
				 (b 3))
		 (- a b))

		 #+end_src
**** ;; FUNCTIONS
		 #+begin_src emacs-lisp :tangle yes
	 (defun main ()
		 "A docstring that tells a little bit about my function"
		 "Hello!")

	 (main)

	 (defun square (x)
		 (* x x))

	 (square 2)

		 #+end_src
**** ;; CONDITIONALS
		 #+begin_src emacs-lisp :tangle yes
	 ;; every value is truthy except nil and the empty list ()

	 ;; and

	 (and t nil)

	 (and 1 13)

	 ;; or

	 (or t nil)

	 (or nil `())

	 ;; not

	 (not nil)

	 ;; don't try to be very clever and try to write code
	 ;; based on those return values that these functions give
	 ;; unless you wanna dab on the haters

	 ;; when -- only take an action if a predicate is true

	 (when (= (+ 2 2) 4)
		 "passed check")

	 ;; if, else -- good ol' if else

	 (defun even-or-odd (n)
		 (if (= (% n 2) 0)
				 "even"
			 "odd"))

	 (even-or-odd 2)
	 (even-or-odd 54)
	 (even-or-odd 32343)

	 ;; cond - much like a switch, i think
	 ;; takes in a "collection" of lists. Remember that.
	 ;; like "let"

	 (defun pick-sword (n)
		 (cond
			((= n 0) "Wood")
			((= n 1) "Plastic")
			((= n 2) "Gold")))

	 (pick-sword 2)


		 #+end_src
**** ;; anonymous functions -- lambdas!
		 #+begin_src emacs-lisp :tangle yes
	 ;; lambdas are function literals

	 (lambda (x) (+ x 5))

	 ;; call it 

	 ((lambda (x) (+ x 5)) 9)

	 ;; funcall -- calls a function

	 (funcall (lambda (x) (* x x)) 4)

	 (funcall '+ 1 2)

	 ;; store the lambda in a variable

	 (fset `square (lambda (x) (* x x)))

	 (square 3)

		 #+end_src
**** ;; HIGHER ORDER FUNCTIONS
		 #+begin_src emacs-lisp :tangle yes
	 (defun transform-until-zero (fn n)
		 "transforms n with the function given unless the number is 0"
		 (if (= n 0)
				 0
			 (funcall fn n)))

	 (transform-until-zero (lambda (n) (* n 2)) 0)

	 (transform-until-zero (lambda (n) (* n 2)) 3)

	 ;; a very important higher order function is mapcar
	 ;; takes in a list and a function and applies the function
	 ;; to every element in the list. NOW we're talking

		 #+end_src
**** ;; much like map in JS
	 #+begin_src emacs-lisp :tangle yes
	 (mapcar (lambda(n) (+ n 1)) '(1 2 3))

	 ;; non destructive!

	 (setq my-list '(1 2 3))
	 (mapcar (lambda (n) (+ n 1)) my-list)

	 #+end_src
*** Cool guid
 https://github.com/chrisdone/elisp-guide
* Help Docs Org
** Welcome to Org mode
*** Marker sibols  
 You can make words 
 *bold*, /italic/, _underlined_, =code= and ~verbatim sdfsdfs~, 
 and, if you must, +strike-through+.
*** Lord of the Rings
    My favorite scenes are (in this order)
    1. Eowyn's fight with the witch king
       + this was already my favorite scene in the book
       + I really like Miranda Otto.
    2. The attack of the Rohirrim
    3. Peter Jackson being shot by Legolas
       - on DVD only
       He makes a really funny face when it happens.
    But in the end, no individual scenes matter but the film as a whole.
    Important actors in this film are:
    - Elijah Wood :: He plays Frodo
    - Sean Austin :: He plays Sam, Frodo's friend.  I still remember
      him very well from his role as Mikey Walsh in The Goonies.
** Help
	[[info:org#Tables][info:org]] 
*** info\manual
    Check out the info manual for Org Mode with C-h i (info) to learn more, including how to customize the number of days initially displayed and what day your week starts on. 
    удобная систе показиваюшая мануалки по всем установленым модам
*** links
**** Org Mode - Organize Your Life In Plain Text!
     http://doc.norang.ca/org-mode.html   
     очень последовательнвый манул по всему оргу с кучей примеров
*** мануал пдф
 [[https://orgmode.org/org.pdf][Link to 304p doc about org]]
** Notes 
*** Exempls
  - Note taken on [2018-10-29 Пн 20:19] \\
    ladfdfd
    fdf
    df
    df
    ts add anoser note
    - sdfsdf sdf sdf sdfsd \\
    sdfsdfsdf
    sdfsdf sd fsd fd
    - some note?
	Intrasting where it puting this
    - d
    - sdf
    - sdfsdfsf
    - [X] 
    - [X] sdf
    - 
    - sdfsdfs sdf sdf sd[fn:1] 
    - 
*** Footnotes

[fn:1] The footnote.

[fn:2] Second footnote.
[fn:1] I not undestend ecthakli how this must work
** Agenda
*** exempl
**** aaronbieber
https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html

(defun air-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))
			
(defun air-org-skip-subtree-if-habit ()
  "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (string= (org-entry-get nil "STYLE") "habit")
        subtree-end
      nil)))


(setq org-agenda-custom-commands
      '(("d" "Daily agenda and all TODOs"
         ((tags "PRIORITY=\"A\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "High-priority unfinished tasks:")))
          (agenda "" ((org-agenda-ndays 1)))
          (alltodo ""
                   ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                   (air-org-skip-subtree-if-priority ?A)
                                                   (org-agenda-skip-if nil '(scheduled deadline))))
                    (org-agenda-overriding-header "ALL normal priority tasks:"))))
         ((org-agenda-compact-blocks t)))))

** Help keys
*** Visibility cycling
Tab – show current
S-tab – show all children
C-u C-u C-u Tab – show all including drawers Startup options
Editting
M-Ret – add element on the same level
M-S-Ret – insert TODO element
M-Right – demote current element
M-S-Right – deomote current subtree
M-Left – promote current element
M-S-Left – promote current subtree
M-S-Up – move current tree up
M-S-Down – move current tree down
C-c C-x C-w – kill current subtree
C-c C-x M-w – copy current subtree
C-c C-x C-y – yank subtree
C-x n s     (org-narrow-to-subtree)
    Narrow buffer to current subtree.
C-x n b     (org-narrow-to-block)
    Narrow buffer to current block.
C-x n w     (widen)
    Widen buffer to remove narrowing.
C-c *     (org-toggle-heading)
    Turn a normal line or plain list item into a headline (so that it becomes a subheading at its location). Also turn a headline into a normal line by removing the stars. If there is an active region, turn all lines in the region into headlines. If the first line in the region was an item, turn only the item lines into headlines. Finally, if the first line is a headline, remove the stars from all headlines in the region. 
‘C-c -’ Cycle the entire list level through the different itemize/enumerate bullets (‘-’, ‘+’, ‘*’, ‘1.’, ‘1)’) or a subset of them, depending
‘C-c C-c’ If there is a checkbox (*note Checkboxes::) in the item line, toggle the state of the checkbox.  In any case, verify bullets and indentation consistency in the whole list.
*** Plain lists
Use M-Ret to add list item
Ordered list:

    First
    Second
    Third

Unordered lists

    abc
    efg

List with checkboxes (M-S-Ret)

    [ ] First element
    [X] Second element (C-c C-c – toggle checkbox state)
    [X] Third element
*** ToDo functionalityt
C-c C-t – rotate TODO state
S-Left, S-Right – rotate TODO state
**** S-M-Ret – insert new TODO note
(setq org-todo-keywords’((sequence “TODO” “FEEDBACK” “VERIFY” “|” “DONE” “DELEGATED”)))
Footnotes
**** C-c / t     (org-show-todo-tree)

    View TODO items in a sparse tree (see Sparse trees). Folds the entire buffer, but shows all TODO items (with not-DONE state) and the headings hierarchy above them. With a prefix argument (or by using C-c / T), search for a specific TODO. You will be prompted for the keyword, and you can also give a list of keywords like KWD1|KWD2|... to list entries that match any one of these keywords. With a numeric prefix argument N, show the tree for the Nth keyword in the option org-todo-keywords. With two prefix arguments, find all TODO states, both un-done and done. 
**** C-c a t     (org-todo-list)

    Show the global TODO list. Collects the TODO items (with not-DONE states) from all agenda files (see Agenda views) into a single buffer. The new buffer will be in agenda-mode, which provides commands to examine and manipulate the TODO entries from the new buffer (see Agenda commands). See Global TODO list, for more information. 
*** unsort
More devices
C-c C-z – time-stamped drawer

    Note taken on [2013-09-02 Mon 23:54]
    My note here

[fn:2]
 C-c C-x f – footnote[fn:1]**
*** keys add agenda file
   C-c [     (org-agenda-file-to-front)

    Add current file to the list of agenda files. The file is added to the front of the list. If it was already in the list, it is moved to the front. With a prefix argument, file is added/moved to the end. 
C-c ]     (org-remove-file)

    Remove current file from the list of agenda files. 
*** drawers : 
**** insert drawers  : 
		   You can interactively insert drawers at point by calling
‘org-insert-drawer’, which is bound to ‘C-c C-x d’.  With an active
region, this command will put the region inside the drawer.  With a
prefix argument, this command calls ‘org-insert-property-drawer’ and add
a property drawer right below the current headline.  Completion over
drawer keywords is also possible using ‘M-<TAB>’(1).

   Visibility cycling (*note Visibility cycling::) on the headline will
hide and show the entry, but keep the drawer collapsed to a single line.
In order to look inside the drawer, you need to move the cursor to the
drawer line and press <TAB> there.  Org mode uses the ‘PROPERTIES’
drawer for storing properties (*note Properties and columns::), and you
can also arrange for state change notes (*note Tracking TODO state
changes::) and clock times (*note Clocking work time::) to be stored in
a drawer ‘LOGBOOK’.  If you want to store a quick note in the LOGBOOK
drawer, in a similar way to state changes, use

**** Add a time-stamped : 
‘C-c C-z’
     Add a time-stamped note to the LOGBOOK drawer.

   You can select the name of the drawers which should be exported with
‘org-export-with-drawers’.  In that case, drawer contents will appear in
export output.  Property drawers are not affected by this variable:
configure ‘org-export-with-properties’ instead.

** template expansion 
*** capture 
**** Template expansion %
10.1.3.2 Template expansion

In the template itself, special “%-escapes”86 allow dynamic insertion of content. The templates are expanded in the order given here:

‘%[FILE]’

    Insert the contents of the file given by FILE.
‘%(EXP)’

    Evaluate Elisp expression EXP and replace it with the result. The EXP form must return a string. Only placeholders pre-existing within the template, or introduced with ‘%[file]’, are expanded this way. Since this happens after expanding non-interactive “%-escapes”, those can be used to fill the expression.
‘%<FORMAT>’

    The result of format-time-string on the FORMAT specification.
‘%t’
    Timestamp, date only.
‘%T’

    Timestamp, with date and time.
‘%u’, ‘%U’

    Like ‘%t’, ‘%T’ above, but inactive timestamps.
‘%i’

    Initial content, the region when capture is called while the region is active. If there is text before ‘%i’ on the same line, such as indentation, and ‘%i’ is not inside a ‘%(exp)’ form, that prefix is added before every line in the inserted text.
‘%a’

    Annotation, normally the link created with org-store-link.
‘%A’

    Like ‘%a’, but prompt for the description part.
‘%l’

    Like ‘%a’, but only insert the literal link.
‘%c’

    Current kill ring head.
‘%x’

    Content of the X clipboard.
‘%k’

    Title of the currently clocked task.
‘%K’

    Link to the currently clocked task.
‘%n’

    User name (taken from user-full-name).
‘%f’

    File visited by current buffer when org-capture was called.
‘%F’

    Full path of the file or directory visited by current buffer.
‘%:keyword’

    Specific information for certain link types, see below.
‘%^g’

    Prompt for tags, with completion on tags in target file.
‘%^G’

    Prompt for tags, with completion all tags in all agenda files.
‘%^t’

    Like ‘%t’, but prompt for date. Similarly ‘%^T’, ‘%^u’, ‘%^U’. You may define a prompt like ‘%^{Birthday}t’.
‘%^C’

    Interactive selection of which kill or clip to use.
‘%^L’

    Like ‘%^C’, but insert as link.
‘%^{PROP}p’

    Prompt the user for a value for property PROP.
‘%^{PROMPT}’

    Prompt the user for a string and replace this sequence with it. You may specify a default value and a completion table with ‘%^{prompt|default|completion2|completion3...}’. The arrow keys access a prompt-specific history.
‘%\N’

    Insert the text entered at the Nth ‘%^{PROMPT}’, where N is a number, starting from 1.
‘%?’

    After completing the template, position point here. 

For specific link types, the following keywords are defined87:
Link type	Available keywords
bbdb	‘%:name’, ‘%:company’
irc	‘%:server’, ‘%:port’, ‘%:nick’
mh, rmail	‘%:type’, ‘%:subject’, ‘%:message-id’
	‘%:from’, ‘%:fromname’, ‘%:fromaddress’
	‘%:to’, ‘%:toname’, ‘%:toaddress’
	‘%:date’ (message date header field)
	‘%:date-timestamp’ (date as active timestamp)
	‘%:date-timestamp-inactive’ (date as inactive timestamp)
	‘%:fromto’ (either “to NAME” or “from NAME”)88
gnus	‘%:group’, for messages also all email fields
w3, w3m	‘%:url’
info	‘%:file’, ‘%:node’
calendar	‘%:date’
org-protocol	‘%:link’, ‘%:description’, ‘%:annotation’
Footnotes
(86)

If you need one of these sequences literally, escape the ‘%’ with a backslash.
(87)

If you define your own link types (see Adding Hyperlink Types), any property you store with org-store-link-props can be accessed in capture templates in a similar way.
(88)
*** structural 
**** list
With just a few keystrokes, it is possible to insert empty structural blocks, such as ‘#+BEGIN_SRC’ … ‘#+END_SRC’, or to wrap existing text in such a block.

C-c C-, (org-insert-structure-template)

    Prompt for a type of block structure, and insert the block at point. If the region is active, it is wrapped in the block. First prompts the user for keys, which are used to look up a structure type from the variable below. If the key is TAB, RET, or SPC, the user is prompted to enter a block type. 

Available structure types are defined in org-structure-template-alist, see the docstring for adding or changing values.

Org Tempo expands snippets to structures defined in org-structure-template-alist and org-tempo-keywords-alist. For example, < s TAB creates a code block. Enable it by customizing org-modules or add ‘(require 'org-tempo)’ to your Emacs init file146.
a	‘#+BEGIN_EXPORT ascii’ … ‘#+END_EXPORT’
c	‘#+BEGIN_CENTER’ … ‘#+END_CENTER’
C	‘#+BEGIN_COMMENT’ … ‘#+END_COMMENT’
e	‘#+BEGIN_EXAMPLE’ … ‘#+END_EXAMPLE’
E	‘#+BEGIN_EXPORT’ … ‘#+END_EXPORT’
h	‘#+BEGIN_EXPORT html’ … ‘#+END_EXPORT’
l	‘#+BEGIN_EXPORT latex’ … ‘#+END_EXPORT’
q	‘#+BEGIN_QUOTE’ … ‘#+END_QUOTE’
s	‘#+BEGIN_SRC’ … ‘#+END_SRC’
v	‘#+BEGIN_VERSE’ … ‘#+END_VERSE’
Footnotes
(146)

For more information, please refer to the commentary section in ‘org-tempo.el’.
**** exempl
	 <s
	 #+BEGIN_SRC 
(setq org-structure-template-alist
      '(("s" "#+BEGIN_SRC ?\n\n#+END_SRC\n")
       ("e" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE\n")
       ("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE\n")
       ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE\n")
       ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM\n")))
	 #+END_SRC
in new versin 2.0
(add-to-list 'org-structure-template-alist '("t" . "src translate"))
old
(add-to-list 'org-structure-template-alist '("t" "#+BEGIN_SRC ? translate\n\n#+END_SRC\n"))
<t
	 #+BEGIN_SRC  translate
	Ты работаешь? 
	 #+END_SRC

	 #+RESULTS:
	 : Do you work?

(add-to-list 'org-structure-template-alist '("tr" "#+BEGIN_SRC ? translate :dest ru\n\n#+END_SRC\n"))
	 #+BEGIN_SRC  translate :dest ru
 Do you work?
	 #+END_SRC

	 #+RESULTS:
	 : Вы работаете?
	 
	 
** Tabels
	[[info:org#Tables][info:org#Tables]] 
*** links 
https://orgmode.org/org.html#Advanced-features
*** exempl
**** Tmp 
 
 |---+---------+---------------+------+---|
 |   | sidfsdf | dfsdf  sfdfsf | sdf  |   |
 |   | sdf     | sdfsdf        | sdf  |   |
 |   |         |               | sdfs |   |
 |---+---------+---------------+------+---|
 |   |         |               |      |   |
 |---+---------+---------------+------+---|
 #+name: FOO
 |---+---+---+---+---+---+---+---+----|
 | 1 | 0 | 1 | 1 | 2 | 3 | 4 | 5 | 15 |
 | 3 | 5 | 3 | 3 | 3 | 4 | 5 | 6 | 16 |
 | 5 | 4 | 5 | 5 | 4 | 5 | 6 | 7 | 17 |
 | 9 | 9 | 7 | 7 |   |   |   |   | 18 |
 |---+---+---+---+---+---+---+---+----|
 | 0 | 0 | 0 |   |   |   |   |   |  1 |
 |---+---+---+---+---+---+---+---+----|
 #+TBLFM: $1=$2 * 10 ::$2=$+3
 #+TBLFM: $2=$+3

 #+CONSTANTS: c=10 pi=3.14 eps=2.4e-6
 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |  8 |        9 |
 |---+---+---+---+---+---+---+----+----------|
 | 1 | 3 | 1 | 1 | 2 | 3 | 4 |  5 | 00:02:00 |
 | 3 | 5 | 3 | 3 | 3 | 4 | 5 |  6 | 00:03:00 |
 | 2 | 9 | 2 | 2 | 4 | 6 | 8 | 10 | 00:04:00 |
 | 7 | 0 | 7 | 7 |   |   |   |    | 00:05:00 |
 |---+---+---+---+---+---+---+----+----------|
 | 0 | 0 | 0 |   |   |   |   |    | 00:06:00 |
 |---+---+---+---+---+---+---+----+----------|
 #+TBLFM: $9=@#
 #+TBLFM: $2=$+3::$9=1
 #+TBLFM: $2=$+3
 #+TBLFM: $2= '(identity remote(FOO, @@#$1))
 #+TBLFM: @4 = 2 * remote(FOO, @1$$#)
 #+TBLFM: $1=$+3
 #+TBLFM: $3=$-2
 #+TBLFM: $9=$c+@# 
 #+TBLFM: @1=$# 
 #+TBLFM: $9=@# *60;T 
 #+TBLFM: $9=@# -1
 #+TBLFM: $1=$# -1

			| Sede          | Max cites |              |
			|---------------+-----------+--------------|
			| Chile         |    257.72 | WWWWWWWWWWWW |
			| Leeds         |    165.77 | WWWWWWWh     |
			| Sao Paolo     |     71.00 | WWW;         |
			| Stockholm     |    134.19 | WWWWWW:      |
			| Morelia       |    257.56 | WWWWWWWWWWWW |
			| Rochefourchat |     10.00 | !            |
			#+TBLFM: $3='(orgtbl-ascii-draw $2 0.0 257.72 12)
 (setq evil-want-C-i-jump nil)

		

 (define-key evil-insert-state-map (kbd "TAB") 'tab-to-tab-stop)
 (define-key evil-insert-state-map (kbd "C-i") 'tab-to-tab-stop)

 |---+--------+--------+-----+----|
 |   | dsf    | sdf    | sdf |    |
 |   | asdf   | 43     |  34 | 23 |
 |   | sdfs	 | sfdsdf |     |    |
 |---+--------+--------+-----+----|

 (define-key evil-motion-state-map (kbd "C-i") 'evil-jump-forward)

			M-: (org-element-parse-buffer) <RET>

 :sdf:

 :sdf1:

 :END:

 :END:



		| freeman | 1 | hucker |
		| max     | 1 | humen  |
		|---------+---+--------|
		|         |   |        |
  
		|---------+---+--------|
		|         |   |        |
**** Time 
***** outer

| ! | Ending           | Weeks | Rent |  Total | |---+------------------+-------+------+--------|
| # | [2016-04-18 Mon] |     4 |  180 | 720.00 |
| # | [2016-05-16 Mon] |     4 |  180 | 720.00 |
| # | [2016-06-20 Mon] |     5 |  180 | 900.00 |
#+TBLFM: $5=$Weeks*$Rent; %.2f
#+TBLFM: $3=($2 - @-1$2)/7::$5=$Weeks*$Rent; %.2f0/0/1
#+TBLFM: $3=if(2 == @#, 4, ($2 - @-1$2)/7)::$5=$Weeks*$Rent; %.2f
***** my
|   |       |                        |                       |       |                                      |
|---+-------+------------------------+-----------------------+-------+--------------------------------------|
|   |  1000 | [2020-06-07 Sun 12:24] | [2020-06-07 Вс 10:00] |   0.1 | проснутся                            |
|   |  1005 | [2020-06-07 Sun 10:19] | [2020-06-07 Вс 10:05] |  0.01 | подключить телефон на зарядку        |
|   |  1000 | [2020-06-07 Sun 10:02] | [2020-06-07 Вс 10:01] | 0.001 | включить комп                        |
|   |  1010 | [2020-06-07 Sun 10:10] | [2020-06-07 Вс 10:10] |       | сообшение белому - проверка телефона |
|   |  1015 | [2020-06-07 Sun 10:15] | [2020-06-07 Вс 10:15] |       | принять душь                         |
|   |  1115 | [2020-06-07 Sun 11:15] | [2020-06-07 Вс 11:15] |       | начать складыватсясложится           |
|   |  1145 | [2020-06-07 Sun 11:45] | [2020-06-07 Вс 11:45] |       | выйти                                |
|   |       | 0                      |                       |       | купить воды лоток\сельпо             |
|   |  1245 | [2020-06-08 Mon 13:00] | [2020-06-08 Пн 13:00] |       | выйти из метро                       |
|   | 13:45 | [2020-06-09 Tue 13:00] | [2020-06-09 Вт 13:00] |       |                                      |
|   | 14:45 | 2                      | 1                     |     1 |                                      |
|   | 14:45 | 0                      |                       |       |                                      |
|---+-------+------------------------+-----------------------+-------+--------------------------------------|
|   |       | 0                      |                       |       |                                      |
#+TBLFM: $3=$+1 + $+2
#+TBLFM: $3=@#
***** расписание
	 #+CONSTANTS: mult=6.944e-4 
	 |   | описание          | минут | часов | время начала           | время завершения       |   |
	 |---+-------------------+-------+-------+------------------------+------------------------+---|
	 | 2 | готовим           |    40 |     0 | [2020-06-23 Tue 11:40] | [2020-06-23 Tue 12:20] | 9 |
	 | 3 | Кушаем с Соней    |    40 |       | [2020-06-23 Tue 12:20] | [2020-06-23 Tue 13:00] |   |
	 | 4 | встреча с вадимом |     0 |     1 | [2020-06-23 Tue 13:00] | [2020-06-23 Tue 14:00] | 9 |
	 | 5 | встреча с вадимом |     0 |     1 | [2020-06-23 Tue 14:00] | [2020-06-23 Tue 15:00] | 9 |
	 | 6 | встреча с вадимом |     0 |     1 | [2020-06-23 Tue 15:00] | [2020-06-23 Tue 16:00] | 9 |
	 |---+-------------------+-------+-------+------------------------+------------------------+---|
	 #+TBLFM: $5=$6-($3+$4*60)*$mult::$6=if(@#==@>$1,@>$6,@+1$5)::$1=@#
	 #+TBLFM: @>$6= <2020-05-23 Сб 16:00>
	 #+TBLFM: @>$6=  
	 #+TBLFM: $5=0
	 #+TBLFM: $4=0
	 #+TBLFM: $6=0
	 #+TBLFM: $1=@#

****** keys 
******* new
	 c-c | - generet new table
	 ‘C-c |     (org-table-create-or-convert-from-region)’
******* learn about ~references~ is to type C-c ? : 
		Before being able to insert a formula in [Formula], you need to know how to refer to a row, a column or a single field.
	 The easiest way to learn about references is to type C-c ? while you are in a field.
	 For example, if you are in the [Formula] field, C-c ? will tell you: line @2, col $4, ref @2$4 or D2, meaning that you are on the second row (or line) of the fourth column, and the reference for this field is either @2$4 or D2. 
******* turn on the reference visualization grid with C-c } : 
	 At any moment, if you are lost in rows and columns, you can always turn on the reference visualization grid with C-c }: 
******* Debugging formulas c-c c-{
******* ‘C-c <SPC>     (org-table-blank-field)’
				Blank the field at point.
******* ‘M-a     (org-table-beginning-of-field)’
				Move to beginning of the current table field, or on to the previous
				field.
******* ‘M-e     (org-table-end-of-field)’
				Move to end of the current table field, or on to the next field.
				Blank the field at point.
******* move 
	 ‘M-<LEFT>     (org-table-move-column-left)’
	 ‘M-<RIGHT>     (org-table-move-column-right)’
				Move the current column left/right.
	 ‘M-<UP>     (org-table-move-row-up)’
	 ‘M-<DOWN>     (org-table-move-row-down)’
				Move the current row up/down.
******* add \\ remove
	 ‘M-S-<LEFT>     (org-table-delete-column)’
				Kill the current column.
	 ‘M-S-<RIGHT>     (org-table-insert-column)’
				Insert a new column to the left of the cursor position.
	 ‘M-S-<UP>     (org-table-kill-row)’
				Kill the current row or horizontal line.
	 ‘M-S-<DOWN>     (org-table-insert-row)’
******* ‘C-c -     (org-table-insert-hline)’
				Insert a horizontal line below current row.  With a prefix
				argument, the line is created above the current line.
******* ‘C-c <RET>     (org-table-hline-and-move)’
				Insert a horizontal line below current row, and move the cursor
				into the row below that line.
******* ‘C-c ^     (org-table-sort-lines)’
				Sort the table lines in the region.  The position of point
				indicates the column to be used for sorting, and the range of lines
				is the range between the nearest horizontal separator lines, or the
				entire table.  If point is before the first column, you will be
				prompted for the sorting column.  If there is an active region, the
				mark specifies the first line and the sorting column, while point
				should be in the last line to be included into the sorting.  The
				command prompts for the sorting type (alphabetically, numerically,
				or by time).  You can sort in normal or reverse order.  You can
				also supply your own key extraction and comparison functions.  When
				called with a prefix argument, alphabetic sorting will be
				case-sensitive.
******* ‘M-<RET>     (org-table-wrap-region)’
				Split the current field at the cursor position and move the rest to
				the line below.  If there is an active region, and both point and
				mark are in the same column, the text in the column is wrapped to
				minimum width for the given number of lines.  A numeric prefix
				argument may be used to change the number of desired lines.  If
				there is no region, but you specify a prefix argument, the current
				field is made blank, and the content is appended to the field
				above.
******* ‘C-c +     (org-table-sum)’
				Sum the numbers in the current column, or in the rectangle defined
				by the active region.  The result is shown in the echo area and can
				be inserted with ‘C-y’.
******* ‘S-<RET>     ~протягивание~ (org-table-copy-down)’
				When current field is empty, copy from first non-empty field above.
				When not empty, copy current field down to next row and move cursor
				along with it.  Depending on the option ‘org-table-copy-increment’,
				integer field values will be incremented during copy.  Integers
				that are too large will not be incremented.  Also, a ‘0’ prefix
				argument temporarily disables the increment.  This key is also used
				by shift-selection and related modes (*note Conflicts::).
******* ‘C-c |     (org-table-create-or-convert-from-region)’
				Tables can also be imported by pasting tabular text into the Org
				buffer, selecting the pasted text with ‘C-x C-x’ and then using the
				‘C-c |’ command (see above under Creation and conversion).
	 ‘C-c |     (org-table-create-or-convert-from-region)’
				Convert the active region to a table.  If every line contains at
				least one TAB character, the function assumes that the material is
				tab separated.  If every line contains a comma, comma-separated
				values (CSV) are assumed.  If not, lines are split at whitespace
				into fields.  You can use a prefix argument to force a specific
				separator: ‘C-u’ forces CSV, ‘C-u C-u’ forces TAB, ‘C-u C-u C-u’
******* C-c = for editing column formulas : 
		If you prefer, you can edit formulas in the minibuffer: use C-c = for editing column formulas or C-u C-c = for field formulas.
******* C-u C-c = for field formulas : 
		If you prefer, you can edit formulas in the minibuffer: use C-c = for editing column formulas or C-u C-c = for field formulas.
******* edit formulas interactively in a dedicated buffer C-c ' 
	 But you can also edit formulas more interactively in a dedicated buffer by typing C-c '. This new buffer lists all the formulas for the table at point and provides facilities to edit the references.

	 When the cursor is above a reference, the corresponding field in the table get highlighted. Nice! But you can do more than that: you can actually select the reference by using the S-<left/right/up/down> keys. 
******* ‘C-c `     (org-table-edit-field)’
				Edit the current field in a separate window.  This is useful for
				fields that are not fully visible (*note Column width and
				alignment::).  When called with a ‘C-u’ prefix, just make the full
				field visible, so that it can be edited in place.  When called with
				two ‘C-u’ prefixes, make the editor window follow the cursor
				through the table and always show the current field.  The follow
				mode exits automatically when the cursor leaves the table, or when
				you repeat this command with ‘C-u C-u C-c `’.
******* ‘C-c '     (org-table-edit-formulas)’
				Edit all formulas for the current table in a special buffer, where
				the formulas will be displayed one per line.  If the current field
				has an active formula, the cursor in the formula editor will mark
				it.  While inside the special buffer, Org will automatically
				highlight any field or range reference at the cursor position.  You
				may edit, remove and add formulas, and use the following commands:

				‘C-c C-c  or  C-x C-s     (org-table-fedit-finish)’
						 Exit the formula editor and store the modified formulas.  With
						 ‘C-u’ prefix, also apply the new formulas to the entire table.
				‘C-c C-q     (org-table-fedit-abort)’
						 Exit the formula editor without installing changes.
				‘C-c C-r     (org-table-fedit-toggle-ref-type)’
						 Toggle all references in the formula editor between standard
						 (like ‘B3’) and internal (like ‘@3$2’).
				‘<TAB>     (org-table-fedit-lisp-indent)’
						 Pretty-print or indent Lisp formula at point.  When in a line
						 containing a Lisp formula, format the formula according to
						 Emacs Lisp rules.  Another <TAB> collapses the formula back
						 again.  In the open formula, <TAB> re-indents just like in
						 Emacs Lisp mode.
				‘M-<TAB>     (lisp-complete-symbol)’
						 Complete Lisp symbols, just like in Emacs Lisp mode.(1)
				‘S-<UP>/<DOWN>/<LEFT>/<RIGHT>’
						 Shift the reference at point.  For example, if the reference
						 is ‘B3’ and you press ‘S-<RIGHT>’, it will become ‘C3’.  This
						 also works for relative references and for hline references.
				‘M-S-<UP>     (org-table-fedit-line-up)’
				‘M-S-<DOWN>     (org-table-fedit-line-down)’
						 Move the test line for column formulas in the Org buffer up
						 and down.
				‘M-<UP>     (org-table-fedit-scroll-down)’
				‘M-<DOWN>     (org-table-fedit-scroll-up)’
						 Scroll the window displaying the table.
				‘C-c }’
						 Turn the coordinate grid in the table on and off.


****** Outer exempl
******* GANTT
	 https://www.youtube.com/watch?time_continue=791&v=5ViUBaarsbw&feature=emb_title
****** explains 
******* :=vmean($2..$3) 
	 in this field. This formula means: calculate the mean for fields from the second ($2) to the third ($3) field in this row. If you prefer to use the other notation, type
******* :=vmean(B&..C&)
		where the & character stands for "in this row", which is implicit in the previous notation. 
******* prefixed by = instead of :=  
	 Note that the only difference with what you've inserted previously is that the formula is prefixed by = instead of :=. When you're done, do a C-c C-c in the field: you should be prompted whether you want to replace the formula with a column formula, which is precisely what we want.

	 Once you agree with this, the value in the field should be the same than before (namely 11) and you can now update all the fields in this column by reapplying all formulas with C-u C-c * (or C-c C-c if you're on the #+TBLFM line.) 
	 For now we have been defining formulas by inserting them directly in the table cells: typing = in a field starts the definition for a column formula and typing := starts a definition for a field formula. 
****** visual
******* width of this column to this value : 
	 contain just the string ‘<N>’ where ‘N’ is an integer specifying the
	 width of the column in characters.  The next re-align will then set the
	 width of this column to this value.

	 |---+------------------------------|         |---+--------|
	 |   |                              |         |   | <6>    |
	 | 1 | one                          |         | 1 | one    |
	 | 2 | two                          |  ----\  | 2 | two    |
	 | 3 | This is a long chunk of text |  ----/  | 3 | This=> |
	 | 4 | four                         |         | 4 | four   |
	 |---+------------------------------|         |---+--------|

	 Fields that are wider become clipped and end in the string ‘=>’.  Note
	 that the full text is still in the buffer but is hidden.  To see the
	 full text, hold the mouse over the field—a tool-tip window will show the
	 full content.  To edit such a field, use the command ‘C-c `’ (that is
	 ‘C-c’ followed by the grave accent).  This will open a new window with
	 the full field.  Edit it and finish with ‘C-c C-c’.
******* format 
******** 3.5.2 Formula syntax for Calc
		-----------------------------

		A formula can be any algebraic expression understood by the Emacs ‘Calc’
		package.  Note that ‘calc’ has the non-standard convention that ‘/’ has
		lower precedence than ‘*’, so that ‘a/b*c’ is interpreted as ‘a/(b*c)’.
		Before evaluation by ‘calc-eval’ (*note calc-eval: (calc)Calling Calc
		from Your Programs.), variable substitution takes place according to the
		rules described above.  The range vectors can be directly fed into the
		Calc vector functions like ‘vmean’ and ‘vsum’.

			 A formula can contain an optional mode string after a semicolon.
		This string consists of flags to influence Calc and other modes during
		execution.  By default, Org uses the standard Calc modes (precision 12,
		angular units degrees, fraction and symbolic modes off).  The display
		format, however, has been changed to ‘(float 8)’ to keep tables compact.
		The default settings can be configured using the option
		‘org-calc-default-modes’.
******** List of modes:

		‘p20’
				 Set the internal Calc calculation precision to 20 digits.
		‘n3’, ‘s3’, ‘e2’, ‘f4’
				 Normal, scientific, engineering or fixed format of the result of
				 Calc passed back to Org.  Calc formatting is unlimited in precision
				 as long as the Calc calculation precision is greater.
		‘D’, ‘R’
				 Degree and radian angle modes of Calc.
		‘F’, ‘S’
				 Fraction and symbolic modes of Calc.
		‘T’, ‘t’, ‘U’
				 Duration computations in Calc or Lisp, *note Durations and time
				 values::.
		‘E’
				 If and how to consider empty fields.  Without ‘E’ empty fields in
				 range references are suppressed so that the Calc vector or Lisp
				 list contains only the non-empty fields.  With ‘E’ the empty fields
				 are kept.  For empty fields in ranges or empty field references the
				 value ‘nan’ (not a number) is used in Calc formulas and the empty
				 string is used for Lisp formulas.  Add ‘N’ to use 0 instead for
				 both formula types.  For the value of a field the mode ‘N’ has
				 higher precedence than ‘E’.
		‘N’
				 Interpret all fields as numbers, use 0 for non-numbers.  See the
				 next section to see how this is essential for computations with
				 Lisp formulas.  In Calc formulas it is used only occasionally
				 because there number strings are already interpreted as numbers
				 without ‘N’.
		‘L’
				 Literal, for Lisp formulas only.  See the next section.

		Unless you use large integer numbers or high-precision-calculation and
		-display for floating point numbers you may alternatively provide a
		‘printf’ format specifier to reformat the Calc result after it has been
		passed back to Org instead of letting Calc already do the formatting(1).
********  A few examples:

				 $1+$2                Sum of first and second field
				 $1+$2;%.2f           Same, format result to two decimals
				 exp($2)+exp($1)      Math functions can be used
				 $0;%.1f              Reformat current cell to 1 decimal
				 ($3-32)*5/9          Degrees F -> C conversion
				 $c/$1/$cm            Hz -> cm conversion, using ‘constants.el’
				 tan($1);Dp3s1        Compute in degrees, precision 3, display SCI 1
				 sin($1);Dp3%.1e      Same, but use printf specifier for display
				 taylor($3,x=7,2)     Taylor series of $3, at x=7, second degree

			 Calc also contains a complete set of logical operations, (*note
		Logical Operations: (calc)Logical Operations.).  For example

		‘if($1 < 20, teen, string(""))’
				 "teen" if age $1 is less than 20, else the Org table result field
				 is set to empty with the empty string.
		‘if("$1" == "nan" || "$2" == "nan", string(""), $1 + $2); E f-1’
				 Sum of the first two columns.  When at least one of the input
				 fields is empty the Org table result field is set to empty.  ‘E’ is
				 required to not convert empty fields to 0.  ‘f-1’ is an optional
				 Calc format string similar to ‘%.1f’ but leaves empty results
				 empty.
		‘if(typeof(vmean($1..$7)) == 12, string(""), vmean($1..$7); E’
				 Mean value of a range unless there is any empty field.  Every field
				 in the range that is empty is replaced by ‘nan’ which lets ‘vmean’
				 result in ‘nan’.  Then ‘typeof == 12’ detects the ‘nan’ from
				 ‘vmean’ and the Org table result field is set to empty.  Use this
				 when the sample set is expected to never have missing values.
		‘if("$1..$7" == "[]", string(""), vmean($1..$7))’
				 Mean value of a range with empty fields skipped.  Every field in
				 the range that is empty is skipped.  When all fields in the range
				 are empty the mean value is not defined and the Org table result
				 field is set to empty.  Use this when the sample set can have a
				 variable size.
		‘vmean($1..$7); EN’
				 To complete the example before: Mean value of a range with empty
				 fields counting as samples with value 0.  Use this only when
				 incomplete sample sets should be padded with 0 to the full size.

			 You can add your own Calc functions defined in Emacs Lisp with
		‘defmath’ and use them in formula syntax for Calc.
******** 		---------- Footnotes ----------

			 (1) The ‘printf’ reformatting is limited in precision because the
		value passed to it is converted into an ‘integer’ or ‘double’.  The
		‘integer’ is limited in size by truncating the signed value to 32 bits.
		The ‘double’ is limited in precision to 64 bits overall which leaves
		approximately 16 significant decimal digits.


****** Formulas
******* sum
******** name
	 Assign a field-name using the ^ mark:
	 |---+---|
	 |   | 1 |
	 |   | 2 |
	 |   | 3 |
	 |---+---|
	 |   | 6 |
	 | ^ | x |
	 |---+---|
	 #+TBLFM: $x=vsum(@1..@-1)
******** bitwins lines 
	 Yet another possibility makes use of horizontal lines (@I, @II, etc.) which are useful anyways to structure your table:

	 | What  |    $$ |
	 |-------+-------|
	 | Ice   |  3.00 |
	 | Soda  |  6.49 |
	 | Gin   |  4.99 |
	 |-------+-------|
	 | Total | 14.48 |
	 #+TBLFM: @>$2=vsum(@I..@II)
******** bitwins Rows 
	 The example below gives the sum of the last column both at the first and the last rows.

	 |      |    T |   8 |
	 | Col1 | Col2 | Sum |
	 |------+------+-----|
	 |    1 |    3 |   4 |
	 |    2 |    8 |  10 |
	 |    3 |   -9 |  -6 |
	 |------+------+-----|
	 |      |      |   8 |
	 #+TBLFM: $3=$1+$2::@1$3=vsum(@I..@II)::@6$3=vsum(@I..@II)
	 #+TBLFM: @1$2=T::

	 vsum sums a vector of numbers; @I and @II refer to the first and second hlines.
******** for sum colum 
	 You can try this:
	 $<col_num>=<func>(@2..@-1))
	 @2 is static. It refers to the 2nd row onwards. @-1 refers to the second to last row.
	 I think this was the easiest and non-intrusive way. It preserves your column names and does not clutter up the visual space. It does not require you to address the last row. It is addressed by default.
	 Rows can be added/removed. No other markers.
	 eg.
	 #+TBLFM: $3=vmean(@2..@-1)::$4=vsum(@2..@-1))
	 Sample table
			| Time                   | Input             | Test      | InQty |
			| <2018-03-13 Tue 06:15> | Water             |           |   200 |
			| <2018-03-13 Tue 07:03> |                   |           |       |
			|                        |                   |           |       |
			| <2018-03-13 Tue 07:31> | Water             |           |   180 |
			| <2018-03-13 Tue 09:00> | Chai              |           |   240 |
			| <2018-03-13 Tue 11:30> | Chai              |           |   240 |
			| <2018-03-13 Tue 16:01> | Water             |           |    60 |
			|                        |                   |           |       |
			|------------------------+-------------------+-----------+-------|
			|                        |                   |           |   920 |
			#+TBLFM: $4=vsum(@2..@-1)
******* aggregate & name: 
	 You may use the orgtbl-aggregate package available on http://melpa.org
	 The sum of Col1 and Col2 is given in the aggregated table below.
	 #+name: cc
	 | Col1 | Col2 | Sum8 |
	 |------+------+------|
	 |    1 |    3 |    4 |
	 |    2 |    8 |   10 |
	 |    3 |   -9 |   -6 |
	 #+TBLFM: $3=$1+$2

	 #+BEGIN: aggregate :table "cc" :cols "vsum(Col1+Col2)"

	 #+END:

	 Documentation here: https://github.com/tbanel/orgaggregate
******* indexing colum #+tblfm: $1=@#-1
	 Place #+tblfm: $1=@#-1 under the table. Now when you move your mouse to the formula and C-c C-c on it, it will recalculate the contents of the first column s.a. to create a sequence of increasing integers. – wvxvw Aug 12 '15 at 8:51
	 I was looking for exactly the same thing (@#). Sometimes searching is faster than asking... ;-D – user543 Aug 13 '15 at 3:53
	 It's possible, but time-consuming, to figure this out from the manual by piecing together info from two sections (sometimes asking is faster than searching, reading, and thinking :) Go to the info-mode manual in emacs (C-h I), Section 3.5.1 of the manual, in an unnumbered sub-section called "Field coordinates in formulas," explains @#-1. Then section 3.5.6, "Column Fomulas," explains the $1=. – Reb.Cabin Jul 14 '19 at 17:50
	 Note that with @wvxvw's answer you can have 0-based indexing with $1=@#-2.
******* Field coordinates in formulas
	 .............................

	 One of the very first actions during evaluation of Calc formulas and
	 Lisp formulas is to substitute ‘@#’ and ‘$#’ in the formula with the row
	 or column number of the field where the current result will go to.  The
	 traditional Lisp formula equivalents are ‘org-table-current-dline’ and
	 ‘org-table-current-column’.  Examples:

	 ‘if(@# % 2, $#, string(""))’
				Insert column number on odd rows, set field to empty on even rows.
	 ‘$2 = '(identity remote(FOO, @@#$1))’
				Copy text or values of each row of column 1 of the table named
				‘FOO’ into column 2 of the current table.
	 ‘@3 = 2 * remote(FOO, @1$$#)’
				Insert the doubled value of each column of row 1 of the table named
				‘FOO’ into row 3 of the current table.

	 For the second/third example, the table named ‘FOO’ must have at least
	 as many rows/columns as the current table.  Note that this is
	 inefficient(3) for large number of rows/columns.
******* Named references : 
	 ‘$name’ is interpreted as the name of a column, parameter or constant.
	 Constants are defined globally through the option
	 ‘org-table-formula-constants’, and locally (for the file) through a line
	 like

				#+CONSTANTS: c=299792458. pi=3.14 eps=2.4e-6

	 Also properties (*note Properties and columns::) can be used as
	 constants in table formulas: for a property ‘:Xyz:’ use the name
	 ‘$PROP_Xyz’, and the property will be searched in the current outline
	 entry and in the hierarchy above it.  If you have the ‘constants.el’
	 package, it will also be used to resolve constants, including natural
	 constants like ‘$h’ for Planck’s constant, and units like ‘$km’ for
	 kilometers(4).  Column names and parameters can be specified in special
	 table lines.  These are described below, see *note Advanced features::.
	 All names must start with a letter, and further consist of letters and
	 numbers.

******* Remote references : 
	 You may also reference constants, fields and ranges from a different
	 table, either in the current file or even in a different file.  The
	 syntax is
				remote(NAME-OR-ID,REF)
	 where NAME can be the name of a table in the current file as set by a
	 ‘#+NAME: Name’ line before the table.  It can also be the ID of an
	 entry, even in a different file, and the reference then refers to the
	 first table in that entry.  REF is an absolute field or range reference
	 as described above for example ‘@3$3’ or ‘$somename’, valid in the
	 referenced table.
			Indirection of NAME-OR-ID: When NAME-OR-ID has the format
	 ‘@ROW$COLUMN’ it will be substituted with the name or ID found in this
	 field of the current table.  For example ‘remote($1, @>$2)’ =>
	 ‘remote(year_2013, @>$1)’.  The format ‘B3’ is not supported because it
	 can not be distinguished from a plain table name or ID.

******* 3.5.7 Lookup functions
	 ----------------------

	 Org has three predefined Emacs Lisp functions for lookups in tables.
	 ‘(org-lookup-first VAL S-LIST R-LIST &optional PREDICATE)’
				Searches for the first element ‘S’ in list ‘S-LIST’ for which
						 (PREDICATE VAL S)
				is ‘t’; returns the value from the corresponding position in list
				‘R-LIST’.  The default ‘PREDICATE’ is ‘equal’.  Note that the
				parameters ‘VAL’ and ‘S’ are passed to ‘PREDICATE’ in the same
				order as the corresponding parameters are in the call to
				‘org-lookup-first’, where ‘VAL’ precedes ‘S-LIST’.  If ‘R-LIST’ is
				‘nil’, the matching element ‘S’ of ‘S-LIST’ is returned.
	 ‘(org-lookup-last VAL S-LIST R-LIST &optional PREDICATE)’
				Similar to ‘org-lookup-first’ above, but searches for the last
				element for which ‘PREDICATE’ is ‘t’.
	 ‘(org-lookup-all VAL S-LIST R-LIST &optional PREDICATE)’
				Similar to ‘org-lookup-first’, but searches for all elements for
				which ‘PREDICATE’ is ‘t’, and returns all corresponding values.
				This function can not be used by itself in a formula, because it
				returns a list of values.  However, powerful lookups can be built
				when this function is combined with other Emacs Lisp functions.

			If the ranges used in these functions contain empty fields, the ‘E’
	 mode for the formula should usually be specified: otherwise empty fields
	 will not be included in ‘S-LIST’ and/or ‘R-LIST’ which can, for example,
	 result in an incorrect mapping from an element of ‘S-LIST’ to the
	 corresponding element of ‘R-LIST’.

			These three functions can be used to implement associative arrays,
	 count matching cells, rank results, group data etc.  For practical
	 examples see this tutorial on Worg
	 (https://orgmode.org/worg/org-tutorials/org-lookups.html).


******* 3.5.10 Advanced features
******** calculation mark in first column : 
		If you want the recalculation of fields to happen automatically, or if
		you want to be able to assign names(1) to fields and columns, you need
		to reserve the first column of the table for special marking characters.

		‘C-#     (org-table-rotate-recalc-marks)’
				 Rotate the calculation mark in first column through the states ‘ ’,
				 ‘#’, ‘*’, ‘!’, ‘$’.  When there is an active region, change all
				 marks in the region.

		 
******** example of a table : 
			 Here is an example of a table that collects exam results of students
		and makes use of these features:

				 |---+---------+--------+--------+--------+-------+------|
				 |   | Student | Prob 1 | Prob 2 | Prob 3 | Total | Note |
				 |---+---------+--------+--------+--------+-------+------|
				 | ! |         |     P1 |     P2 |     P3 |   Tot |      |
				 | # | Maximum |     10 |     15 |     25 |    50 | 10.0 |
				 | ^ |         |     m1 |     m2 |     m3 |    mt |      |
				 |---+---------+--------+--------+--------+-------+------|
				 | # | Peter   |     10 |      8 |     23 |    41 |  8.2 |
				 | # | Sam     |      2 |      4 |      3 |     9 |  1.8 |
				 |---+---------+--------+--------+--------+-------+------|
				 |   | Average |        |        |        |  25.0 |      |
				 | ^ |         |        |        |        |    at |      |
				 | $ | max=50  |        |        |        |       |      |
				 |---+---------+--------+--------+--------+-------+------|
				 |   | 50      |        |        |        |       |      |
				 #+TBLFM: $6=vsum($P1..$P3)::$7=10*$Tot/$max;%.1f::$at=vmean(@-II..@-I);%.1f
				 #+TBLFM: @10$2=$max
********* Important : 
		Important: please note that for these special tables, recalculating the
		table with ‘C-u C-c *’ will only affect rows that are marked ‘#’ or ‘*’,
		and fields that have a formula assigned to the field itself.  The column
		formulas are not applied in rows with empty first field.
******** The marking characters have the following meaning:
*********  ‘!’
					The fields in this line define names for the columns, so that you
					may refer to a column as ‘$Tot’ instead of ‘$6’.
********* 	‘^’
					This row defines names for the fields _above_ the row.  With such a
					definition, any formula in the table may use ‘$m1’ to refer to the
					value ‘10’.  Also, if you assign a formula to a names field, it
					will be stored as ‘$name=...’.
********* 	‘_’
					Similar to ‘^’, but defines names for the fields in the row
					_below_.
*********  ‘$’
					Fields in this row can define _parameters_ for formulas.  For
					example, if a field in a ‘$’ row contains ‘max=50’, then formulas
					in this table can refer to the value 50 using ‘$max’.  Parameters
					work exactly like constants, only that they can be defined on a
					per-table basis.
 
********* ‘#’
					Fields in this row are automatically recalculated when pressing
					<TAB> or <RET> or ‘S-<TAB>’ in this row.  Also, this row is
					selected for a global recalculation with ‘C-u C-c *’.  Unmarked
					lines will be left alone by this command.

********* 	‘*’
					Selects this line for global recalculation with ‘C-u C-c *’, but
					not for automatic recalculation.  Use this when automatic
					recalculation slows down editing too much.

********* 	‘ ’
					Unmarked lines are exempt from recalculation with ‘C-u C-c *’.  All
					lines that should be recalculated should be marked with ‘#’ or ‘*’.

********* 	‘/’
					Do not export this line.  Useful for lines that contain the
					narrowing ‘<N>’ markers or column group markers.

******** series of degree ‘n’ at location ‘x’  : 
			 Finally, just to whet your appetite for what can be done with the
		fantastic ‘calc.el’ package, here is a table that computes the Taylor
		series of degree ‘n’ at location ‘x’ for a couple of functions.

				 |---+-------------+---+-----+--------------------------------------|
				 |   | Func        | n | x   | Result                               |
				 |---+-------------+---+-----+--------------------------------------|
				 | # | exp(x)      | 1 | x   | 1 + x                                |
				 | # | exp(x)      | 2 | x   | 1 + x + x^2 / 2                      |
				 | # | exp(x)      | 3 | x   | 1 + x + x^2 / 2 + x^3 / 6            |
				 | # | x^2+sqrt(x) | 2 | x=0 | x*(0.5 / 0) + x^2 (2 - 0.25 / 0) / 2 |
				 | # | x^2+sqrt(x) | 2 | x=1 | 2 + 2.5 x - 2.5 + 0.875 (x - 1)^2    |
				 | * | tan(x)      | 3 | x   | x pi / 180 + 5.72e-8 x^3 pi^3        |
				 |---+-------------+---+-----+--------------------------------------|
				 #+TBLFM: $5=taylor($2,$4,$3);n3

******** ---------- Footnotes ----------

			 (1) Such names must start by an alphabetic character and use only
		alphanumeric/underscore characters.

******* ASCII bar plots
	 ---------------
	 While the cursor is on a column, typing ‘C-c " a’ or ‘M-x
	 orgtbl-ascii-plot <RET>’ create a new column containing an ASCII-art
	 bars plot.  The plot is implemented through a regular column formula.
	 When the source column changes, the bar plot may be updated by
	 refreshing the table, for example typing ‘C-u C-c *’.

				| Sede          | Max cites |              |
				|---------------+-----------+--------------|
				| Chile         |    257.72 | WWWWWWWWWWWW |
				| Leeds         |    165.77 | WWWWWWWh     |
				| Sao Paolo     |     71.00 | WWW;         |
				| Stockholm     |    134.19 | WWWWWW:      |
				| Morelia       |    257.56 | WWWWWWWWWWWH |
				| Rochefourchat |      0.00 |              |
				#+TBLFM: $3='(orgtbl-ascii-draw $2 0.0 257.72 12)

			The formula is an elisp call:
				(orgtbl-ascii-draw COLUMN MIN MAX WIDTH)

	 ‘COLUMN’
				is a reference to the source column.

	 ‘MIN MAX’
				are the minimal and maximal values displayed.  Sources values
				outside this range are displayed as ‘too small’ or ‘too large’.

	 ‘WIDTH’
				is the width in characters of the bar-plot.  It defaults to ‘12’.


****** Lisp code
******* explene constans & exempl
		But what if you want to use Emacs lisp code instead of Calc?

	 Lets say for example that you want to associate each student with a decimal of the Pi number, depending on their mean across maths and physics.

	 For this you need to tell Org about the value you consider to be the value of the Pi number. You can do this by adding this line:

	 #+CONSTANTS: pi=3.14159265358979323846

	 (Don't forget to hit C-c C-c on the #+CONSTANTS line so that org-mode knows about it.)

	 Then you can define an Emacs lisp formula like this one:

	 $5='(substring (number-to-string $pi) (round $4) (1+ (round $4)));N

	 Ahem. Let's parse this:

			 (substring S A B): get a substring of string S between A and B
			 (number-to-string $pi): convert the constant "Pi" into a string
			 (round $4): get the rounded value of the value in column $4
			 ;N: consider the values of fields to be numeric values, not strings.

	 If the mean of a student is 10, this formula returns the tenth decimal of Pi. 
*** Formuls 
**** sqrt : 
 #+TBLFM: @2$2 = 100 - @-1 :: $5 = 1 ::@3$2 = @-1 * @-2::@4$2 = sqrt(@-1)
**** sum 
#+TBLFM: 
@>$5=vsum(@I..@12)::
@>$3=vsum(@I..@II)::$3=@1$3*$-1::
$5=@1$3*($2^2)::@2$4= @2$3::$4=$3+@-1$4::@>$4=0:: 
@2$6=@2$5::$6=$5+@-1$6::@>$6=0

*** Keys 
**** Re-aligning and
----------------------------
‘C-c C-c’ (‘org-table-align’)
     Re-align the table without moving point.

‘<TAB>’ (‘org-table-next-field’)
     Re-align the table, move to the next field.  Creates a new row if
     necessary.

‘C-c <SPC>’ (‘org-table-blank-field’)
     Blank the field at point.

‘S-<TAB>’ (‘org-table-previous-field’)
     Re-align, move to previous field.

‘<RET>’ (‘org-table-next-row’)
     Re-align the table and move down to next row.  Creates a new row if
     necessary.  At the beginning or end of a line, ‘<RET>’ still
     inserts a new line, so it can be used to split a table.

**** field motion
----------------------------
‘M-a’ (‘org-table-beginning-of-field’)
     Move to beginning of the current table field, or on to the previous
     field.

‘M-e’ (‘org-table-end-of-field’)
     Move to end of the current table field, or on to the next field.

**** Column and row editing
----------------------
‘M-<LEFT>’ (‘org-table-move-column-left’)
     Move the current column left.

‘M-<RIGHT>’ (‘org-table-move-column-right’)
     Move the current column right.

‘M-S-<LEFT>’ (‘org-table-delete-column’)
     Kill the current column.

‘M-S-<RIGHT>’ (‘org-table-insert-column’)
     Insert a new column at point position.  Move the recent column and
     all cells to the right of this column to the right.

‘M-<UP>’ (‘org-table-move-row-up’)
     Move the current row up.

‘M-<DOWN>’ (‘org-table-move-row-down’)
     Move the current row down.

‘M-S-<UP>’ (‘org-table-kill-row’)
     Kill the current row or horizontal line.

‘S-<UP>’ (‘org-table-move-cell-up’)
     Move cell up by swapping with adjacent cell.

‘S-<DOWN>’ (‘org-table-move-cell-down’)
     Move cell down by swapping with adjacent cell.

‘S-<LEFT>’ (‘org-table-move-cell-left’)
     Move cell left by swapping with adjacent cell.

‘S-<RIGHT>’ (‘org-table-move-cell-right’)
     Move cell right by swapping with adjacent cell.

‘M-S-<DOWN>’ (‘org-table-insert-row’)
     Insert a new row above the current row.  With a prefix argument,
     the line is created below the current one.

‘C-c -’ (‘org-table-insert-hline’)
     Insert a horizontal line below current row.  With a prefix
     argument, the line is created above the current line.

‘C-c <RET>’ (‘org-table-hline-and-move’)
     Insert a horizontal line below current row, and move point into the
     row below that line.

‘C-c ^’ (‘org-table-sort-lines’)
     Sort the table lines in the region.  The position of point
     indicates the column to be used for sorting, and the range of lines
     is the range between the nearest horizontal separator lines, or the
     entire table.  If point is before the first column, you are
     prompted for the sorting column.  If there is an active region, the
     mark specifies the first line and the sorting column, while point
     should be in the last line to be included into the sorting.  The
     command prompts for the sorting type, alphabetically, numerically,
     or by time.  You can sort in normal or reverse order.  You can also
     supply your own key extraction and comparison functions.  When
     called with a prefix argument, alphabetic sorting is
     case-sensitive.

**** Regions
-------
‘C-c C-x M-w’ (‘org-table-copy-region’)
     Copy a rectangular region from a table to a special clipboard.
     Point and mark determine edge fields of the rectangle.  If there is
     no active region, copy just the current field.  The process ignores
     horizontal separator lines.

‘C-c C-x C-w’ (‘org-table-cut-region’)
     Copy a rectangular region from a table to a special clipboard, and
     blank all fields in the rectangle.  So this is the “cut” operation.

‘C-c C-x C-y’ (‘org-table-paste-rectangle’)
     Paste a rectangular region into a table.  The upper left corner
     ends up in the current field.  All involved fields are overwritten.
     If the rectangle does not fit into the present table, the table is
     enlarged as needed.  The process ignores horizontal separator
     lines.

‘M-<RET>’ (‘org-table-wrap-region’)
     Split the current field at point position and move the rest to the
     line below.  If there is an active region, and both point and mark
     are in the same column, the text in the column is wrapped to
     minimum width for the given number of lines.  A numeric prefix
     argument may be used to change the number of desired lines.  If
     there is no region, but you specify a prefix argument, the current
     field is made blank, and the content is appended to the field
     above.

**** Calculations
------------

‘C-c +’ (‘org-table-sum’)
     Sum the numbers in the current column, or in the rectangle defined
     by the active region.  The result is shown in the echo area and can
     be inserted with ‘C-y’.

‘S-<RET>’ (‘org-table-copy-down’)
     When current field is empty, copy from first non-empty field above.
     When not empty, copy current field down to next row and move point
     along with it.

     Depending on the variable ‘org-table-copy-increment’, integer and
     time stamp field values, and fields prefixed or suffixed with a
     whole number, can be incremented during copy.  Also, a ‘0’ prefix
     argument temporarily disables the increment.

     This key is also used by shift-selection and related modes (see
     *note Conflicts::).

**** Miscellaneous
-------------

‘C-c `’ (‘org-table-edit-field’)
     Edit the current field in a separate window.  This is useful for
     fields that are not fully visible (see *note Column Width and
     Alignment::).  When called with a ‘C-u’ prefix, just make the full
     field visible, so that it can be edited in place.  When called with
     two ‘C-u’ prefixes, make the editor window follow point through the
     table and always show the current field.  The follow mode exits
     automatically when point leaves the table, or when you repeat this
     command with ‘C-u C-u C-c `’.

‘M-x org-table-import’
     Import a file as a table.  The table should be TAB or whitespace
     separated.  Use, for example, to import a spreadsheet table or data
     from a database, because these programs generally can write
     TAB-separated text files.  This command works by inserting the file
     into the buffer and then converting the region to a table.  Any
     prefix argument is passed on to the converter, which uses it to
     determine the separator.

‘C-c |’ (‘org-table-create-or-convert-from-region’)
     Tables can also be imported by pasting tabular text into the Org
     buffer, selecting the pasted text with ‘C-x C-x’ and then using the
     ‘C-c |’ command (see *note Creation and conversion::).

‘M-x org-table-export’
     Export the table, by default as a TAB-separated file.  Use for data
     exchange with, for example, spreadsheet or database programs.  The
     format used to export the file can be configured in the variable
     ‘org-table-export-default-format’.  You may also use properties
     ‘TABLE_EXPORT_FILE’ and ‘TABLE_EXPORT_FORMAT’ to specify the file
     name and the format for table export in a subtree.  Org supports
     quite general formats for exported tables.  The exporter format is
     the same as the format used by Orgtbl radio tables, see *note
     Translator functions::, for a detailed description.

**** Shrink or expand current column : 
‘C-c <TAB>’ (‘org-table-toggle-column-width’)
     Shrink or expand current column.

     If a width cookie specifies a width W for the column, shrinking it
     displays the first W visible characters only.  Otherwise, the
     column is shrunk to a single character.

     When called before the first column or after the last one, ask for
     a list of column ranges to operate on.

‘C-u C-c <TAB>’ (‘org-table-shrink’)
     Shrink all columns with a column width.  Expand the others.

‘C-u C-u C-c <TAB>’ (‘org-table-expand’)
     Expand all columns.

**** what the coordinates : 
what the coordinates of a field are, press ‘C-c ?’ in that field, or
**** display of a grid : 
press ‘C-c }’ to toggle the display of a grid.

**** Install a new formula for the current column : 
‘C-c =’ (‘org-table-eval-formula’)
     Install a new formula for the current column and replace current
     field with the result of the formula.  The command prompts for a
     formula, with default taken from the ‘TBLFM’ keyword, applies it to
     the current field and stores it.  With a numeric prefix argument,
     e.g., ‘C-5 C-c =’, the command applies it to that many consecutive
     fields in the current column.

   To assign a formula to a column, type it directly into any field in
the column, preceded by an equal sign, like ‘=$1+$2’.  When you press
‘<TAB>’ or ‘<RET>’ or ‘C-c C-c’ with point still in the field, the
formula is stored as the formula for the current column, evaluated and
the current field replaced with the result.  If the field contains only
‘=’, the previously stored formula for this column is used.  For each
column, Org only remembers the most recently used formula.  In the
‘TBLFM’ keyword, column formulas look like ‘$4=$1+$2’.  The left-hand
side of a column formula can not be the name of column, it must be the
numeric column reference or ‘$>’.

**** Install a new formula for the current field. : 
To assign a formula to a particular field, type it directly into the
field, preceded by ‘:=’, for example ‘vsum(@II..III)’.  When you press
‘<TAB>’ or ‘<RET>’ or ‘C-c C-c’ with point still in the field, the
formula is stored as the formula for this field, evaluated, and the
current field is replaced with the result.

‘C-u C-c =’ (‘org-table-eval-formula’)
     Install a new formula for the current field.  The command prompts
     for a formula with default taken from the ‘TBLFM’ keyword, applies
     it to the current field, and stores it.

   The left-hand side of a formula can also be a special expression in
order to assign the formula to a number of different fields.  There is
no keyboard shortcut to enter such range formulas.  To add them, use the
formula editor (see *note Editing and debugging formulas::) or edit the
‘TBLFM’ keyword directly.

‘$2=’
     Column formula, valid for the entire column.  This is so common
     that Org treats these formulas in a special way, see *note Column
     formulas::.

‘@3=’
     Row formula, applies to all fields in the specified row.  ‘@>=’
     means the last row.

‘@1$2..@4$3=’
     Range formula, applies to all fields in the given rectangular
     range.  This can also be used to assign a formula to some but not
     all fields in a row.

‘$NAME=’
     Named field, see *note Advanced features::.

**** 3.5.8 Editing and debugging formulas
------------------------------------
You can edit individual formulas in the minibuffer or directly in the
field.  Org can also prepare a special buffer with all active formulas
of a table.  When offering a formula for editing, Org converts
references to the standard format (like ‘B3’ or ‘D&’) if possible.  If
you prefer to only work with the internal format (like ‘@3$2’ or ‘$4’),
configure the variable ‘org-table-use-standard-references’.

‘C-c =’ or ‘C-u C-c =’ (‘org-table-eval-formula’)
     Edit the formula associated with the current column/field in the
     minibuffer.  See *note Column formulas::, and *note Field and range
     formulas::.

‘C-u C-u C-c =’ (‘org-table-eval-formula’)
     Re-insert the active formula (either a field formula, or a column
     formula) into the current field, so that you can edit it directly
     in the field.  The advantage over editing in the minibuffer is that
     you can use the command ‘C-c ?’.

‘C-c ?’ (‘org-table-field-info’)
     While editing a formula in a table field, highlight the field(s)
     referenced by the reference at point position in the formula.

‘C-c }’ (‘org-table-toggle-coordinate-overlays’)
     Toggle the display of row and column numbers for a table, using
     overlays.  These are updated each time the table is aligned; you
     can force it with ‘C-c C-c’.

‘C-c {’ (‘org-table-toggle-formula-debugger’)
     Toggle the formula debugger on and off.  See below.

‘C-c '’ (‘org-table-edit-formulas’)
     Edit all formulas for the current table in a special buffer, where
     the formulas are displayed one per line.  If the current field has
     an active formula, point in the formula editor marks it.  While
     inside the special buffer, Org automatically highlights any field
     or range reference at point position.  You may edit, remove and add
     formulas, and use the following commands:

     ‘C-c C-c’ or ‘C-x C-s’ (‘org-table-fedit-finish’)
          Exit the formula editor and store the modified formulas.  With
          ‘C-u’ prefix, also apply the new formulas to the entire table.

     ‘C-c C-q’ (‘org-table-fedit-abort’)
          Exit the formula editor without installing changes.

     ‘C-c C-r’ (‘org-table-fedit-toggle-ref-type’)
          Toggle all references in the formula editor between standard
          (like ‘B3’) and internal (like ‘@3$2’).

     ‘<TAB>’ (‘org-table-fedit-lisp-indent’)
          Pretty-print or indent Lisp formula at point.  When in a line
          containing a Lisp formula, format the formula according to
          Emacs Lisp rules.  Another ‘<TAB>’ collapses the formula back
          again.  In the open formula, ‘<TAB>’ re-indents just like in
          Emacs Lisp mode.

     ‘M-<TAB>’ (‘lisp-complete-symbol’)
          Complete Lisp symbols, just like in Emacs Lisp mode.

     ‘S-<UP>’, ‘S-<DOWN>’, ‘S-<LEFT>’, ‘S-<RIGHT>’
          Shift the reference at point.  For example, if the reference
          is ‘B3’ and you press ‘S-<RIGHT>’, it becomes ‘C3’.  This also
          works for relative references and for hline references.

     ‘M-S-<UP>’ (‘org-table-fedit-line-up’)
          Move the test line for column formulas up in the Org buffer.

     ‘M-S-<DOWN>’ (‘org-table-fedit-line-down’)
          Move the test line for column formulas down in the Org buffer.

     ‘M-<UP>’ (‘org-table-fedit-scroll-up’)
          Scroll up the window displaying the table.

     ‘M-<DOWN>’ (‘org-table-fedit-scroll-down’)
          Scroll down the window displaying the table.

     ‘C-c }’
          Turn the coordinate grid in the table on and off.

   Making a table field blank does not remove the formula associated
with the field, because that is stored in a different line—the ‘TBLFM’
keyword line.  During the next recalculation, the field will be filled
again.  To remove a formula from a field, you have to give an empty
reply when prompted for the formula, or to edit the ‘TBLFM’ keyword.

   You may edit the ‘TBLFM’ keyword directly and re-apply the changed
equations with ‘C-c C-c’ in that line or with the normal recalculation
commands in the table.

** Tags 
Two: Which tags do you use most?
You can always add tags freely and by hand, but if you configure the most important ones along with fast-access keys, life will be better. Configure the variable org-tags-alist or simply do this right in the file with1
#+TAGS: home(h) work(w) @computer(c) @phone(p) errants(e)
** Todos 
*** Dependantistis 
**** TODO Blocked until (two) is done
***** DONE one
***** TODO two
**** Parent
     :PROPERTIES:
     :ORDERED:  t
     :END:
***** WAITING a
- isdf
- [ ] sdfs
- [X] sdfsdf
***** TODO b, needs to wait for (a)
***** TODO c, needs to wait for (a) and (b)

   You can ensure an entry is never blocked by using the NOBLOCKING property:

**** This entry is never blocked
     :PROPERTIES:
     :NOBLOCKING: t
     :END:

   C-c C-x o     (org-toggle-ordered-property)
*** Status 
  One: More TODO keywords
  Define the TODO states you find useful and single letters for fast selection. Customize the variable org-todo-keywords or simply do this right in the file with1:
  #+TODO: TODO(t) STARTED(s) WAITING(w) | DONE(d) CANCELED(c)
*** arhiv 
    c+c $ 
you can move them to an archive file with C-c $ (org-archive-subtree)отправляет в архи таким путём чистя агенду и лист
момет отправки помечается временени поидееии
и соответственно его скорй всего потом оможно будет от туда выташить и использовать 
*** shadule
    С+с С+s
  Next, we're going to schedule some tasks. Go to a task that you want to do today. Press C-c C-s (org-schedule) and accept the default. Schedule a couple of other tasks for today.

Schedule some tasks for tomorrow, too. This time, when you schedule it, type +1 for the date. You can specify +2 for the day after tomorrow, etc. The 28th? 28. If you want to schedule something for next Saturday, you can type sat. Two Tuesdays from now? 2thu. A month from now? 1m. It's really flexible. 
*** агендa
**** keys add agenda file
    C-c [     (org-agenda-file-to-front)

     Add current file to the list of agenda files. The file is added to the front of the list. If it was already in the list, it is moved to the front. With a prefix argument, file is added/moved to the end. 
 C-c ]     (org-remove-file)

     Remove current file from the list of agenda files. 
**** comands to add agenda file
    (setq org-agenda-files '("~/org"))
    (setq org-agenda-files '("~/ORG/start.org"))
    (setq org-agenda-files (quote ("~/ORG/start.org")))
*** *add a :CATEGORY: property to the top-level, non-TODO heading that identifies the project.  Using your example:

 * Project ABC
  :PROPERTIES:
  :CATEGORY: ABC
  :END:

 ** TODO A task related to Project ABC
 ** TODO Another task related to ABC
 *** TODO Subtask
SCHEDULED: 

In my bog-standard org-mode setup, this results in “ABC” being displayed in the far-left column of the agenda instead of just “todo” (which seems to be the default). This is great — it means that, in the text of the “Subtask” todo entry itself, I don’t need to include a reminder of what project the todo entry is associated with.

Here’s an agenda mockup to illustrate the point, augmented with a “default” entry from my own to-do list:

  todo:       Scheduled:  Follow up on expense reimbursement request
  ABC:        Scheduled:  Subtask

** Links 
[[info:org#Hyperlinks][info:org#Hyperlinks]]
*** общее
(define-key global-map "\C-cl" 'org-store-link)
Для того что бы создать ссылку достаточно использовать такой шаблон — [[%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0][описание]].
  [ {] [] ]

Для создания ссылки можно ещё использовать комбинацию C+c C+l. В мини-буфере emacs предложит сначала написать ссылку, затем после нажатия RET — её создать. Находясь в мини-буфере так же можно нажать TAB, для просмотра, какие виды ссылок бывают.
редактировать повторно тойже комбинацией C+c C+l. 

Что бы открыть вновь созданные ссылки необходимо навести точку на ссылку и тыкнуть C+c C+o. Или C+u C+c C+o — если Вы хотите открыть её в другом окне.

Ради интереса, можно перейти в другой файл, нажать там C+c l. И ссылка на этот файл поместится в хранилище ссылок. Перейдя в любой наш файл .org мы можем извлечь из этого хранилища любые сохраненные ссылки, с помощью той же команды C+c C+l.
Самые наблюдательные читатели уже могли заметить, что эта команда как раз и есть та, которую мы вписали в ~/.emacs, в начале.
‘file:/home/dominik/images/jupiter.jpg’ file, absolute path
‘/home/dominik/images/jupiter.jpg’ same as above
‘file:papers/last.pdf’ file, relative path
‘./papers/last.pdf’ same as above
‘file:/ssh:me@some.where:papers/last.pdf’ file, path on remote machine
‘/ssh:me@some.where:papers/last.pdf’ same as above
‘file:sometextfile::NNN’ file, jump to line number
‘file:projects.org’ another Org file
‘file:projects.org::some words’ text search in Org file5
‘file:projects.org::*task title’ heading search in Org file
‘file+sys:/path/to/file’ open via OS, like double-click
‘file+emacs:/path/to/file’ force opening by Emacs
‘docview:papers/last.pdf::NNN’ open in doc-view mode at page
‘id:B7423F4D-2E8A-471B-8810-C40F074717E9’ link to heading by ID
‘mailto:adent@galaxy.net’ mail link
‘irc:/irc.com/#emacs/bob’ IRC link
‘info:org#External links’ Info node link
‘shell:ls *.org’ shell command
‘elisp:org-agenda’ interactive Elisp command
‘elisp:(find-file "Elisp.org")’ Elisp form to evaluate
‘http://www.astro.uva.nl/=dominik’ on the web
*** мануал пдф
[[https://orgmode.org/org.pdf][Link to 304p doc about org]]
*** 4.2 Internal Link
If the link does not look like a URL, it is considered to be internal in the current file.
The most important case is a link like ‘[[#my-custom-id]]’ which links to the entry with
the ‘CUSTOM_ID’ property ‘my-custom-id’. You are responsible yourself to make sure these
custom IDs are unique in a file.
Links such as ‘[[My Target]]’ or ‘[[My Target][Find my target]]’ lead to a text
‘[[My Target]}’ or ‘[[My Target][Find my target]}’
search in the current file.

The link can be followed with C-c C-o when point is on the link, or with a mouse click
(see Section 4.5 [Handling Links], page 39). Links to custom IDs point to the corresponding
headline. The preferred match for a text link is a dedicated target: the same string in double

angular brackets, like ‘<<My Target>>’.
If no dedicated target exists, the link tries to match the exact name of an element within
the buffer. Naming is done with the ‘NAME’ keyword, which has to be put in the line before
the element it refers to, as in the following example
#+NAME: My Target
| a | table |
|----+------------|
| of | four cells |
If none of the above succeeds, Org searches for a headline that is exactly the link text
but may also include a TODO keyword and tags3
1. one item
2. <<target>>another item
Here we refer to item [[target]] \ [[target]} .
The last sentence will appear as ‘Here we refer to item 2’ when exported.
In non-Org files, the search looks for the words in the link text. In the above example
the search would be for ‘target’.
Following a link pushes a mark onto Org’s own mark ring. You can return to the previous
position with C-c &. Using this command several times in direct succession goes back to
positions recorded earlier.
*** 4.7 Link Abbreviations 
[[linkword:tag][description]}
where the tag is optional. The linkword must be a word, starting with a letter, followed by
letters, numbers, ‘-’, and ‘_’. Abbreviations are resolved according to the information in
the variable org-link-abbrev-alist that relates the linkwords to replacement text. Here
is an example:
(setq org-link-abbrev-alist
'(("bugzilla" . "http://10.1.2.9/bugzilla/show_bug.cgi?id=")
("url-to-ja" . "http://translate.google.fr/translate?sl=en&tl=ja&u=%h")
("google" . "http://www.google.com/search?q=")
("gmap" . "http://maps.google.com/maps?q=%s")
("omap" . "http://nominatim.openstreetmap.org/search?q=%s&polygon=1")
("ads" . "https://ui.adsabs.harvard.edu/search/q=%20author%3A\"%s\"")))
If the replacement text contains the string ‘%s’, it is replaced with the tag. Using ‘%h’
instead of ‘%s’ percent-encodes the tag (see the example above, where we need to encode
the URL parameter). Using ‘%(my-function)’ passes the tag to a custom Lisp function,
and replace it by the resulting string.
If the replacement text do not contain any specifier, it is simply appended to the string
in order to create the link.
Instead of a string, you may also specify a Lisp function to create the link. Such a
function will be called with the tag as the only argument.
With the above setting, you could link to a specific bug with ‘[[bugzilla:129]]’,
search the web for ‘OrgMode’ with ‘[[google:OrgMode]]’, show the map location of the
Free Software Foundation ‘[[gmap:51 Franklin Street, Boston]]’

If you need special abbreviations just for a single Org buffer, you can define them in the
file with
#+LINK: bugzilla http://10.1.2.9/bugzilla/show_bug.cgi?id=
#+LINK: google http://www.google.com/search?q=%s
In-buffer completion (see Section 15.1 [Completion], page 228) can be used after ‘[’ to
complete link abbreviations. You may also define a Lisp function that implements special
(e.g., completion) support for inserting such a link with C-c C-l. Such a function should
not accept any arguments, and should return the full link with a prefix. You can set the
link completion function like this:
(org-link-set-parameter "type" :complete #'some-completion-function)
*** 4.8 Search Options in File Links 

[[file:~/code/main.c::255]}
[[file:~/xx.org::My Target]}
[[file:~/xx.org::*My Target]}
[[file:~/xx.org::#my-custom-id]}
[[file:~/xx.org::/regexp/]}
‘255’ Jump to line 255.
‘My Target’
Search for a link target ‘<<My Target>>’, or do a text search for ‘my target’,
similar to the search in internal links, see Section 4.2 [Internal Links], page 36.
In HTML export (see Section 12.9 [HTML Export], page 151), such a file link
becomes a HTML reference to the corresponding named anchor in the linked
file.
‘*My Target’
In an Org file, restrict search to headlines.
‘#my-custom-id’
Link to a heading with a ‘CUSTOM_ID’ property
‘/REGEXP/’
Do a regular expression search for REGEXP. This uses the Emacs command
occur to list all matches in a separate window. If the target file is in Org mode,
org-occur is used to create a sparse tree with the matches.

  As a degenerate case, a file link with an empty file name can be used to search the
current file. For example, ‘[[file:::find me]}’ does a search for ‘find me’ in the current
file, just as ‘[[find me]}’ would.
** сорс комады
*** для всех 
	C+c C+c
(setq org-confirm-babel-evaluate nil)
*** шелл 
 #+BEGIN_SRC sh :shcmd "cmdproxy.exe"
 dir
 #+END_SRC
 #+BEGIN_SRC sh :exports both
 ls
 #+END_SRC

 #+BEGIN_SRC sh :exports both
 ls
 #+END_SRC

*** translate 
**** пример 
  #+BEGIN_SRC translate
  Чтобы поймать психа нужен Псих
  #+END_SRC

  #+RESULTS:
	: To catch psycho Psycho needed

<t
<tr

**** Docs
***** Options
 Each block supports the following arguments:
 Argument	Description	Example	Default
****** :src	Source language.
  +BEGIN_SRC translate :src de	‘auto’ (for auto detection).
****** :dest	Destination language(s).
  +BEGIN_SRC translate :dest it,fr	‘en’ (for English).
  :dest may be a single country-code, or a comma-separated list.
****** All defaults are customizable 
  with M-x customize-group RET ob-translate.
*** Docs
**** 14.1 Structure of code blocks
https://www.gnu.org/software/emacs/manual/html_node/org/Structure-of-code-blocks.html#Structure-of-code-blocks
***** structure source code  : 
Org offers two ways to structure source code in Org documents: in a ‘src’ block, and directly inline. Both specifications are shown below.

A ‘src’ block conforms to this structure:

     #+NAME: <name>
     #+BEGIN_SRC <language> <switches> <header arguments>
       <body>
     #+END_SRC

		 
***** templates system : 
Org mode's templates system (see Easy templates) speeds up creating ‘src’ code blocks with just three keystrokes. Do not be put-off by having to remember the source block syntax. Org also works with other completion systems in Emacs, some of which predate Org and have custom domain-specific languages for defining templates. Regular use of templates reduces errors, increases accuracy, and maintains consistency.

An inline code block conforms to this structure:

     src_<language>{<body>}

or

     src_<language>[<header arguments>]{<body>}

***** Names the ‘src’ block : 
#+NAME: <name>
    Optional. Names the ‘src’ block so it can be called, like a function, from other ‘src’ blocks or inline blocks to evaluate or to capture the results. Code from other blocks, other files, and from table formulas (see The spreadsheet) can use the name to reference a ‘src’ block. This naming serves the same purpose as naming Org tables. Org mode requires unique names. For duplicate names, Org mode's behavior is undefined.
***** mark the start and end : 
#+BEGIN_SRC
#+END_SRC
    Mandatory. They mark the start and end of a block that Org requires. The #+BEGIN_SRC line takes additional arguments, as described next.
<language>
    Mandatory for live code blocks. It is the identifier of the source code language in the block. See Languages, for identifiers of supported languages.
<switches>
    Optional. Switches provide finer control of the code execution, export, and format (see the discussion of switches in Literal examples)
<header arguments>
    Optional. Heading arguments control many aspects of evaluation, export and tangling of code blocks (see Header arguments). Using Org's properties feature, header arguments can be selectively applied to the entire buffer or specific sub-trees of the Org document.
source code, header arguments
<body>
    Source code in the dialect of the specified language identifier. 
**** 14.8.2 Specific header arguments
https://www.gnu.org/software/emacs/manual/html_node/org/Specific-header-arguments.html#Specific-header-arguments
Org comes with many header arguments common to all languages. New header arguments are added for specific languages as they become available for use in ‘src’ code blocks. A header argument is specified with an initial colon followed by the argument's name in lowercase. Common header arguments are:

    var: Pass arguments to ‘src’ code blocks
    results: Specify results type; how to collect
    file: Specify a path for output file
    file-desc: Specify a description for file results
    file-ext: Specify an extension for file output
    output-dir: Specify a directory for output file
    dir: Specify the default directory for code block execution
    exports: Specify exporting code, results, both, none
    tangle: Toggle tangling; or specify file name
    mkdirp: Toggle for parent directory creation for target files during tangling
    comments: Toggle insertion of comments in tangled code files
    padline: Control insertion of padding lines in tangled code files
    no-expand: Turn off variable assignment and noweb expansion during tangling
    session: Preserve the state of code evaluation
    noweb: Toggle expansion of noweb references
    noweb-ref: Specify block's noweb reference resolution target
    noweb-sep: String to separate noweb references
    cache: Avoid re-evaluating unchanged code blocks
    sep: Delimiter for writing tabular results outside Org
    hlines: Handle horizontal lines in tables
    colnames: Handle column names in tables
    rownames: Handle row names in tables
    shebang: Make tangled files executable
    tangle-mode: Set permission of tangled files
    eval: Limit evaluation of specific code blocks
    wrap: Mark source block evaluation results
    post: Post processing of results of code block evaluation
    prologue: Text to prepend to body of code block
    epilogue: Text to append to body of code block 

For language-specific header arguments, see Languages. 

**** 14.10 Noweb reference syntax
https://www.gnu.org/software/emacs/manual/html_node/org/Noweb-reference-syntax.html#Noweb-reference-syntax
***** Org supports named blocks in Noweb style syntax.
For Noweb literate programming details, see http://www.cs.tufts.edu/~nr/noweb/).

			 <<code-block-name>>

	For the header argument :noweb yes, Org expands Noweb style references in the ‘src’ code block before evaluation.

	For the header argument :noweb no, Org does not expand Noweb style references in the ‘src’ code block before evaluation.

	The default is :noweb no. Org defaults to :noweb no so as not to cause errors in languages where Noweb syntax is ambiguous. Change Org's default to :noweb yes for languages where there is no risk of confusion.

	Org offers a more flexible way to resolve Noweb style references (see noweb-ref).

	Org can include the results of a code block rather than its body. To that effect, append parentheses, possibly including arguments, to the code block name, as show below.

			 <<code-block-name(optional arguments)>>

	Note that when using the above approach to a code block's results, the code block name set by #+NAME keyword is required; the reference set by :noweb-ref will not work.

 
***** example : 
 Here is an example that demonstrates how the exported content changes when Noweb style references are used with parentheses versus without.

 With:

			#+NAME: some-code
			#+BEGIN_SRC python :var num=0 :results output :exports none
			print(num*10)
			#+END_SRC

 this code block:

			#+BEGIN_SRC text :noweb yes
			<<some-code>>
			#+END_SRC

 expands to:

			print(num*10)

			
***** with parentheses : 
 Below, a similar Noweb style reference is used, but with parentheses, while setting a variable num to 10:

			#+BEGIN_SRC text :noweb yes
			<<some-code(num=10)>>
			#+END_SRC

 Note that now the expansion contains the results of the code block some-code, not the code block itself:

			100

 For faster tangling of large Org mode files, set org-babel-use-quick-and-dirty-noweb-expansion variable to t. The speedup comes at the expense of not correctly resolving inherited values of the :noweb-ref header argument. 
**** 14.11 Key bindings and useful functions
https://www.gnu.org/software/emacs/manual/html_node/org/Key-bindings-and-useful-functions.html#Key-bindings-and-useful-functions
Many common Org mode key sequences are re-bound depending on the context.
***** Active key bindings in code blocks:

 C-c C-c 	org-babel-execute-src-block
 C-c C-o 	org-babel-open-src-block-result
 M-<UP> 	org-babel-load-in-session
 M-<DOWN> 	org-babel-switch-to-session
***** Active key bindings in Org mode buffer:

	C-c C-v p or C-c C-v C-p 	org-babel-previous-src-block
	C-c C-v n or C-c C-v C-n 	org-babel-next-src-block
	C-c C-v e or C-c C-v C-e 	org-babel-execute-maybe
	C-c C-v o or C-c C-v C-o 	org-babel-open-src-block-result
	C-c C-v v or C-c C-v C-v 	org-babel-expand-src-block
	C-c C-v u or C-c C-v C-u 	org-babel-goto-src-block-head
	C-c C-v g or C-c C-v C-g 	org-babel-goto-named-src-block
	C-c C-v r or C-c C-v C-r 	org-babel-goto-named-result
	C-c C-v b or C-c C-v C-b 	org-babel-execute-buffer
	C-c C-v s or C-c C-v C-s 	org-babel-execute-subtree
	C-c C-v d or C-c C-v C-d 	org-babel-demarcate-block
	C-c C-v t or C-c C-v C-t 	org-babel-tangle
	C-c C-v f or C-c C-v C-f 	org-babel-tangle-file
	C-c C-v c or C-c C-v C-c 	org-babel-check-src-block
	C-c C-v j or C-c C-v C-j 	org-babel-insert-header-arg
	C-c C-v l or C-c C-v C-l 	org-babel-load-in-session
	C-c C-v i or C-c C-v C-i 	org-babel-lob-ingest
	C-c C-v I or C-c C-v C-I 	org-babel-view-src-block-info
	C-c C-v z or C-c C-v C-z 	org-babel-switch-to-session-with-code
	C-c C-v a or C-c C-v C-a 	org-babel-sha1-hash
	C-c C-v h or C-c C-v C-h 	org-babel-describe-bindings
	C-c C-v x or C-c C-v C-x 	org-babel-do-key-sequence-in-edit-buffer

** Faces : 
You may specify special faces for specific tags using the variable org-tag-faces, in
much the same way as you can for TODO keywords (see Faces for TODO
keywords). 
* Help Docs Gnus
  The Emacs news and email reader.
* Help Docs Mods 
** use-package
*** Getting started
;; This is only needed once, near the top of the file
(eval-when-compile
  ;; Following line is not needed if use-package.el is in ~/.emacs.d
  (add-to-list 'load-path "<path where use-package is installed>")
  (require 'use-package))

(use-package foo)
This loads in the package foo, but only if foo is available on your system. If not, a warning is logged to the *Messages* buffer.
*** :init :config
Use the :init keyword to execute code before a package is loaded. It accepts one or more forms, up to the next keyword:

(use-package foo
  :init
  (setq foo-variable t))
Similarly, :config can be used to execute code after a package is loaded. In cases where loading is done lazily (see more about autoloading below), this execution is deferred until after the autoload occurs:

(use-package foo
  :init
  (setq foo-variable t)
  :config
  (foo-mode 1))
As you might expect, you can use :init and :config together:

(use-package color-moccur
  :commands (isearch-moccur isearch-all)
  :bind (("M-s O" . moccur)
         :map isearch-mode-map
         ("M-o" . isearch-moccur)
         ("M-O" . isearch-moccur-all))
  :init
  (setq isearch-lazy-highlight t)
  :config
  (use-package moccur-edit))
In this case, I want to autoload the commands isearch-moccur and isearch-all from color-moccur.el, and bind keys both at the global level and within the isearch-mode-map (see next section). When the package is actually loaded (by using one of these commands), moccur-edit is also loaded, to allow editing of the moccur buffer.
*** Key-binding
Another common thing to do when loading a module is to bind a key to primary commands within that module:

(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))
This does two things: first, it creates an autoload for the ace-jump-mode command and defers loading of ace-jump-mode until you actually use it. Second, it binds the key C-. to that command. After loading, you can use M-x describe-personal-keybindings to see all such keybindings you've set throughout your .emacs file.

A more literal way to do the exact same thing is:

(use-package ace-jump-mode
  :commands ace-jump-mode
  :init
  (bind-key "C-." 'ace-jump-mode))
When you use the :commands keyword, it creates autoloads for those commands and defers loading of the module until they are used. Since the :init form is always run -- even if ace-jump-mode might not be on your system -- remember to restrict :init code to only what would succeed either way.

The :bind keyword takes either a cons or a list of conses:

(use-package hi-lock
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))
The :commands keyword likewise takes either a symbol or a list of symbols.

NOTE: inside strings, special keys like tab or F1-Fn have to be written inside angle brackets, e.g. "C-<up>". Standalone special keys (and some combinations) can be written in square brackets, e.g. [tab] instead of "<tab>". The syntax for the keybindings is similar to the "kbd" syntax: see https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-Rebinding.html for more information.

Examples:

(use-package helm
  :bind (("M-x" . helm-M-x)
         ("M-<f5>" . helm-find-files)
         ([f10] . helm-buffers-list)
         ([S-f10] . helm-recentf)))
Furthermore, remapping commands with :bind and bind-key works as expected, because when the binding is a vector, it is passed straight to define-key. So the following example will rebind M-q (originally fill-paragraph) to unfill-toggle:

(use-package unfill
  :bind ([remap fill-paragraph] . unfill-toggle))
*** Binding to keymaps
Normally :bind expects that commands are functions that will be autoloaded from the given package. However, this does not work if one of those commands is actually a keymap, since keymaps are not functions, and cannot be autoloaded using Emacs' autoload mechanism.

To handle this case, use-package offers a special, limited variant of :bind called :bind-keymap. The only difference is that the "commands" bound to by :bind-keymap must be keymaps defined in the package, rather than command functions. This is handled behind the scenes by generating custom code that loads the package containing the keymap, and then re-executes your keypress after the first load, to reinterpret that keypress as a prefix key.

For example:

(use-package projectile
  :bind-keymap
  ("C-c p" . projectile-command-map))
Binding within local keymaps

Slightly different from binding a key to a keymap, is binding a key within a local keymap that only exists after the package is loaded. use-package supports this with a :map modifier, taking the local keymap to bind to:

(use-package helm
  :bind (:map helm-command-map
         ("C-c h" . helm-execute-persistent-action)))
The effect of this statement is to wait until helm has loaded, and then to bind the key C-c h to helm-execute-persistent-action within Helm's local keymap, helm-mode-map.

Multiple uses of :map may be specified. Any binding occurring before the first use of :map are applied to the global keymap:

(use-package term
  :bind (("C-c t" . term)
         :map term-mode-map
         ("M-p" . term-send-up)
         ("M-n" . term-send-down)
         :map term-raw-map
         ("M-o" . other-window)
         ("M-p" . term-send-up)
         ("M-n" . term-send-down)))
*** Modes and interpreters
Similar to :bind, you can use :mode and :interpreter to establish a deferred binding within the auto-mode-alist and interpreter-mode-alist variables. The specifier to either keyword can be a cons cell, a list of cons cells, or a string or regexp:

(use-package ruby-mode
  :mode "\\.rb\\'"
  :interpreter "ruby")

;; The package is "python" but the mode is "python-mode":
(use-package python
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode))
If you aren't using :commands, :bind, :bind*, :bind-keymap, :bind-keymap*, :mode, :interpreter, or :hook (all of which imply :defer; see the docstring for use-package for a brief description of each), you can still defer loading with the :defer keyword:

(use-package ace-jump-mode
  :defer t
  :init
  (autoload 'ace-jump-mode "ace-jump-mode" nil t)
  (bind-key "C-." 'ace-jump-mode))
This does exactly the same thing as the following:

(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))
*** Magic handlers
Similar to :mode and :interpreter, you can also use :magic and :magic-fallback to cause certain function to be run if the beginning of a file matches a given regular expression. The difference between the two is that :magic-fallback has a lower priority than :mode. For example:

(use-package pdf-tools
  :load-path "site-lisp/pdf-tools/lisp"
  :magic ("%PDF" . pdf-view-mode)
  :config
  (pdf-tools-install :no-query))
This registers an autoloaded command for pdf-view-mode, defers loading of pdf-tools, and runs pdf-view-mode if the beginning of a buffer matches the string "%PDF".

*** Hooks
The :hook keyword allows adding functions onto hooks, here only the basename of the hook is required. Thus, all of the following are equivalent:

(use-package ace-jump-mode
  :hook prog-mode)

(use-package ace-jump-mode
  :hook (prog-mode . ace-jump-mode))

(use-package ace-jump-mode
  :commands ace-jump-mode
  :init
  (add-hook 'prog-mode-hook #'ace-jump-mode))
And likewise, when multiple hooks should be applied, the following are also equivalent:

(use-package ace-jump-mode
  :hook (prog-mode text-mode))

(use-package ace-jump-mode
  :hook ((prog-mode text-mode) . ace-jump-mode))

(use-package ace-jump-mode
  :hook ((prog-mode . ace-jump-mode)
         (text-mode . ace-jump-mode)))

(use-package ace-jump-mode
  :commands ace-jump-mode
  :init
  (add-hook 'prog-mode-hook #'ace-jump-mode)
  (add-hook 'text-mode-hook #'ace-jump-mode))
The use of :hook, as with :bind, :mode, :interpreter, etc., causes the functions being hooked to implicitly be read as :commands (meaning they will establish interactive autoload definitions for that module, if not already defined as functions), and so :defer t is also implied by :hook.
*** Conditional loading
**** :if
You can use the :if keyword to predicate the loading and initialization of modules.
For example, I only want edit-server running for my main, graphical Emacs, not for other Emacsen I may start at the command line:

(use-package edit-server
  :if window-system
  :init
  (add-hook 'after-init-hook 'server-start t)
  (add-hook 'after-init-hook 'edit-server-start t))
In another example, we can load things conditional on the operating system:

(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :ensure t
  :config
  (exec-path-from-shell-initialize))
**** :disable
The :disabled keyword can turn off a module you're having difficulties with, or stop loading something you're not using at the present time:

(use-package ess-site
  :disabled
  :commands R)
When byte-compiling your .emacs file, disabled declarations are omitted from the output entirely, to accelerate startup times.
**** :when
NOTE: :when is provided as an alias for :if, and :unless foo means the same thing as :if (not foo). For example, the following will also stop :ensure from happening on Mac systems:

(when (memq window-system '(mac ns))
  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize)))
Conditional loading before :preface

If you need to conditionalize a use-package form so that the condition occurs before even the :preface is executed, simply use when around the use-package form itself:
*** Loading packages in sequence
Sometimes it only makes sense to configure a package after another has been loaded, because certain variables or functions are not in scope until that time. This can achieved using an :after keyword that allows a fairly rich description of the exact conditions when loading should occur. Here is an example:

(use-package hydra
  :load-path "site-lisp/hydra")

(use-package ivy
  :load-path "site-lisp/swiper")

(use-package ivy-hydra
  :after (ivy hydra))
In this case, because all of these packages are demand-loaded in the order they occur, the use of :after is not strictly necessary. By using it, however, the above code becomes order-independent, without an implicit depedence on the nature of your init file.

By default, :after (foo bar) is the same as :after (:all foo bar), meaning that loading of the given package will not happen until both foo and bar have been loaded. Here are some of the other possibilities:

:after (foo bar)
:after (:all foo bar)
:after (:any foo bar)
:after (:all (:any foo bar) (:any baz quux))
:after (:any (:all foo bar) (:all baz quux))
When you nest selectors, such as (:any (:all foo bar) (:all baz quux)), it means that the package will be loaded when either both foo and bar have been loaded, or both baz and quux have been loaded.

NOTE: pay attention if you set use-package-always-defer to t, and also use the :after keyword, as you will need to specify how the declared package is to be loaded: e.g., by some :bind. If you're not using one of tho mechanisms that registers autoloads, such as :bind or :hook, and your package manager does not provide autoloads, it's possible that without adding :demand t to those declarations, your package will never be loaded.

*** Prevent loading if dependencies are missing

While the :after keyword delays loading until the dependencies are loaded, the somewhat simpler :requires keyword simply never loads the package if the dependencies are not available at the time the use-package declaration is encountered. By "available" in this context it means that foo is available if (featurep 'foo) evaluates to a non-nil value. For example:

(use-package abbrev
  :requires foo)
This is the same as:

(use-package abbrev
  :if (featurep 'foo))
As a convenience, a list of such packages may be specified:

(use-package abbrev
  :requires (foo bar baz))
For more complex logic, such as that supported by :after, simply use :if and the appropriate Lisp expression.
*** Gathering Statistics

If you'd like to see how many packages you've loaded, what stage of initialization they've reached, and how much aggregate time they've spent (roughly), you can enable use-package-compute-statistics after loading use-package but before any use-package forms, and then run the command M-x use-package-report to see the results. The buffer displayed is a tabulated list. You can use S in a column to sort the rows based on it.
*** (use-package-chords)
The :chords keyword allows you to define key-chord bindings for use-package declarations in the same manner as the :bind keyword.

To enable the extension:

(use-package use-package-chords
  :ensure t
  :config (key-chord-mode 1))
Then you can define your chord bindings in the same manner as :bind using a cons or a list of conses:

(use-package ace-jump-mode
  :chords (("jj" . ace-jump-char-mode)
           ("jk" . ace-jump-word-mode)
           ("jl" . ace-jump-line-mode)))
*** Some timing results
On my Retina iMac, the "Mac port" variant of Emacs 24.4 loads in 0.57s, with around 218 packages configured (nearly all of them lazy-loaded). However, I experience no loss of functionality, just a bit of latency when I'm first starting to use Emacs (due to the autoloading). Since I also use idle-loading for many packages, perceived latency is typically reduced overall.

On Linux, the same configuration loads in 0.32s.

If I don't use Emacs graphically, I can test the absolute minimum times. This is done by running:

time emacs -l init.elc -batch --eval '(message "Hello, world!")'
On the Mac I see an average of 0.36s for the same configuration, and on Linux 0.26s.
*** DONE use-package exempl
	CLOSED: [2019-09-13 Пт 05:52]
The easiest way is to install use-package.
(package-initialize)
(require 'package)
(add-to-list 'package-archives
    '("melpa" . "http://melpa.milkbox.net/packages/") t)
(dolist (package '(use-package))
   (unless (package-installed-p package)
       (package-install package)))
Then
 (use-package paredit
   :ensure t)
The :ensure t is what ensures that the package is installed.
To just load ensure multiple packages are install
(dolist (package '(package-a package-b package-c))
 (unless (package-installed-p package)
   (package-install package))
   (require package))))
*** :quelpa
https://github.com/quelpa/quelpa-use-package
**** instal
(use-package quelpa-use-package :ensure t)
**** cfg exempl link 
	(find-file-other-frame "~/INI/dev/unity-cfg.el")
**** use exempl github
		 #+begin_src emacs-lisp :tangle yes
(unless (package-installed-p 'miracle)
	(use-package miracle 
	;; :ensure t 
		:quelpa (miracle :fetcher github :repo "Saikyun/miracle")))
		 #+end_src
		Следим что название пакаджа совподает с название гепозитория
		и если используем репо то нет домена гит в конце
		помним что репозитории бываю и другие например просто гит
		есть возможность задать плный урл
		также следим что нет инсура иначе он будет устанавливать с задынх
репо игноря гелп - нужны спец команды чтоб исур использовал гелп(на сайте есть) 
		 #+begin_src emacs-lisp :tangle yes
(quelpa
'(miracle
	:fetcher github
	:url "https://github.com/saikyun/miracle.git"))
		 #+end_src
		 это пример для гилпа но допускаю что этот параметр в озможежен и
для юза
(use-package abc-mode :quelpa)
вообше для установки достаточно этого
он сам обо всё догадается и найдт
все пораметры для уточнения и указани конкретики
**** Installation
Requirements: Emacs 25.1
Assuming you have bootstrapped quelpa, install quelpa-use-package (which installs use-package as a dependency) and require the library:
(quelpa
 '(quelpa-use-package
   :fetcher git
   :url "https://github.com/quelpa/quelpa-use-package.git"))
(require 'quelpa-use-package)
**** Usage use package
After that it is possible to call use-package with the :quelpa keyword:
#+begin_src emacs-lisp :tangle yes

;; installs abc-mode with quelpa
(use-package abc-mode :quelpa)

;; does the same (`t' is optional)
(use-package abc-mode :quelpa t)

;; again... (if the package would have another name)
(use-package abc-mode :quelpa abc-mode)

;; passes upgrade parameter to quelpa
(use-package abc-mode :quelpa (:upgrade t))

;; uses the given recipe
(use-package abc-mode
  :quelpa (abc-mode :fetcher github :repo "mkjunker/abc-mode"))

;; recipe with plist arguments
(use-package abc-mode
  :quelpa ((abc-mode :fetcher github :repo "mkjunker/abc-mode") :upgrade t))
#+end_src
***** Using quelpa with :ensure
To make :ensure t use quelpa instead of package.el set the use-package-ensure-function in your init file:
(setq use-package-ensure-function 'quelpa)
After that:
(use-package abc-mode :ensure t)
will install abc-mode with quelpa.
And if you enable use-package-always-ensure:
(setq use-package-always-ensure t)
then
(use-package abc-mode)
will install abc-mode with quelpa.
***** Conditional execution
Note that the :quelpa keyword is inserted after :if, :when, :unless and :requires so that you can make the installation of a package depend on some requirement, for example:
(use-package magit-filenotify
  :when (fboundp 'file-notify-add-watch)
  :quelpa (magit-filenotify :fetcher github :repo "magit/magit-filenotify")
In this case magit-filenotify is only installed if the function file-notify-add-watch is bound.
Likewise you can use :requires to make the installation depend on a feature being available:
(use-package magit-filenotify
  :requires filenotify
  :quelpa (magit-filenotify :fetcher github :repo "magit/magit-filenotify"))
***** Overriding use-package-always-ensure
To install some packages with quelpa but use use-package-always-ensure to install all others from an ELPA repo :ensure needs to be disabled if the :quelpa keyword is found.
quelpa-use-package provides an advice for this purpose which can be activated thus:
(quelpa-use-package-activate-advice)
To disable it again you can use:
(quelpa-use-package-deactivate-advice)
**** use quelpa : 
(quelpa '(hydra :repo "abo-abo/hydra" :fetcher github))

** hidra mod 
    https://github.com/abo-abo/hydra
This is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common prefix - a Hydra.
** yasnippet
*** Path to my snipets 
cd D:\Development\lisp\HOME\.emacs.d\snippets\python-mode 
*** Path to lib snipets 
cd D:\Development\lisp\HOME\.emacs.d\elpa\yasnippet-snippets-20200122.1140\snippets 
*** doc 
**** my
		 снипеты из твоей папки переписывают орегиналые
		 если уних совподают имен
		 снипеты подгрухаются вместе емаком
		 и невкурсе если они сменились
		 по команда из меню all - a  
yas-reload-all переподгружает их
**** manual
[[http://joaotavora.github.io/yasnippet/][Yet another snippet extension]]
***** Expanding
****** Inserting region or register contents into snippet
It's often useful to inject already written text in the middle of a snippet. The variable
[[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-wrap-around-region][yas-wrap-around-region]] when to t substitute the region contents into the $0
placeholder of a snippet expanded by [[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-insert-snippet][yas-insert-snippet]]. Setting it to a character
value (e.g. ?0) will insert the contents of corresponding register. 

Older (versions 0.9.1 and below) of Yasnippet, supported a setting of cua that is
equivalent to ?0 but only worked with cua-mode turned on. This setting is still
supported for backwards compatibility, but is now entirely equivalent to ?0. 
***** Writing snippets 
http://joaotavora.github.io/yasnippet/snippet-development.html
****** Mirrors 
We refer the tab stops with placeholders as a field. A field can have mirrors. All
mirrors get updated whenever you update any field text. Here's an example: 

\begin{${1:enumerate}}
    $0
\end{$1}

When you type "document" at ${1:enumerate}, the word "document" will also be
inserted at \end{$1}. The best explanation is to see the screencast([[http://www.youtube.com/watch?v=vOj7btx3ATg][YouTube]] or [[http://yasnippet.googlecode.com/files/yasnippet.avi][avi]]
[[http://yasnippet.googlecode.com/files/yasnippet.avi][video]]). 

The tab stops with the same number to the field act as its mirrors. If none of the tab
stops has an initial value, the first one is selected as the field and others mirrors. 
****** Mirrors with transformations 

If the value of an ${n:-construct starts with and contains $(, then it is interpreted as a
mirror for field n with a transformation. The mirror's text content is calculated according
to this transformation, which is Emacs-lisp code that gets evaluated in an environment
where the variable [[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-text][yas-text]] is bound to the text content (string) contained in the field n.
Here's an example for Objective-C: 

- (${1:id})${2:foo}
{
    return $2;
}

- (void)set${2:$(capitalize yas-text)}:($1)aValue
{
    [$2 autorelease];
    $2 = [aValue retain];
}
$0

Look at ${2:$(capitalize yas-text)}, it is a mirror with transformation instead of a field.
The actual field is at the first line: ${2:foo}. When you type text in ${2:foo}, the
transformation will be evaluated and the result will be placed there as the transformed
text. So in this example, if you type "baz" in the field, the transformed text will be
"Baz". This example is also available in the screencast. 

Another example is for rst-mode. In reStructuredText, the document title can be some
text surrounded by "=" below and above. The "=" should be at least as long as the
text. So 

=====
Title
=====

is a valid title but 

===
Title
===

is not. Here's an snippet for rst title: 

${1:$(make-string (string-width yas-text) ?\=)}
${1:Title}
${1:$(make-string (string-width yas-text) ?\=)}

$0

Note that a mirror with a transform is not restricted to the text of the field it is mirroring.
By making use of [[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-field-value][yas-field-value]], a mirror can look at any of the snippet's field (as
mentioned above, all mirrors are updated when any field is updated). Here is an
example which shows a "live" result of calling format: 

(format "${1:formatted %s}" "${2:value}")
=> "${1:$(ignore-errors (format (yas-field-value 1) (yas-field-value 2)))}"

To keep the example simple, it uses ignore-errors to suppress errors due to
incomplete format codes. 

****** Fields with transformations

From version 0.6 on, you can also have lisp transformation inside fields. These work
mostly like mirror transformations. However, they are evaluated when you first enter the
field, after each change you make to the field and also just before you exit the field. 

The syntax is also a tiny bit different, so that the parser can distinguish between fields
and mirrors. In the following example 


#define "${1:mydefine$(upcase yas-text)}"

mydefine gets automatically upcased to MYDEFINE once you enter the field. As you
type text, it gets filtered through the transformation every time. 

Note that to tell this kind of expression from a mirror with a transformation, YASnippet
needs extra text between the : and the transformation's $. If you don't want this
extra-text, you can use two $'s instead. 


#define "${1:$$(upcase yas-text)}"

Please note that as soon as a transformation takes place, it changes the value of the
field and sets it its internal modification state to true. As a consequence, the
auto-deletion behaviour of normal fields does not take place. This is by design. 

****** Choosing fields value from a list and other tricks

As mentioned, the field transformation is invoked just after you enter the field, and with
some useful variables bound, notably [[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-modified-p][yas-modified-p]] and [[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-moving-away-p][yas-moving-away-p]].
Because of this feature you can place a transformation in the primary field that lets you
select default values for it. 

The [[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-choose-value][yas-choose-value]] does this work for you. For example: 

<div align="${2:$$(yas-choose-value '("right" "center" "left"))}">
  $0
</div>

See the definition of [[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-choose-value][yas-choose-value]] to see how it was written using the two
variables. 

Here's another use, for LaTeX-mode, which calls reftex-label just as you enter snippet
field 2. This one makes use of [[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-modified-p][yas-modified-p]] directly. 

\section{${1:"Titel der Tour"}}%
\index{$1}%
\label{{2:"waiting for reftex-label call..."$(unless yas-modified-p (reftex-label nil 'dont-
insert))}}%

The function [[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-verify-value][yas-verify-value]] has another neat trick, and makes use of
[[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-moving-away-p][yas-moving-away-p]]. Try it and see! Also, check out this [[http://groups.google.com/group/smart-snippet/browse_thread/thread/282a90a118e1b662][thread]] 

****** Nested placeholder fields

From version 0.6 on, you can also have nested placeholders of the type: 

<div${1: id="${2:some_id}"}>$0</div>

This allows you to choose if you want to give this div an id attribute. If you tab forward
after expanding, it will let you change "some\id" to whatever you like. Alternatively, you
can just press C-d (which executes [[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-skip-and-clear-or-delete-char][yas-skip-and-clear-or-delete-char]]) and go straight
to the exit marker. 

By the way, C-d will only clear the field if you cursor is at the beginning of the field and
it hasn't been changed yet. Otherwise, it performs the normal Emacs delete-char
command. 

****** Indentation markers

If [[http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-indent-line][yas-indent-line]] is not set to 'auto, it's still possible to indent specific lines by adding
an indentation marker, $>, somewhere on the line. 


***** Organizing snippets 
http://joaotavora.github.io/yasnippet/snippet-organization.html	
***** Reference
http://joaotavora.github.io/yasnippet/snippet-reference.html#yas-wrap-around-region

** WindMove & FrameMove 
https://truthseekers.io/lessons/an-introduction-to-emacs-everything-you-need-to-know-to-get-started/
;; Remap windmove keys to home keys
(global-set-key (kbd "M-h") 'windmove-left)
(global-set-key (kbd "M-j") 'windmove-down)
(global-set-key (kbd "M-k") 'windmove-up)
(global-set-key (kbd "M-l") 'windmove-right)
** Org-brain
*** help
https://github.com/Kungsgeten/org-brain
**** help on keys
***** SVG Imageorg-brain-visualize
The primary usage of org-brain is through M-x org-brain-visualize (which you might
want to bind to a key). From there you can browse entries, add/remove
relationships, open entries for editing etc. The following keybindings are available in
org-brain-visualize:
***** Key  Command  Description : 
 Key  Command  Description  
 m  org-brain-visualize-mind-map  Toggle between normal and  
		 mind-map visualization.  
 j or TAB  forward-button  Goto next link  
 k or S-TAB  backward-button  Goto previous link  
 b  org-brain-visualize-back  Like the back button in a web  
		 browser.  
 h or *  org-brain-add-child-headline *  Add a new child headline to  
		 entry  
 c  org-brain-add-child *  Add an existing entry, or a new  
		 file, as a child  
 C  org-brain-remove-child *  Remove one the entry’s child  
		 relations  
 e  org-brain-annotate-edge  Annotate the connection  
		 between the visualized entry  
		 and the entry link at point.  
 p  org-brain-add-parent *  Add an existing entry, or a new  
		 file, as a parent  
 P  org-brain-remove-parent *  Remove one of the entry’s  
		 parent relations  
 f  org-brain-add-friendship *  Add an existing entry, or a new  
		 file, as a friend  
 F  org-brain-remove-friendship *  Remove one of the entry’s  
		 friend relations  
 n  org-brain-pin *  Toggle if the entry is pinned  
		 or not  
 N  org-brain-add-nickname  Add a nickname for the entry  
		 (you can have several names  
		 for the same entry)  
 s  org-brain-select-dwim  Select an entry for batch  
		 processing.  
 S  org-brain-select-map  Prefix key to do batch  
		 processing with selected  
		 entries.  
 t  org-brain-set-title  Change the title of the entry.  
 T  org-brain-set-tags  Change the tags of the entry.  
 d  org-brain-delete-entry  Choose an entry to delete.  
 l  org-brain-visualize-add-resource  Add a new resource link in  
		 entry  
 r  org-brain-open-resource  Choose and open a resource  
		 from the entry.  
 C-y  org-brain-visualize-paste-resource  Add a new resource link from  
		 clipboard  
 a  org-brain-visualize-attach  Run org-attach on entry  
		 (headline entries only)  
 A  org-brain-archive  Archive the entry (headline  
		 entries only)  
 o  org-brain-goto-current  Open current entry for editing  
 O  org-brain-goto  Choose and edit one of your  
		 org-brain entries  
 v  org-brain-visualize  Choose and visualize a  
		 different entry  
 V  org-brain-visualize-follow  Similar to  
		 org-agenda-follow-mode; view  
		 visualized entry in another  
		 window.  
 w  org-brain-visualize-random  Visualize one of your entries  
		 at random.  
 W  org-brain-visualize-wander  Visualize at random, in a set  
		 interval. W again to cancel.  
 C-c C-x C-v  org-toggle-inline-images  Display org-mode images in  
		 the entry text.  
 M  Move prefix  Move (refile) the current entry.  
 M r  org-brain-refile  Move current entry to another  
		 entry (change local parent).  
 M p  org-brain-change-local-parent  Choose among the entry’s  
		 parents and make another of  
		 them the local parent.  

The commands above marked with * can be run with the universal argument C-u in
order to operate on the entry link at point instead of the visualized entry.

You may use org-store-link inside of org-brain-visualize in order to store a link to the
currently visualized org-brain entry.
***** universal argument C-u : 
If the universal argument C-u is used when running org-brain-visualize-random or
org-brain-visualize-wander, the randomized targets are restricted to descendants
(children, grandchildren, grand-grandchildren etc) of the currently visualized entry.
Use for instance C-u W to wander among the descendants.

The universal argument C-u can also be used with org-brain-open-resource. This
lets you choose not only resource from the visualized entry, but also from
descendants (children, grand-children, etc) of that entry.

If the universal argument C-u is used when calling org-brain-annotate-edge then the
annotation will be “one-way”. The default behaviour is otherwise to annotate the
connection in both directions.

***** toggle by Zooming : 
When using the mind map visualization (toggle by pressing m), you can use the
following keybindings in order to show or hide successive levels of hierarchy relative
to the current entry.

 Key  Command  Description  
 +  org-brain-show-descendant-level  Show one more level of entries to the  
		 right (children of children, etc.)  
 -  org-brain-hide-descendant-level  Hide rightmost level of descendant  
		 entries  
 z  org-brain-show-ancestor-level  Show one more level of entries to the  
		 left (parents of parents, etc.)  
 Z  org-brain-hide-ancestor-level  Hide leftmost level of ancestor entries  

***** batch processing : 
If you want to select several entries and then remove/add them as
children/parents/friends you can use the s key (org-brain-select-dwim) to select an
entry. If the point is over a button link to an entry, that entry will be selected, otherwise
it will select the currently visualized entry. If the entry is already selected, it will be
unselected instead.

Once you have selected all the entries you wish to use, you can use the S prefix key
to do batch processing on the selected entries. The keybindings in this prefix keymap
is identical to those in org-brain-visualize. You could for instance use S c to add all
selected entries as children to the visualized entry, or S P to remove the parent
relationship of the selected entries. When you’re done and wish to clear the selection
use org-brain-clear-selected, which is bound to S s.
**** ID
***** M-x org-brain-update-id-locations
			Удобно в ручную можно удалить любые айди
потом запустить эту команду и он удалит эти айди из списка
поскольку сам фали содержит пути к файлам
и как результат если в файле больше нет айди
он удаляет его из файла-списка
org-brain use org-id in order to speed things up. Because of this, the variable org-id-track-globally should be t (which it already is by default). You may want to modify org-id-locations-file too. If you add entries to org-brain directly from org-mode you must assign headliens an ID. A comfortable way to do this is with the command org-brain-ensure-ids-in-buffer. Even more comfortable is to add that to before-save-hook, so that it runs when saving.
If you find that org-brain is missing entries, or list entries which doesn’t exist, try using M-x org-brain-update-id-locations, which syncs the org-brain entries with the org-id caching system.
****** exempl
 (setq org-id-track-globally t)
  (setq org-id-locations-file "~/.emacs.d/.org-id-locations")
  (add-hook 'before-save-hook #'org-brain-ensure-ids-in-buffer)
***** M-x org-brain-headline-to-file. : 
If you have a headline entry, which you want to convert to a file entry, use M-x org-brain-headline-to-file. Unfortunately there is currently no function to convert a file entry into a headline entry.
***** M-x org-brain-get-id
You can edit org-brain entries directly from org-mode. You can use the default org-mode outline structure to define parent/children relationships, but keep in mind that only entries with an ID property will be considered as entries to org-brain; use M-x org-brain-get-id to create an ID property to the current org-mode headline. Another alternative is to use M-x org-brain-refile which will create the ids for you. You can also create IDs for all headlines in the buffer with M-x org-brain-ensure-ids-in-buffer, and you might find it useful to add this to before-save-hook.
**** From ORG-MODE 
***** org-brain-prefix-map
Most of the commands available in org-brain-visualize-mode is also bound to the prefix keymap org-brain-prefix-map. You can bind this to a key in org-mode, for instance C-c b, and you could then type C-c b p to add a parent to the current entry. Example config: (define-key org-mode-map (kbd "C-c b") 'org-brain-prefix-map).
***** org-brain-add-entry
You could also use M-x org-brain-add-entry if you do not want to visualize the new entry. Also commands which add children, parents and friends, or links to entries, can create new entries in the same way. Se General information below.
***** org-brain-add-child : 
Most of the commands available in org-brain-visualize can also be used in org-mode directly, in which case they will operate on the “entry at point”. In other words you can use M-x org-brain-add-child directly from org-mode in order to add a child to the org-brain entry at point. 
***** org-brain-goto-<relationsship> : 
You may also want to use the commands org-brain-goto-<relationsship> to navigate between entries.
***** headline convert to file: 
If you have a headline entry, which you want to convert to a file entry, use M-x
org-brain-headline-to-file. Unfortunately there is currently no function to convert a file
entry into a headline entry.
***** Editing from org-mode
 You can edit org-brain entries directly from org-mode. You can use the default
 org-mode outline structure to define parent/children relationships, but keep in mind
 that only entries with an ID property will be considered as entries to org-brain; use
 M-x org-brain-get-id to create an ID property to the current org-mode headline.
 Another alternative is to use M-x org-brain-refile which will create the ids for you. You
 can also create IDs for all headlines in the buffer with M-x
 org-brain-ensure-ids-in-buffer, and you might find it useful to add this to
 before-save-hook.

 Most of the commands available in org-brain-visualize can also be used in org-mode
 directly, in which case they will operate on the “entry at point”. In other words you can
 use M-x org-brain-add-child directly from org-mode in order to add a child to the
 org-brain entry at point. You may also want to use the commands
 org-brain-goto-<relationsship> to navigate between entries.

 Most of the commands available in org-brain-visualize-mode is also bound to the
 prefix keymap org-brain-prefix-map. You can bind this to a key in org-mode, for
 instance C-c b, and you could then type C-c b p to add a parent to the current entry.
 Example config: (define-key org-mode-map (kbd "C-c b") 'org-brain-prefix-map).

 You may want to create a link to an org-brain entry in an org-mode file (not
 necessarily an org-brain file itself). org-brain provides several link types for this
 purpose. You can use org-insert-link (bound to C-c C-l in org-mode by default) to
 insert one of these links. They all have in common that they, when clicked, will open
 the org-brain entry for editing. When inserting a link like this, org-brain will run
 completion upon all your entries.

****** brain:
	 The default kind of link. Just let’s you visit another org-brain entry when clicked.
	 If the variable org-brain-backlink is t a brain-link will also be created as a
	 resource in the link target, linking back to where the link was created. If
	 org-brain-backlink is set to a string, that string will be added as a prefix to the
	 title of the backlink. Example: You set org-brain-backlink to =”<– “= and create
	 a brain: link in Rabbits linking to Carrots. Now a resource with the description
	 <-- Rabbits will be created in Carrots. 
****** brain-child:
	 When inserted using org-insert-link this will make the linked entry a child to the
	 current org-brain entry, upon completion. Keep in mind that this doesn’t work if
	 you type the link manually; only by completion through org-insert-link. 
****** brain-parent:
	 Like brain-child: but makes the linked entry a parent of the current entry. 
******  brain-friend:
	 Like brain-child: but adds the linked entry as a friend. 
******  brainswitch
	 If you have multiple brains you may want a link which switches to a specific brain
	 and one of its entries. The brainswitch link allows for this. 
****** inserting links : 
	The names of the relationship inserting links (brain-child, brain-parent and
	brain-friend) can be customized with the variables org-brain-child-link-name,
	org-brain-parent-link-name, and org-brain-friend-link-name. This customization
	should be done before loading org-brain. If you’re using use-package, put the
	customization in the :init block.
**** Renaming files in org-brain
Headline entries use org-id to identify themselves, so the headlines can be manually renamed without worries. File entries, on the other hand, uses the filename as the identifier. This will cause problems if you try to manually rename files inside of org-brain.

In order to rename a file, use M-x org-brain-rename-file.
**** Special tags
You might have a headline which you do not really want as an entry in org-brain. The most basic way to exclude such a headline is simply to not add an ID property to it. However, org-brain also provide two tags, which you can use to tag the headline:
***** :nobrain:
This tag excludes the headline, and its subheadings, from your org-brain entries. You can change the tag name by modifying org-brain-exclude-tree-tag.
***** :childless:
This tag does not exclude the headline, but it excludes the subheadings. You can change the tag name by modifying org-brain-exclude-children-tag. Works on file entries.
The following tags modifies the kind of information that is shown when an entry is visualized:

***** :notext:
Do not show the entry’s text in org-brain-visualize. You can change the tag name by modifying org-brain-exclude-text-tag.
***** :resourceless:
Do not show the entry’s resources in org-brain-visualize. You can change the tag name by modifying org-brain-exclude-resources-tag.
***** :showchildren:
By default local child entries aren’t shown as text. By setting this tag the entry get the entire subtree as text. You can change the tag name by modifying org-brain-show-children-tag. Works on file entries.
***** :nosiblings:
You may have an entry with lots of children, and when you visualize one of these children you might not want to see the siblings from this parent. A good example would be if you have an index entry or similar. By tagging the parent with nosiblings the parent’s children will not show siblings from that parent. You can change the tag name by modifying org-brain-exclude-siblings-tag.
***** :nolocalparent:
This is similar to :nosiblings: but the tagged parent will not be shown at all when one of its local children are visualized.
The following tags modify the way how information is shown when an entry is visualized.
***** :ownline:
Make each child of the tagged entry appear on its own line when the tagged entry is visualized. This only affects the tagged entry. It works akin to temporarily setting org-brain-child-fill-column-sexp to 0.
***** :nosort:
Display each child of the tagged node in the order the children are listed in the file, rather than in the sorted order determined by org-brain-visualize-sort-function. This affects the order of the node’s children in both the child list (when the tagged node is being visited) and in the sibling list (when one of the tagged node’s children is being visited).
**** Having multiple brains
You can have multiple brains simply by having more than one brain folder. In this way, each folder becomes a separate brain. You can switch between these using M-x org-brain-switch-brain. You can also use brainswitch: links in org-mode to switch brains.

If you run org-brain-visualize from inside an org-file in the root of an org-brain directory, org-brain will automatically switch to this brain.
**** Customizing the look of entry titles
When visualizing you might want to see additional information about the entries. This
can be done by customizing the following variables:

 org-brain-vis-title-prepend-functions
 org-brain-vis-title-append-functions
 org-brain-vis-current-title-prepend-functions
 org-brain-vis-current-title-append-functions

Each of these variables should be a list of functions, which all takes an entry as the
single parameter and returns a string. This string is the prepended or appended to
the entry’s title, according to the name of the function. The variables with the name
current in them only applies the functions on the currently visualized entry (the focused
one).

Suitable functions to add to these lists might be:

 org-brain-entry-icon (included in org-brain-vis-title-prepend-functions by default)
 org-brain-entry-todo-state
 org-brain-entry-tags-string
** Evil
*** insert mod
**** tab
If you are using Evil anyways, you can use C-t and C-d to increase/decrease indent at the start of the line.

** org-eww
When this module is active `org-store-link' (often on key C-c l) in
a eww buffer stores a link to the current url of the eww buffer.

In an eww buffer function `org-eww-copy-for-org-mode' kills either
a region or the whole buffer if no region is set and transforms the
text on the fly so that it can be pasted into an org-mode buffer
with hot links.
** company-mode 
*** keys
Completion will start automatically after you type a few letters. Use M-n and M-p to select, <return> to complete or <tab> to complete the common part. Search through the completions with C-s, C-r and C-o. Press M-(digit) to quickly complete with one of the first 10 candidates.

Type M-x company-complete to initiate completion manually. Bind this command to a key combination of your choice.

When the completion candidates are shown, press <f1> to display the documentation for the selected candidate, or C-w to see its source. Not all back-ends support this.
*** backends
To see or change the list of enabled back-ends, type M-x customize-variable RET company-backends. Also see its description for information on writing a back-end.

For information on specific back-ends, also check out the comments inside the respective files.

For more information, type M-x describe-function RET company-mode.

To customize other aspects of its behavior, type M-x customize-group RET company
*** completion-styles
**** exempls
(setq completion-styles '(partial-completion substring emacs22))
**** completion-styles’ begins with ‘basic’ by default : 
 <…> I want to complete ‘eval-when-compile’ and I know there are several functions beginning with ‘eval’, but there are fewer which have ‘when’ in their names. So I type ‘when’ and company lists ‘eval-when-compile’ too among others with ‘when’ in the name.

Similarly to iswitchb. Iswitchb is great, because I don’t have to type the beginning of the buffer name, I can type any part of it.

<…> Better yet: obey ‘completion-styles’, so the user can choose between ‘prefix’, ‘substring’, ‘partial-completion’, or any other style she likes.
    Note that ‘completion-styles’ begins with ‘basic’ by default, and all styles are tried in turn. So unless you customize this variable, if you just type ‘when’, you won’t get ‘eval-when-compile’ among the candidates. You’ll have to input a prefix that doesn’t have any matches when using the ‘basic’ style.

*** You can start completion with an empty prefix : 
The search feature was actually inspired by the way I use iswitchb. You can start completion with an empty prefix, type C-s, search for “when”, and press C-o to limit the search. – nschum

I’ve written another command named ‘company-filter-candidates’ that will probably be (edit: is) in version 0.2. It works like automatically pressing C-o after every search char. The search still has to be started manually (i.e. one key stroke).

*** customize  company : 
		Получить инфу по всем переменным
M-x 
customize-group 
RET 
company. 

