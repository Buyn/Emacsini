#-*- mode: org -*-
#+STARTUP: overview 
#+TODO: TODO DONE
* Welcom! Don`t panic!
 _   _   _             _   _   _
| |_| |_| |           | |_| |_| |
 \ _____ /      o_     \ _____ /
  |     |       |_|     |     |
  |  |  |       |       |  |  |
  |   _ } _   _ | _   _ { _   |
  |  | |_| |_| ||| |_| |_| |  |
  |  |                     |  |
  || |                     | ||
  |  |        _____        |  |
  |  |       /_|_|_\       |  |
  |  |      /|_|_|_|\      |  |
  |  |      ||_|_|_||      |  |
  |  |      ||_|_|_||      |  |
  |__|      ||_|_|_||      |__|
 /   |      ||_|_|_||      |   \
=================================
* Pathes
** org files
*** lincks
[[file:~/../Dropbox/orgs/weekly.org][weekly file]]
[[file:~/../Dropbox/orgs/todo_plan.org][ToDo Plan org]]
[[file:~/../Dropbox/orgs/monthly.org][Monthly file]]
[[file:GTD.org][GTD file]]
[[file:today.org][Today org file]]
[[file:~/ORG/gtd/inbox.org][Inbox GTD File]]
[[file:~/ORG/gtd/tickler.org][Tikler Todo File]]

*** main todos
(find-file "D:/Development/lisp/Dropbox/orgs/weekly.org")
(find-file "~/../Dropbox/orgs/todo_main.org")
(find-file "~/../Dropbox/orgs/todo_plan.org")
(find-file "~/../Dropbox/orgs/todo_LongRun.org")

*** uptown todos
файлы для Вышгорода
(find-file "~/../Dropbox/orgs/uptown/todo_rasps.org")

*** gts 
(find-file "~/ORG/gtd/gtd.org")
(find-file "~/ORG/gtd/inbox.org")
(find-file "~/ORG/gtd/tickler.org")
** init files
(find-file "~/.emacs")
	(find-file "~/INI/init.el")
*** vanila
(find-file "~/INI/inpak.el")
(find-file "~/INI/vanila_cfg.el")
*** Evil
(find-file "~/INI/evil-mod-cfg.el")
	(find-file "~/ELs/Evil/evil-respect-input.el")
	(find-file "~/ELs/Evil/onecharadd.el")
	(find-file "~/ELs/Evil/copylines.el") пока нет
*** Orgs
(find-file "~/INI/org-cfg.el")
	(find-file "~/INI/org_agend_cfg.el")
	(find-file "~/INI/babel-cfg.el")
	(find-file "~/ELs/Org/Babel/ob-eshell.el")
*** Folding
(find-file "~/INI/folding-cfg.el")
	(find-file "~/INI/origami_cfg.el") not using
	но содержит в себе огромное количество класных решенией
	которые нужно перенести в outshine-mod
		(find-file "~/ELs/Evil/origami_triplebrase.el")
	(find-file "~/INI/outshine_cfg.el")
*** Other 
(find-file "~/INI/frame-control.el")
(find-file "~/INI/advnsed-selections-cfg.el")
(find-file "~/INI/interface-mods.el")
(find-file "~/INI/hydra-cfg.el")
*** literary 
(find-file "~/INI/lit-cfg.el") not et
	(find-file "~/INI/translate-cfg.el") not et
	(find-file "~/INI/grammer-cfg.el") not et
*** Programing
(find-file "~/INI/dev-cfg.el")
	(find-file "~/INI/autocomplete-cfg.el")
	(find-file "~/INI/snippets-cfg.el")
	(find-file "~/INI/delimiters-cfg.el")
	(find-file "~/INI/js-cfg.el") not used
	(find-file "~/INI/lua-cfg.el")
	(find-file "~/INI/python-cfg.el") load flycheck
	(find-file "~/INI/c-mode-cfg.el") not used
** exempl
(find-file "~/../hi.txt")
*Help Docs Emacs 
* Команды
** reload init files
(load "~/INI/evil-mod-cfg.el")
(load "~/INI/frame-control.el")
(load "~/INI/vanila_cfg.el")
(load "~/INI/origami_cfg.el")
(load "~/INI/folding-cfg.el")
(load "~/INI/org-cfg.el")
(load "~/INI/lit-cfg.el")
(load "~/INI/dev-cfg.el")
(load "~/INI/hydra-cfg.el")
** открыть
(find-file-other-frame "d:/My_Docs/Ofice/PaperFlow/TODO/todo.org")
(org-agenda nil "a")

** линкс команды
   C+c C+o
	[[shell:echo%20"hi%20Max"][Hello?]]
	[[shell:dir][Whera are u?]]
[[
shell:echo "dfgdfg max"
] [
Working?
]]
[[shell:echo "dfgdfg max"][Working?]]

[[shell:echo "dfgdfg max"]
[Working?]]
** сорс комады
*** для всех 
	C+c C+c
(setq org-confirm-babel-evaluate nil)
*** шелл 
 #+BEGIN_SRC sh :shcmd "cmdproxy.exe"
 dir
 #+END_SRC
 #+BEGIN_SRC sh :exports both
 ls
 #+END_SRC

 #+BEGIN_SRC sh :exports both
 ls
 #+END_SRC

*** translate 
**** пример 
  #+BEGIN_SRC translate
  Чтобы поймать психа нужен Псих
  #+END_SRC

  #+RESULTS:
  : To catch psycho Psycho needed

<t

**** Docs
***** Options
 Each block supports the following arguments:
 Argument	Description	Example	Default
****** :src	Source language.
  +BEGIN_SRC translate :src de	‘auto’ (for auto detection).
****** :dest	Destination language(s).
  +BEGIN_SRC translate :dest it,fr	‘en’ (for English).
  :dest may be a single country-code, or a comma-separated list.
****** All defaults are customizable 
  with M-x customize-group RET ob-translate.
** Install
tar not found when trying to install from melpa 
You probably have an outdated package database
(package-refresh-contents)
(package-install company-irony)
** setings
*** systems paths
(setq exec-path (append exec-path '("D:/Development/CPP/CMake/bin/")))
	неменяет системную переменую только переменая емака взятая при запуске
(setenv "PATH" (concat (getenv "PATH") ";c:\\sw\\bin"))
(setq exec-path (append exec-path '("d:/sw/bin")))
	;; example of setting env var named “path”, by appending a new path to existing path

(setenv "PATH"
  (concat
   "C:/cygwin/usr/local/bin" ";"
   "C:/cygwin/usr/bin" ";"
   "C:/cygwin/bin" ";"
   (getenv "PATH")
  )
)
    You can use slash / and you don't have to use backslash \.
    Dir path may end with a path separator /, or without.
    the builtin variable path-separator can be used instead of ;.
;; show env var named path
(getenv "PATH")
*** for Source
(origami-mode)
(outline-minor-mode)
** ielm 
* Help Docs Emacs 
** Keyborde help 
*** evaluate
****    27.9 Evaluating Emacs Lisp Expressions
Emacs Lisp mode is the major mode for editing Emacs Lisp. Its mode command is M-x emacs-lisp-mode.
Emacs provides several commands for evaluating Emacs Lisp expressions. You can use these commands in Emacs Lisp mode, to test your Emacs Lisp code as it is being written. For example, after re-writing a function, you can evaluate the function definition to make it take effect for subsequent function calls. These commands are also available globally, and can be used outside Emacs Lisp mode.
M-:
    Read a single Emacs Lisp expression in the minibuffer, evaluate it, and print the value in the echo area (eval-expression).
~C-x C-e~
    Evaluate the Emacs Lisp expression ~before point~, and print the value in the echo area (eval-last-sexp).
~C-M-x (in Emacs Lisp mode)~
~M-x eval-defun~
    Evaluate the defun containing or after point, and print the value in the echo area (eval-defun).
~M-x eval-region~
    Evaluate all the Emacs Lisp expressions in the region.
~M-x eval-buffer~
    Evaluate all the Emacs Lisp expressions in the buffer. 

M-: (eval-expression) reads an expression using the minibuffer, and evaluates it. (Before evaluating the expression, the current buffer switches back to the buffer that was current when you typed M-:, not the minibuffer into which you typed the expression.)

The command C-x C-e (eval-last-sexp) evaluates the Emacs Lisp expression preceding point in the buffer, and displays the value in the echo area. When the result of an evaluation is an integer, it is displayed together with the value in other formats (octal, hexadecimal, and character if eval-expression-print-maximum-character, described below, allows it).

If M-: or C-x C-e is given a prefix argument, it inserts the value into the current buffer at point, rather than displaying it in the echo area. If the prefix argument is zero, any integer output is inserted together with its value in other formats (octal, hexadecimal, and character). Such a prefix argument also prevents abbreviation of the output according to the variables eval-expression-print-level and eval-expression-print-length (see below). Similarly, a prefix argument of -1 overrides the effect of eval-expression-print-length.

The eval-defun command is bound to C-M-x in Emacs Lisp mode. It evaluates the top-level Lisp expression containing or following point, and prints the value in the echo area. In this context, a top-level expression is referred to as a “defun”, but it need not be an actual defun (function definition). In particular, this command treats defvar expressions specially. Normally, evaluating a defvar expression does nothing if the variable it defines already has a value. But this command unconditionally resets the variable to the initial value specified by the defvar; this is convenient for debugging Emacs Lisp programs. defcustom and defface expressions are treated similarly. Note that the other commands documented in this section do not have this special feature.

With a prefix argument, C-M-x instruments the function definition for Edebug, the Emacs Lisp Debugger. See Instrumenting for Edebug.

The command M-x eval-region parses the text of the region as one or more Lisp expressions, evaluating them one by one. M-x eval-buffer is similar but evaluates the entire buffer.

The options eval-expression-print-level and eval-expression-print-length control the maximum depth and length of lists to print in the result of the evaluation commands before abbreviating them. Supplying a zero prefix argument to eval-expression or eval-last-sexp causes lists to be printed in full. eval-expression-debug-on-error controls whether evaluation errors invoke the debugger when these commands are used; its default is t. eval-expression-print-maximum-character prevents integers which are larger than it from being displayed as characters. 
5.31 How do I execute (“evaluate”) a piece of Emacs Lisp code?
There are a number of ways to execute (evaluate, in Lisp lingo) an Emacs Lisp form:
    If you want it evaluated every time you run Emacs, put it in a file named .emacs in your home directory. This is known as “your .emacs file,” and contains all of your personal customizations.
    You can type the form in the *scratch* buffer, and then type <LFD> (or C-j) after it. The result of evaluating the form will be inserted in the buffer.
    ~In emacs-lisp-mode~, typing ~C-M-x~ evaluates a top-level form before or around point.
    Typing ~C-x C-e~ in ~any buffer~ evaluates the Lisp form immediately before point and prints its value in the echo area.
    Typing M-: or M-x eval-expression allows you to type a Lisp form in the minibuffer which will be evaluated once you press <RET>.
    You can use M-x load-file to have Emacs evaluate all the Lisp forms in a file. (To do this from Lisp use the function load instead.)
    The functions load-library, eval-region, eval-buffer, require, and autoload are also useful; see Emacs Lisp documentation, if you want to learn more about them. 
**** python
***** run unit test
 C-c C-t [elpy-test]

*** get help 
*** get menu command 
    Some of the commands in the menu bar have ordinary key bindings as well;
 if so, a key binding is shown after the item itself. 
To view the full ~command name~ and documentation for a menu item, type ~C-h k~,
 and then select the menu bar with the mouse in the usual way (see Key Help). 
*** coment line 
26.5.1 Comment Commands
The following commands operate on comments:
M-;
    Insert or realign comment on current line; if the region is active, comment or uncomment the region instead (comment-dwim).
~C-x C-;~
    Comment or uncomment the current line (comment-line). If the region is active, comment or uncomment the lines in the region instead.
C-u M-;
    Kill comment on current line (comment-kill).
C-x ;
    Set comment column (comment-set-column).
C-M-j
M-j
    Like <RET> followed by inserting and aligning a comment (comment-indent-new-line). See Multi-Line Comments.
M-x comment-region
C-c C-c (in C-like modes)
    Add comment delimiters to all the lines in the region. 

The command to create or align a comment is M-; (comment-dwim). The word “dwim” is an acronym for “Do What I Mean”; it indicates that this command can be used for many different jobs relating to comments, depending on the situation where you use it.
When a region is active (see Mark), M-; either adds comment delimiters to the region, or removes them. If every line in the region is already a comment, it uncomments each of those lines by removing their comment delimiters. Otherwise, it adds comment delimiters to enclose the text in the region.
If you supply a prefix argument to M-; when a region is active, that specifies the number of comment delimiters to add or delete. A positive argument n adds n delimiters, while a negative argument -n removes n delimiters.
If the region is not active, and there is no existing comment on the current line, M-; adds a new comment to the current line. If the line is blank (i.e., empty or containing only whitespace characters), the comment is indented to the same position where <TAB> would indent to (see Basic Indent). If the line is non-blank, the comment is placed after the last non-whitespace character on the line. Emacs tries to fit the comment between the columns specified by the variables comment-column and comment-fill-column (see Options for Comments), if possible. Otherwise, it will choose some other suitable position, usually separated from the non-comment text by at least one space. In each case, Emacs places point after the comment's starting delimiter, so that you can start typing the comment text right away.
You can also use M-; to align an existing comment. If a line already contains the comment-start string, M-; realigns it to the conventional alignment and moves point after the comment's starting delimiter. As an exception, comments starting in column 0 are not moved. Even when an existing comment is properly aligned, M-; is still useful for moving directly to the start of the comment text.
~C-x C-;~ (comment-line) comments or uncomments complete lines. When a region is active (see Mark), C-x C-; either comments or uncomments the lines in the region. If the region is not active, this command comments or uncomments the line point is on. With a positive prefix argument n, it operates on n lines starting with the current one; with a negative n, it affects n preceding lines. After invoking this command with a negative argument, successive invocations with a positive argument will operate on preceding lines as if the argument were negated.
C-u M-; (comment-dwim with a prefix argument) kills any comment on the current line, along with the whitespace before it. Since the comment is saved to the kill ring, you can reinsert it on another line by moving to the end of that line, doing C-y, and then M-; to realign the comment. You can achieve the same effect as C-u M-; by typing M-x comment-kill (comment-dwim actually calls comment-kill as a subroutine when it is given a prefix argument).
The command M-x comment-region is equivalent to calling M-; on an active region, except that it always acts on the region, even if the mark is inactive. In C mode and related modes, this command is bound to C-c C-c. The command M-x uncomment-region uncomments each line in the region; a numeric prefix argument specifies the number of comment delimiters to remove (negative arguments specify the number of comment delimiters to add).
For C-like modes, you can configure the exact effect of M-; by setting the variables c-indent-comment-alist and c-indent-comments-syntactically-p. For example, on a line ending in a closing brace, M-; puts the comment one space after the brace rather than at comment-column. For full details see Comment Commands. 
*** Rebind keys
**** keys to keys
(global-set-key (kbd "<f7>") (kbd "C-u C-c C-c"))
** Customize 
*** by menu
To customize rainbow-delimiters mode, you can use:
M-x customize-group rainbow-delimiters
Color Scheme

customize-group rainbow-delimiters-faces has the faces for successive nested pairs of delimiters. You can change them through emacs customize or in your color theme or dot-emacs.

The face rainbow-delimiters-unmatched-face is used for unmatched closing delimiters.

Zenburn and Solarized themes have their own colors for these faces.

deftheme/color-theme.el: Further information is at the top of rainbow-delimiters.el.
Stop Highlighting Certain Delimiters

You can disable highlighting of any of the supported delimiter types through the customize interface, in the Toggle Delimiters section. 
*** using command
используя названия из меню можно подобрать подходяшию команду
на основе примера
	;; (custom-theme-set-faces
	;; 'material
	;; `(outline-1 ((t (:height 1.25 :weight bold))))
	;; `(outline-2 ((t (:height 1.15 :weight bold))))
	;; `(outline-3 ((t (:height 1.05 :weight bold))))
	;; `(outline-4 ((t (:height 1.95 :weight bold))))
	;; `(outline-5 ((t (:height 1.85 :weight bold))))
	;; `(outline-6 ((t (:height 1.75 :weight bold))))
	;; `(outline-7 ((t (:height 1.65 :weight bold))))
** info\help
   Check out the info manual for Org Mode with C-h i (info) to learn more, including how to customize the number of days initially displayed and what day your week starts on. 
   удобная систе показиваюшая мануалки по всем установленым модам
** Options
*** Visual
*** Home 
**** 3.5 Where do I put my init file?
***** file
On Windows, the .emacs file may be called _emacs for backward compatibility with DOS and FAT filesystems where filenames could not start with a dot. Some users prefer to continue using such a name due to historical problems various Windows tools had in the past with file names that begin with a dot. In Emacs 22 and later, the init file may also be called .emacs.d/init.el. Many of the other files that are created by lisp packages are now stored in the .emacs.d directory too, so this keeps all your Emacs related files in one place.

All the files mentioned above should go in your HOME directory. The HOME directory is determined by following the steps below:

***** environment variable HOME
    If the environment variable HOME is set, use the directory it indicates.
***** registry
    If the registry entry HKCU\SOFTWARE\GNU\Emacs\HOME is set, use the directory it indicates.
    If the registry entry HKLM\SOFTWARE\GNU\Emacs\HOME is set, use the directory it indicates. Not recommended, as it results in users sharing the same HOME directory.
***** if HOME was not set
    If C:\.emacs exists, then use C:/. This is for backward compatibility, as previous versions defaulted to C:/ if HOME was not set.
    Use the user's AppData directory, usually a directory called AppData under the user's profile directory, the location of which varies according to Windows version and whether the computer is part of a domain. 

***** Within Emacs, ~
Within Emacs, ~ at the beginning of a file name is expanded to your HOME directory, so you can always find your .emacs file by typing the command C-x C-f ~/.emacs. 
*** Text Eltments
**** Parenthesis
***** 5.27 How do I show which parenthesis matches the one I’m looking at?
  Call show-paren-mode in your .emacs file:
  (show-paren-mode 1)

  You can also enable this mode by selecting the ‘Paren Match Highlighting’ option from the ‘Options’ menu of the Emacs menu bar at the top of any Emacs frame.

  Alternatives to this mode include:

  If you’re looking at a right parenthesis (or brace or bracket) you can delete it and reinsert it. Emacs will momentarily move the cursor to the matching parenthesis.

  C-M-f (forward-sexp) and C-M-b (backward-sexp) will skip over one set of balanced parentheses, so you can see which parentheses match. (You can train it to skip over balanced brackets and braces at the same time by modifying the syntax table.)

  Here is some Emacs Lisp that will make the % key show the matching parenthesis, like in vi. In addition, if the cursor isn’t over a parenthesis, it simply inserts a % like normal.
  #+BEGIN_SRC elisp
;; By an unknown contributor
(global-set-key "%" 'match-paren)
(defun match-paren (arg)
"Go to the matching paren if on a paren; otherwise insert %."
    (interactive "p")
    (cond ((looking-at "\\s(") (forward-list 1) (backward-char 1))
	    ((looking-at "\\s)") (forward-char 1) (backward-list 1))
	    (t (self-insert-command (or arg 1)))))
  #+END_SRC
** eLisp
*** show maseges
**** message
(message "Load of init.el is ended")
	(if nil "yes" "no")
**** format
	(format "sdfsdf")
*** varible
**** show type
(type-of chartoadd)
**** chek type
(typep *x* 'integer)
**** chege type 
***** From number to string:
(number-to-string 5)
"5"
you may transform a string to any numerical notation:
(number-to-string 341 :base 10)
"341"
***** From string to number:
(parse-integer "5")
5
with some trash
(parse-integer " 5 something not a number" :junk-allowed t)
5
Or use this:
(read-from-string "23 absd")
23
***** FORMAT 
(format nil "~A" 1)
*** Cool guid
https://github.com/chrisdone/elisp-guide
*** compile
Emacs 24.3 or below

There's no built-in way of preventing these old files from being loaded, but there are easy ways to get rid of them.

****    You can recompile the entire elpa directory by calling:
    M-x byte-recompile-directory RET ~/.emacs.d/elpa/.
    This should get rid of outdated files.
****    You can use the auto-compile package
and activate auto-compile-on-load-mode which can compile files before they are loaded.

Emacs 24.4

Yes, and it turns out to be rather simple. The
****    load-prefer-newer
variable serves precisely this purpose.

(setq load-prefer-newer t)

Unfortunately, it won't work when some code specifically targets the .elc file, such as (load "server.elc"). But it should be enough as long as you're using requires or calling load without a suffix, which you should.

From the doc:

    load-prefer-newer is a variable defined in lread.c.
    Its value is nil

    Documentation:
    Non-nil means load prefers the newest version of a file.
    This applies when a filename suffix is not explicitly specified and load is trying various possible suffixes (see load-suffixes and load-file-rep-suffixes). Normally, it stops at the first file that exists unless you explicitly specify one or the other. If this option is non-nil, it checks all suffixes and uses whichever file is newest.
    Note that if you customize this, obviously it will not affect files that are loaded before your customizations are read!
** REPL 
** DeBug
** eShell
*** doc
**** commands
***** [so] Is it therefore possible to see what actual elisp is being invoked...
https://emacs.stackexchange.com/questions/14979/access-to-the-elisp-commands-behind-eshell-commands/14981#14981

Yes. They are all located in the eshell folder under Resources/elisp in the Emacs app folder. See screenshot of files on my computer. 


  So I'd like to have the actual elisp...


Open any of those files to see the actual elisp code. For example, ls command with its normal switches is implemented in em-ls.el file by John Wiegley and its core uses expand-file-name function.

How to find which lisp file provides what shell command? Open eshell prompt and then type, say you want to know where kill is in elisp:

which kill


will tell you that 

eshell/kill is a compiled Lisp function in `esh-proc.el'


What other commands are available in eshell?

see the [manual][2]



  there is no way I know of running eshell commands as Babel "code blocks."


There are no special eshell commands per se. Eshell mimics standard unix shell commands using existing lisp functions. You can invoke those same functions in org-babel lisp blocks without any mediating functions implemented in eshell. 
    
***** so find-function
        e.g.: M-x find-function RET eshell/ls RET

I like having find-function bound to C-hC-f as a variant on the standard describe-function binding (via which you can also indirectly get to the code, FYI).

You could also use the following:
#+BEGIN_SRC shell
(defun eshell/goto (name)
  "Visit the source code for the specified eshell command."
  (let ((func (eshell-find-alias-function name)))
    (if func
        (find-function func)
      (error "%s is not an elisp function" name))))
#+END_SRC
$ goto ls


If you want to know what's implemented in elisp and what isn't, you could just ask Emacs to complete on eshell/

e.g.: C-uC-ha eshell/ RET
** Folding 
*** HideShow
Invoke HideShow mode with M-x hs-minor-mode.

* Help Docs Org
** Welcome to Org mode
*** Marker sibols  
 You can make words 
 *bold*, /italic/, _underlined_, =code= and ~verbatim sdfsdfs~, 
 and, if you must, +strike-through+.
*** Lord of the Rings
    My favorite scenes are (in this order)
    1. Eowyn's fight with the witch king
       + this was already my favorite scene in the book
       + I really like Miranda Otto.
    2. The attack of the Rohirrim
    3. Peter Jackson being shot by Legolas
       - on DVD only
       He makes a really funny face when it happens.
    But in the end, no individual scenes matter but the film as a whole.
    Important actors in this film are:
    - Elijah Wood :: He plays Frodo
    - Sean Austin :: He plays Sam, Frodo's friend.  I still remember
      him very well from his role as Mikey Walsh in The Goonies.
** Help
*** info\manual
    Check out the info manual for Org Mode with C-h i (info) to learn more, including how to customize the number of days initially displayed and what day your week starts on. 
    удобная систе показиваюшая мануалки по всем установленым модам
*** links
**** Org Mode - Organize Your Life In Plain Text!
     http://doc.norang.ca/org-mode.html   
     очень последовательнвый манул по всему оргу с кучей примеров
*** мануал пдф
 [[https://orgmode.org/org.pdf][Link to 304p doc about org]]
** Tree Notes 
*** Exempls
  - Note taken on [2018-10-29 Пн 20:19] \\
    ladfdfd
    fdf
    df
    df
    ts add anoser note
    - sdfsdf sdf sdf sdfsd \\
    sdfsdfsdf
    sdfsdf sd fsd fd
    - some note?
	Intrasting where it puting this
    - d
    - sdf
    - sdfsdfsf
    - [X] 
    - [X] sdf
    - 
    - sdfsdfs sdf sdf sd[fn:1] 
    - 
*** Footnotes

[fn:1] The footnote.

[fn:2] Second footnote.
[fn:1] I not undestend ecthakli how this must work
** Help keys
*** Visibility cycling
Tab – show current
S-tab – show all children
C-u C-u C-u Tab – show all including drawers
Startup options
Editting
M-Ret – add element on the same level
M-S-Ret – insert TODO element
M-Right – demote current element
M-S-Right – deomote current subtree
M-Left – promote current element
M-S-Left – promote current subtree
M-S-Up – move current tree up
M-S-Down – move current tree down
C-c C-x C-w – kill current subtree
C-c C-x M-w – copy current subtree
C-c C-x C-y – yank subtree
C-x n s     (org-narrow-to-subtree)
    Narrow buffer to current subtree.
C-x n b     (org-narrow-to-block)
    Narrow buffer to current block.
C-x n w     (widen)
    Widen buffer to remove narrowing.
C-c *     (org-toggle-heading)
    Turn a normal line or plain list item into a headline (so that it becomes a subheading at its location). Also turn a headline into a normal line by removing the stars. If there is an active region, turn all lines in the region into headlines. If the first line in the region was an item, turn only the item lines into headlines. Finally, if the first line is a headline, remove the stars from all headlines in the region. 
*** Plain lists
Use M-Ret to add list item
Ordered list:

    First
    Second
    Third

Unordered lists

    abc
    efg

List with checkboxes (M-S-Ret)

    [ ] First element
    [X] Second element (C-c C-c – toggle checkbox state)
    [X] Third element
*** ToDo functionalityt
C-c C-t – rotate TODO state
S-Left, S-Right – rotate TODO state
**** S-M-Ret – insert new TODO note
(setq org-todo-keywords’((sequence “TODO” “FEEDBACK” “VERIFY” “|” “DONE” “DELEGATED”)))
Footnotes
**** C-c / t     (org-show-todo-tree)

    View TODO items in a sparse tree (see Sparse trees). Folds the entire buffer, but shows all TODO items (with not-DONE state) and the headings hierarchy above them. With a prefix argument (or by using C-c / T), search for a specific TODO. You will be prompted for the keyword, and you can also give a list of keywords like KWD1|KWD2|... to list entries that match any one of these keywords. With a numeric prefix argument N, show the tree for the Nth keyword in the option org-todo-keywords. With two prefix arguments, find all TODO states, both un-done and done. 
**** C-c a t     (org-todo-list)

    Show the global TODO list. Collects the TODO items (with not-DONE states) from all agenda files (see Agenda views) into a single buffer. The new buffer will be in agenda-mode, which provides commands to examine and manipulate the TODO entries from the new buffer (see Agenda commands). See Global TODO list, for more information. 
*** unsort
More devices
C-c C-z – time-stamped drawer

    Note taken on [2013-09-02 Mon 23:54]
    My note here

[fn:2]
 C-c C-x f – footnote[fn:1]**
** template expansion 
*** capture 
**** Template expansion %
10.1.3.2 Template expansion

In the template itself, special “%-escapes”86 allow dynamic insertion of content. The templates are expanded in the order given here:

‘%[FILE]’

    Insert the contents of the file given by FILE.
‘%(EXP)’

    Evaluate Elisp expression EXP and replace it with the result. The EXP form must return a string. Only placeholders pre-existing within the template, or introduced with ‘%[file]’, are expanded this way. Since this happens after expanding non-interactive “%-escapes”, those can be used to fill the expression.
‘%<FORMAT>’

    The result of format-time-string on the FORMAT specification.
‘%t’
    Timestamp, date only.
‘%T’

    Timestamp, with date and time.
‘%u’, ‘%U’

    Like ‘%t’, ‘%T’ above, but inactive timestamps.
‘%i’

    Initial content, the region when capture is called while the region is active. If there is text before ‘%i’ on the same line, such as indentation, and ‘%i’ is not inside a ‘%(exp)’ form, that prefix is added before every line in the inserted text.
‘%a’

    Annotation, normally the link created with org-store-link.
‘%A’

    Like ‘%a’, but prompt for the description part.
‘%l’

    Like ‘%a’, but only insert the literal link.
‘%c’

    Current kill ring head.
‘%x’

    Content of the X clipboard.
‘%k’

    Title of the currently clocked task.
‘%K’

    Link to the currently clocked task.
‘%n’

    User name (taken from user-full-name).
‘%f’

    File visited by current buffer when org-capture was called.
‘%F’

    Full path of the file or directory visited by current buffer.
‘%:keyword’

    Specific information for certain link types, see below.
‘%^g’

    Prompt for tags, with completion on tags in target file.
‘%^G’

    Prompt for tags, with completion all tags in all agenda files.
‘%^t’

    Like ‘%t’, but prompt for date. Similarly ‘%^T’, ‘%^u’, ‘%^U’. You may define a prompt like ‘%^{Birthday}t’.
‘%^C’

    Interactive selection of which kill or clip to use.
‘%^L’

    Like ‘%^C’, but insert as link.
‘%^{PROP}p’

    Prompt the user for a value for property PROP.
‘%^{PROMPT}’

    Prompt the user for a string and replace this sequence with it. You may specify a default value and a completion table with ‘%^{prompt|default|completion2|completion3...}’. The arrow keys access a prompt-specific history.
‘%\N’

    Insert the text entered at the Nth ‘%^{PROMPT}’, where N is a number, starting from 1.
‘%?’

    After completing the template, position point here. 

For specific link types, the following keywords are defined87:
Link type	Available keywords
bbdb	‘%:name’, ‘%:company’
irc	‘%:server’, ‘%:port’, ‘%:nick’
mh, rmail	‘%:type’, ‘%:subject’, ‘%:message-id’
	‘%:from’, ‘%:fromname’, ‘%:fromaddress’
	‘%:to’, ‘%:toname’, ‘%:toaddress’
	‘%:date’ (message date header field)
	‘%:date-timestamp’ (date as active timestamp)
	‘%:date-timestamp-inactive’ (date as inactive timestamp)
	‘%:fromto’ (either “to NAME” or “from NAME”)88
gnus	‘%:group’, for messages also all email fields
w3, w3m	‘%:url’
info	‘%:file’, ‘%:node’
calendar	‘%:date’
org-protocol	‘%:link’, ‘%:description’, ‘%:annotation’
Footnotes
(86)

If you need one of these sequences literally, escape the ‘%’ with a backslash.
(87)

If you define your own link types (see Adding Hyperlink Types), any property you store with org-store-link-props can be accessed in capture templates in a similar way.
(88)
*** structural 
**** list
With just a few keystrokes, it is possible to insert empty structural blocks, such as ‘#+BEGIN_SRC’ … ‘#+END_SRC’, or to wrap existing text in such a block.

C-c C-, (org-insert-structure-template)

    Prompt for a type of block structure, and insert the block at point. If the region is active, it is wrapped in the block. First prompts the user for keys, which are used to look up a structure type from the variable below. If the key is TAB, RET, or SPC, the user is prompted to enter a block type. 

Available structure types are defined in org-structure-template-alist, see the docstring for adding or changing values.

Org Tempo expands snippets to structures defined in org-structure-template-alist and org-tempo-keywords-alist. For example, < s TAB creates a code block. Enable it by customizing org-modules or add ‘(require 'org-tempo)’ to your Emacs init file146.
a	‘#+BEGIN_EXPORT ascii’ … ‘#+END_EXPORT’
c	‘#+BEGIN_CENTER’ … ‘#+END_CENTER’
C	‘#+BEGIN_COMMENT’ … ‘#+END_COMMENT’
e	‘#+BEGIN_EXAMPLE’ … ‘#+END_EXAMPLE’
E	‘#+BEGIN_EXPORT’ … ‘#+END_EXPORT’
h	‘#+BEGIN_EXPORT html’ … ‘#+END_EXPORT’
l	‘#+BEGIN_EXPORT latex’ … ‘#+END_EXPORT’
q	‘#+BEGIN_QUOTE’ … ‘#+END_QUOTE’
s	‘#+BEGIN_SRC’ … ‘#+END_SRC’
v	‘#+BEGIN_VERSE’ … ‘#+END_VERSE’
Footnotes
(146)

For more information, please refer to the commentary section in ‘org-tempo.el’.
**** exempl
	 <s
	 #+BEGIN_SRC 
(setq org-structure-template-alist
      '(("s" "#+BEGIN_SRC ?\n\n#+END_SRC\n")
       ("e" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE\n")
       ("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE\n")
       ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE\n")
       ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM\n")))
	 #+END_SRC
in new versin 2.0
(add-to-list 'org-structure-template-alist '("t" . "src translate"))
old
(add-to-list 'org-structure-template-alist '("t" "#+BEGIN_SRC ? translate\n\n#+END_SRC\n"))
<t
	 #+BEGIN_SRC  translate
	Ты работаешь? 
	 #+END_SRC

	 #+RESULTS:
	 : Do you work?

(add-to-list 'org-structure-template-alist '("tr" "#+BEGIN_SRC ? translate :dest ru\n\n#+END_SRC\n"))
	 #+BEGIN_SRC  translate :dest ru
 Do you work?
	 #+END_SRC

	 #+RESULTS:
	 : Вы работаете?
	 
	 
** Tabels
*** exempl
   | freeman | 1 | hucker |
   | max     | 1 | humen  |
   |---------+---+--------|
   |         |   |        |
  
   |---------+---+--------|
   |         |   |        |
*** keys 
**** new
c-c | - generet new table
‘C-c |     (org-table-create-or-convert-from-region)’

**** ‘C-c <SPC>     (org-table-blank-field)’
**** ‘M-a     (org-table-beginning-of-field)’
     Move to beginning of the current table field, or on to the previous
     field.
**** ‘M-e     (org-table-end-of-field)’
     Move to end of the current table field, or on to the next field.
     Blank the field at point.
**** move 
‘M-<LEFT>     (org-table-move-column-left)’
‘M-<RIGHT>     (org-table-move-column-right)’
     Move the current column left/right.
‘M-<UP>     (org-table-move-row-up)’
‘M-<DOWN>     (org-table-move-row-down)’
     Move the current row up/down.
**** add \\ remove
‘M-S-<LEFT>     (org-table-delete-column)’
     Kill the current column.
‘M-S-<RIGHT>     (org-table-insert-column)’
     Insert a new column to the left of the cursor position.
‘M-S-<UP>     (org-table-kill-row)’
     Kill the current row or horizontal line.
‘M-S-<DOWN>     (org-table-insert-row)’
**** ‘C-c -     (org-table-insert-hline)’
     Insert a horizontal line below current row.  With a prefix
     argument, the line is created above the current line.
**** ‘C-c <RET>     (org-table-hline-and-move)’
     Insert a horizontal line below current row, and move the cursor
     into the row below that line.
**** ‘C-c ^     (org-table-sort-lines)’
     Sort the table lines in the region.  The position of point
     indicates the column to be used for sorting, and the range of lines
     is the range between the nearest horizontal separator lines, or the
     entire table.  If point is before the first column, you will be
     prompted for the sorting column.  If there is an active region, the
     mark specifies the first line and the sorting column, while point
     should be in the last line to be included into the sorting.  The
     command prompts for the sorting type (alphabetically, numerically,
     or by time).  You can sort in normal or reverse order.  You can
     also supply your own key extraction and comparison functions.  When
     called with a prefix argument, alphabetic sorting will be
     case-sensitive.
**** ‘M-<RET>     (org-table-wrap-region)’
     Split the current field at the cursor position and move the rest to
     the line below.  If there is an active region, and both point and
     mark are in the same column, the text in the column is wrapped to
     minimum width for the given number of lines.  A numeric prefix
     argument may be used to change the number of desired lines.  If
     there is no region, but you specify a prefix argument, the current
     field is made blank, and the content is appended to the field
     above.
**** ‘C-c +     (org-table-sum)’
     Sum the numbers in the current column, or in the rectangle defined
     by the active region.  The result is shown in the echo area and can
     be inserted with ‘C-y’.
**** ‘S-<RET>     (org-table-copy-down)’
     When current field is empty, copy from first non-empty field above.
     When not empty, copy current field down to next row and move cursor
     along with it.  Depending on the option ‘org-table-copy-increment’,
     integer field values will be incremented during copy.  Integers
     that are too large will not be incremented.  Also, a ‘0’ prefix
     argument temporarily disables the increment.  This key is also used
     by shift-selection and related modes (*note Conflicts::).
**** ‘C-c |     (org-table-create-or-convert-from-region)’
     Tables can also be imported by pasting tabular text into the Org
     buffer, selecting the pasted text with ‘C-x C-x’ and then using the
     ‘C-c |’ command (see above under Creation and conversion).
** Tags 
Two: Which tags do you use most?
You can always add tags freely and by hand, but if you configure the most important ones along with fast-access keys, life will be better. Configure the variable org-tags-alist or simply do this right in the file with1
#+TAGS: home(h) work(w) @computer(c) @phone(p) errants(e)
** Todos 
*** Dependantistis 
**** TODO Blocked until (two) is done
***** DONE one
***** TODO two
**** Parent
     :PROPERTIES:
     :ORDERED:  t
     :END:
***** WAITING a
- isdf
- [ ] sdfs
- [X] sdfsdf
***** TODO b, needs to wait for (a)
***** TODO c, needs to wait for (a) and (b)

   You can ensure an entry is never blocked by using the NOBLOCKING property:

**** This entry is never blocked
     :PROPERTIES:
     :NOBLOCKING: t
     :END:

   C-c C-x o     (org-toggle-ordered-property)
*** Status 
  One: More TODO keywords
  Define the TODO states you find useful and single letters for fast selection. Customize the variable org-todo-keywords or simply do this right in the file with1:
  #+TODO: TODO(t) STARTED(s) WAITING(w) | DONE(d) CANCELED(c)
*** arhiv 
    c+c $ 
you can move them to an archive file with C-c $ (org-archive-subtree)отправляет в архи таким путём чистя агенду и лист
момет отправки помечается временени поидееии
и соответственно его скорй всего потом оможно будет от туда выташить и использовать 
*** shadule
    С+с С+s
  Next, we're going to schedule some tasks. Go to a task that you want to do today. Press C-c C-s (org-schedule) and accept the default. Schedule a couple of other tasks for today.

Schedule some tasks for tomorrow, too. This time, when you schedule it, type +1 for the date. You can specify +2 for the day after tomorrow, etc. The 28th? 28. If you want to schedule something for next Saturday, you can type sat. Two Tuesdays from now? 2thu. A month from now? 1m. It's really flexible. 
*** агендa
**** keys add agenda file
    C-c [     (org-agenda-file-to-front)

     Add current file to the list of agenda files. The file is added to the front of the list. If it was already in the list, it is moved to the front. With a prefix argument, file is added/moved to the end. 
 C-c ]     (org-remove-file)

     Remove current file from the list of agenda files. 
**** comands to add agenda file
    (setq org-agenda-files '("~/org"))
    (setq org-agenda-files '("~/ORG/start.org"))
    (setq org-agenda-files (quote ("~/ORG/start.org")))
*** *add a :CATEGORY: property to the top-level, non-TODO heading that identifies the project.  Using your example:

 * Project ABC
  :PROPERTIES:
  :CATEGORY: ABC
  :END:

 ** TODO A task related to Project ABC
 ** TODO Another task related to ABC
 *** TODO Subtask
SCHEDULED: 

In my bog-standard org-mode setup, this results in “ABC” being displayed in the far-left column of the agenda instead of just “todo” (which seems to be the default). This is great — it means that, in the text of the “Subtask” todo entry itself, I don’t need to include a reminder of what project the todo entry is associated with.

Here’s an agenda mockup to illustrate the point, augmented with a “default” entry from my own to-do list:

  todo:       Scheduled:  Follow up on expense reimbursement request
  ABC:        Scheduled:  Subtask

** Links 
*** общее
(define-key global-map "\C-cl" 'org-store-link)
Для того что бы создать ссылку достаточно использовать такой шаблон — [[%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0][описание]].
  [ {] [] ]

Для создания ссылки можно ещё использовать комбинацию C+c C+l. В мини-буфере emacs предложит сначала написать ссылку, затем после нажатия RET — её создать. Находясь в мини-буфере так же можно нажать TAB, для просмотра, какие виды ссылок бывают.
редактировать повторно тойже комбинацией C+c C+l. 

Что бы открыть вновь созданные ссылки необходимо навести точку на ссылку и тыкнуть C+c C+o. Или C+u C+c C+o — если Вы хотите открыть её в другом окне.

Ради интереса, можно перейти в другой файл, нажать там C+c l. И ссылка на этот файл поместится в хранилище ссылок. Перейдя в любой наш файл .org мы можем извлечь из этого хранилища любые сохраненные ссылки, с помощью той же команды C+c C+l.
Самые наблюдательные читатели уже могли заметить, что эта команда как раз и есть та, которую мы вписали в ~/.emacs, в начале.
‘file:/home/dominik/images/jupiter.jpg’ file, absolute path
‘/home/dominik/images/jupiter.jpg’ same as above
‘file:papers/last.pdf’ file, relative path
‘./papers/last.pdf’ same as above
‘file:/ssh:me@some.where:papers/last.pdf’ file, path on remote machine
‘/ssh:me@some.where:papers/last.pdf’ same as above
‘file:sometextfile::NNN’ file, jump to line number
‘file:projects.org’ another Org file
‘file:projects.org::some words’ text search in Org file5
‘file:projects.org::*task title’ heading search in Org file
‘file+sys:/path/to/file’ open via OS, like double-click
‘file+emacs:/path/to/file’ force opening by Emacs
‘docview:papers/last.pdf::NNN’ open in doc-view mode at page
‘id:B7423F4D-2E8A-471B-8810-C40F074717E9’ link to heading by ID
‘mailto:adent@galaxy.net’ mail link
‘irc:/irc.com/#emacs/bob’ IRC link
‘info:org#External links’ Info node link
‘shell:ls *.org’ shell command
‘elisp:org-agenda’ interactive Elisp command
‘elisp:(find-file "Elisp.org")’ Elisp form to evaluate
‘http://www.astro.uva.nl/=dominik’ on the web
*** мануал пдф
[[https://orgmode.org/org.pdf][Link to 304p doc about org]]
*** 4.2 Internal Link
If the link does not look like a URL, it is considered to be internal in the current file.
The most important case is a link like ‘[[#my-custom-id]]’ which links to the entry with
the ‘CUSTOM_ID’ property ‘my-custom-id’. You are responsible yourself to make sure these
custom IDs are unique in a file.
Links such as ‘[[My Target]]’ or ‘[[My Target][Find my target]]’ lead to a text
‘[[My Target]}’ or ‘[[My Target][Find my target]}’
search in the current file.

The link can be followed with C-c C-o when point is on the link, or with a mouse click
(see Section 4.5 [Handling Links], page 39). Links to custom IDs point to the corresponding
headline. The preferred match for a text link is a dedicated target: the same string in double

angular brackets, like ‘<<My Target>>’.
If no dedicated target exists, the link tries to match the exact name of an element within
the buffer. Naming is done with the ‘NAME’ keyword, which has to be put in the line before
the element it refers to, as in the following example
#+NAME: My Target
| a | table |
|----+------------|
| of | four cells |
If none of the above succeeds, Org searches for a headline that is exactly the link text
but may also include a TODO keyword and tags3
1. one item
2. <<target>>another item
Here we refer to item [[target]] \ [[target]} .
The last sentence will appear as ‘Here we refer to item 2’ when exported.
In non-Org files, the search looks for the words in the link text. In the above example
the search would be for ‘target’.
Following a link pushes a mark onto Org’s own mark ring. You can return to the previous
position with C-c &. Using this command several times in direct succession goes back to
positions recorded earlier.
*** 4.7 Link Abbreviations 
[[linkword:tag][description]}
where the tag is optional. The linkword must be a word, starting with a letter, followed by
letters, numbers, ‘-’, and ‘_’. Abbreviations are resolved according to the information in
the variable org-link-abbrev-alist that relates the linkwords to replacement text. Here
is an example:
(setq org-link-abbrev-alist
'(("bugzilla" . "http://10.1.2.9/bugzilla/show_bug.cgi?id=")
("url-to-ja" . "http://translate.google.fr/translate?sl=en&tl=ja&u=%h")
("google" . "http://www.google.com/search?q=")
("gmap" . "http://maps.google.com/maps?q=%s")
("omap" . "http://nominatim.openstreetmap.org/search?q=%s&polygon=1")
("ads" . "https://ui.adsabs.harvard.edu/search/q=%20author%3A\"%s\"")))
If the replacement text contains the string ‘%s’, it is replaced with the tag. Using ‘%h’
instead of ‘%s’ percent-encodes the tag (see the example above, where we need to encode
the URL parameter). Using ‘%(my-function)’ passes the tag to a custom Lisp function,
and replace it by the resulting string.
If the replacement text do not contain any specifier, it is simply appended to the string
in order to create the link.
Instead of a string, you may also specify a Lisp function to create the link. Such a
function will be called with the tag as the only argument.
With the above setting, you could link to a specific bug with ‘[[bugzilla:129]]’,
search the web for ‘OrgMode’ with ‘[[google:OrgMode]]’, show the map location of the
Free Software Foundation ‘[[gmap:51 Franklin Street, Boston]]’

If you need special abbreviations just for a single Org buffer, you can define them in the
file with
#+LINK: bugzilla http://10.1.2.9/bugzilla/show_bug.cgi?id=
#+LINK: google http://www.google.com/search?q=%s
In-buffer completion (see Section 15.1 [Completion], page 228) can be used after ‘[’ to
complete link abbreviations. You may also define a Lisp function that implements special
(e.g., completion) support for inserting such a link with C-c C-l. Such a function should
not accept any arguments, and should return the full link with a prefix. You can set the
link completion function like this:
(org-link-set-parameter "type" :complete #'some-completion-function)
*** 4.8 Search Options in File Links 

[[file:~/code/main.c::255]}
[[file:~/xx.org::My Target]}
[[file:~/xx.org::*My Target]}
[[file:~/xx.org::#my-custom-id]}
[[file:~/xx.org::/regexp/]}
‘255’ Jump to line 255.
‘My Target’
Search for a link target ‘<<My Target>>’, or do a text search for ‘my target’,
similar to the search in internal links, see Section 4.2 [Internal Links], page 36.
In HTML export (see Section 12.9 [HTML Export], page 151), such a file link
becomes a HTML reference to the corresponding named anchor in the linked
file.
‘*My Target’
In an Org file, restrict search to headlines.
‘#my-custom-id’
Link to a heading with a ‘CUSTOM_ID’ property
‘/REGEXP/’
Do a regular expression search for REGEXP. This uses the Emacs command
occur to list all matches in a separate window. If the target file is in Org mode,
org-occur is used to create a sparse tree with the matches.

  As a degenerate case, a file link with an empty file name can be used to search the
current file. For example, ‘[[file:::find me]}’ does a search for ‘find me’ in the current
file, just as ‘[[find me]}’ would.
* Help Docs Gnus
  The Emacs news and email reader.
* Help Docs Mods 
** use-package
*** Getting started
;; This is only needed once, near the top of the file
(eval-when-compile
  ;; Following line is not needed if use-package.el is in ~/.emacs.d
  (add-to-list 'load-path "<path where use-package is installed>")
  (require 'use-package))

(use-package foo)
This loads in the package foo, but only if foo is available on your system. If not, a warning is logged to the *Messages* buffer.
*** :init :config
Use the :init keyword to execute code before a package is loaded. It accepts one or more forms, up to the next keyword:

(use-package foo
  :init
  (setq foo-variable t))
Similarly, :config can be used to execute code after a package is loaded. In cases where loading is done lazily (see more about autoloading below), this execution is deferred until after the autoload occurs:

(use-package foo
  :init
  (setq foo-variable t)
  :config
  (foo-mode 1))
As you might expect, you can use :init and :config together:

(use-package color-moccur
  :commands (isearch-moccur isearch-all)
  :bind (("M-s O" . moccur)
         :map isearch-mode-map
         ("M-o" . isearch-moccur)
         ("M-O" . isearch-moccur-all))
  :init
  (setq isearch-lazy-highlight t)
  :config
  (use-package moccur-edit))
In this case, I want to autoload the commands isearch-moccur and isearch-all from color-moccur.el, and bind keys both at the global level and within the isearch-mode-map (see next section). When the package is actually loaded (by using one of these commands), moccur-edit is also loaded, to allow editing of the moccur buffer.
*** Key-binding
Another common thing to do when loading a module is to bind a key to primary commands within that module:

(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))
This does two things: first, it creates an autoload for the ace-jump-mode command and defers loading of ace-jump-mode until you actually use it. Second, it binds the key C-. to that command. After loading, you can use M-x describe-personal-keybindings to see all such keybindings you've set throughout your .emacs file.

A more literal way to do the exact same thing is:

(use-package ace-jump-mode
  :commands ace-jump-mode
  :init
  (bind-key "C-." 'ace-jump-mode))
When you use the :commands keyword, it creates autoloads for those commands and defers loading of the module until they are used. Since the :init form is always run -- even if ace-jump-mode might not be on your system -- remember to restrict :init code to only what would succeed either way.

The :bind keyword takes either a cons or a list of conses:

(use-package hi-lock
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))
The :commands keyword likewise takes either a symbol or a list of symbols.

NOTE: inside strings, special keys like tab or F1-Fn have to be written inside angle brackets, e.g. "C-<up>". Standalone special keys (and some combinations) can be written in square brackets, e.g. [tab] instead of "<tab>". The syntax for the keybindings is similar to the "kbd" syntax: see https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-Rebinding.html for more information.

Examples:

(use-package helm
  :bind (("M-x" . helm-M-x)
         ("M-<f5>" . helm-find-files)
         ([f10] . helm-buffers-list)
         ([S-f10] . helm-recentf)))
Furthermore, remapping commands with :bind and bind-key works as expected, because when the binding is a vector, it is passed straight to define-key. So the following example will rebind M-q (originally fill-paragraph) to unfill-toggle:

(use-package unfill
  :bind ([remap fill-paragraph] . unfill-toggle))
*** Binding to keymaps
Normally :bind expects that commands are functions that will be autoloaded from the given package. However, this does not work if one of those commands is actually a keymap, since keymaps are not functions, and cannot be autoloaded using Emacs' autoload mechanism.

To handle this case, use-package offers a special, limited variant of :bind called :bind-keymap. The only difference is that the "commands" bound to by :bind-keymap must be keymaps defined in the package, rather than command functions. This is handled behind the scenes by generating custom code that loads the package containing the keymap, and then re-executes your keypress after the first load, to reinterpret that keypress as a prefix key.

For example:

(use-package projectile
  :bind-keymap
  ("C-c p" . projectile-command-map))
Binding within local keymaps

Slightly different from binding a key to a keymap, is binding a key within a local keymap that only exists after the package is loaded. use-package supports this with a :map modifier, taking the local keymap to bind to:

(use-package helm
  :bind (:map helm-command-map
         ("C-c h" . helm-execute-persistent-action)))
The effect of this statement is to wait until helm has loaded, and then to bind the key C-c h to helm-execute-persistent-action within Helm's local keymap, helm-mode-map.

Multiple uses of :map may be specified. Any binding occurring before the first use of :map are applied to the global keymap:

(use-package term
  :bind (("C-c t" . term)
         :map term-mode-map
         ("M-p" . term-send-up)
         ("M-n" . term-send-down)
         :map term-raw-map
         ("M-o" . other-window)
         ("M-p" . term-send-up)
         ("M-n" . term-send-down)))
*** Modes and interpreters
Similar to :bind, you can use :mode and :interpreter to establish a deferred binding within the auto-mode-alist and interpreter-mode-alist variables. The specifier to either keyword can be a cons cell, a list of cons cells, or a string or regexp:

(use-package ruby-mode
  :mode "\\.rb\\'"
  :interpreter "ruby")

;; The package is "python" but the mode is "python-mode":
(use-package python
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode))
If you aren't using :commands, :bind, :bind*, :bind-keymap, :bind-keymap*, :mode, :interpreter, or :hook (all of which imply :defer; see the docstring for use-package for a brief description of each), you can still defer loading with the :defer keyword:

(use-package ace-jump-mode
  :defer t
  :init
  (autoload 'ace-jump-mode "ace-jump-mode" nil t)
  (bind-key "C-." 'ace-jump-mode))
This does exactly the same thing as the following:

(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))
*** Magic handlers

Similar to :mode and :interpreter, you can also use :magic and :magic-fallback to cause certain function to be run if the beginning of a file matches a given regular expression. The difference between the two is that :magic-fallback has a lower priority than :mode. For example:

(use-package pdf-tools
  :load-path "site-lisp/pdf-tools/lisp"
  :magic ("%PDF" . pdf-view-mode)
  :config
  (pdf-tools-install :no-query))
This registers an autoloaded command for pdf-view-mode, defers loading of pdf-tools, and runs pdf-view-mode if the beginning of a buffer matches the string "%PDF".

*** Hooks

The :hook keyword allows adding functions onto hooks, here only the basename of the hook is required. Thus, all of the following are equivalent:

(use-package ace-jump-mode
  :hook prog-mode)

(use-package ace-jump-mode
  :hook (prog-mode . ace-jump-mode))

(use-package ace-jump-mode
  :commands ace-jump-mode
  :init
  (add-hook 'prog-mode-hook #'ace-jump-mode))
And likewise, when multiple hooks should be applied, the following are also equivalent:

(use-package ace-jump-mode
  :hook (prog-mode text-mode))

(use-package ace-jump-mode
  :hook ((prog-mode text-mode) . ace-jump-mode))

(use-package ace-jump-mode
  :hook ((prog-mode . ace-jump-mode)
         (text-mode . ace-jump-mode)))

(use-package ace-jump-mode
  :commands ace-jump-mode
  :init
  (add-hook 'prog-mode-hook #'ace-jump-mode)
  (add-hook 'text-mode-hook #'ace-jump-mode))
The use of :hook, as with :bind, :mode, :interpreter, etc., causes the functions being hooked to implicitly be read as :commands (meaning they will establish interactive autoload definitions for that module, if not already defined as functions), and so :defer t is also implied by :hook.
*** Conditional loading
**** :if
You can use the :if keyword to predicate the loading and initialization of modules.
For example, I only want edit-server running for my main, graphical Emacs, not for other Emacsen I may start at the command line:

(use-package edit-server
  :if window-system
  :init
  (add-hook 'after-init-hook 'server-start t)
  (add-hook 'after-init-hook 'edit-server-start t))
In another example, we can load things conditional on the operating system:

(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :ensure t
  :config
  (exec-path-from-shell-initialize))
**** :disable
The :disabled keyword can turn off a module you're having difficulties with, or stop loading something you're not using at the present time:

(use-package ess-site
  :disabled
  :commands R)
When byte-compiling your .emacs file, disabled declarations are omitted from the output entirely, to accelerate startup times.
**** :when
NOTE: :when is provided as an alias for :if, and :unless foo means the same thing as :if (not foo). For example, the following will also stop :ensure from happening on Mac systems:

(when (memq window-system '(mac ns))
  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize)))
Conditional loading before :preface

If you need to conditionalize a use-package form so that the condition occurs before even the :preface is executed, simply use when around the use-package form itself:
*** Loading packages in sequence
Sometimes it only makes sense to configure a package after another has been loaded, because certain variables or functions are not in scope until that time. This can achieved using an :after keyword that allows a fairly rich description of the exact conditions when loading should occur. Here is an example:

(use-package hydra
  :load-path "site-lisp/hydra")

(use-package ivy
  :load-path "site-lisp/swiper")

(use-package ivy-hydra
  :after (ivy hydra))
In this case, because all of these packages are demand-loaded in the order they occur, the use of :after is not strictly necessary. By using it, however, the above code becomes order-independent, without an implicit depedence on the nature of your init file.

By default, :after (foo bar) is the same as :after (:all foo bar), meaning that loading of the given package will not happen until both foo and bar have been loaded. Here are some of the other possibilities:

:after (foo bar)
:after (:all foo bar)
:after (:any foo bar)
:after (:all (:any foo bar) (:any baz quux))
:after (:any (:all foo bar) (:all baz quux))
When you nest selectors, such as (:any (:all foo bar) (:all baz quux)), it means that the package will be loaded when either both foo and bar have been loaded, or both baz and quux have been loaded.

NOTE: pay attention if you set use-package-always-defer to t, and also use the :after keyword, as you will need to specify how the declared package is to be loaded: e.g., by some :bind. If you're not using one of tho mechanisms that registers autoloads, such as :bind or :hook, and your package manager does not provide autoloads, it's possible that without adding :demand t to those declarations, your package will never be loaded.

*** Prevent loading if dependencies are missing

While the :after keyword delays loading until the dependencies are loaded, the somewhat simpler :requires keyword simply never loads the package if the dependencies are not available at the time the use-package declaration is encountered. By "available" in this context it means that foo is available if (featurep 'foo) evaluates to a non-nil value. For example:

(use-package abbrev
  :requires foo)
This is the same as:

(use-package abbrev
  :if (featurep 'foo))
As a convenience, a list of such packages may be specified:

(use-package abbrev
  :requires (foo bar baz))
For more complex logic, such as that supported by :after, simply use :if and the appropriate Lisp expression.
*** Gathering Statistics

If you'd like to see how many packages you've loaded, what stage of initialization they've reached, and how much aggregate time they've spent (roughly), you can enable use-package-compute-statistics after loading use-package but before any use-package forms, and then run the command M-x use-package-report to see the results. The buffer displayed is a tabulated list. You can use S in a column to sort the rows based on it.
*** (use-package-chords)
The :chords keyword allows you to define key-chord bindings for use-package declarations in the same manner as the :bind keyword.

To enable the extension:

(use-package use-package-chords
  :ensure t
  :config (key-chord-mode 1))
Then you can define your chord bindings in the same manner as :bind using a cons or a list of conses:

(use-package ace-jump-mode
  :chords (("jj" . ace-jump-char-mode)
           ("jk" . ace-jump-word-mode)
           ("jl" . ace-jump-line-mode)))
*** Some timing results
On my Retina iMac, the "Mac port" variant of Emacs 24.4 loads in 0.57s, with around 218 packages configured (nearly all of them lazy-loaded). However, I experience no loss of functionality, just a bit of latency when I'm first starting to use Emacs (due to the autoloading). Since I also use idle-loading for many packages, perceived latency is typically reduced overall.

On Linux, the same configuration loads in 0.32s.

If I don't use Emacs graphically, I can test the absolute minimum times. This is done by running:

time emacs -l init.elc -batch --eval '(message "Hello, world!")'
On the Mac I see an average of 0.36s for the same configuration, and on Linux 0.26s.
* TODO натройка емака
** TODO Vims Tabs
*** Таб должен взаимодействоать с полнооконым режимом
если фул скри добовляет окна 4 с права
и помнит для каждого что в нём было
по доп нажатию фула в окне меняет местами содержания из доп окна и основного
** TODO настроить для работы с JS
   Найти файил с туториалом по настройке
   [[https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html]]
*** Mods
**** Indium
     https://github.com/NicolasPetton/Indium
A JavaScript development environment for Emacs.

Indium connects to a browser tab or nodejs process and provides many features for JavaScript development, including:

    a REPL (with auto completion) & object inspection;
    an inspector, with history and navigation;
    a scratch buffer (M-x indium-scratch);
    JavaScript evaluation in JS buffers with indium-interaction-mode;
    a stepping Debugger, similar to edebug, or cider.

** TODO настроить редактор 
*** TODO Понять что делать с языком 
- заменить в ивеле команду замены чтоб она понимала язык
*** TODO добовлять один символ
- [ ] энтер2
- [ ] 2пробел
- [ ] пробел + i\a(I\A)
** TODO Настроить емак для работы с Си 
 1) сварачивание
 2) авто дополнение
 3) снипиты
 4) подсветка
    + кода
    + скобок
    + курсора при альттабинге
 5) квикфикс
 6) оргмод литпрограминг
    - импор сорса в один файл
    - создание нового файла на основе
    - создание структуры папок
    - создание всего проеката на основе стуктурного описания (файлов и папок). с возможностью открытия следуших 
*** примеры удачных реализаций
**** Run shell command and jump to error workflow

 Hi all,

 I have recently started using Emacs(Doom) more and more seriously and really liking the experience. I have come so far that I feel pretty comfortable to use it at work without slowing down my efficiency that much. One aspect of my Vim workflow that I haven't found a good solution to however is building my project (C++) and running unit tests.

 With Vim I am used to using the plugin Asyncrun, https://github.com/skywind3000/asyncrun.vim. This plugin makes it possible to execute shell commands, typically calling the python script that runs build/ or the unit tests and printing the progress in the quickfix window. It would automatically parse the text and find errors and where they are located making it possible to use my keybinding for navigating the quickfix list to easily jump to an error, solve the issue and jump to the next one.

 So far I have only figured out a solution where I open a multiterm window and enable compilation-shell-minor-mode. Run the build command, go back to evil normal mode, M-x compilation-next-error-function. Switch window to the window with the code, fix the error, go to normal mode, switch back to shell window and repeat the process. This seems a little inefficient so I am sure there are better solutions out there but my Emacs skills are very low :)

 So I wonder what your workflows are like in Emacs? :)

 How about

 M-x compile RET whatever-command
 C-x `

 There is also projectile that provides projectile-compile-project and projectile-test-project that also work with next-error (C-x `)
 level 2
 squirelpower
 2 points ·
 1 year ago

 That's perfect, works exactly like I want it, many thanks! :)
 level 2
 oantolin
 1 point ·
 1 year ago
 · edited 1 year ago

 I prefer the keybinding M-g M-n for next-error and its companion M-g M-p for previous-error.
 level 2
 TabCompletion
 1 point ·
 1 year ago
 · edited 1 year ago

 I bound F6 for my next-error command. I also have a mondo compilation-error-regexp-alist regex to match errors:
** TODO Добавить функционал 
*** DONE пробел символ
	CLOSED: [2019-08-06 Вт 06:03]
*** ентер для пост символа
*** сдвиг строк
*** копия строк
** TODO работа с серийным портом
 - Передовать команды из буфера в открытый порт
 - посмотреть как настроен емак в видео с форсом
 - понять как реконектится наиболее быстро
   - командой
   - сочетание кнопок
   - строкой из скреч буфера
** Моды для емака
*** org-journal 
*** Done Ivy mods 
	CLOSED: [2019-09-13 Пт 05:52]
    [[https://www.youtube.com/watch?v=AaUlOH4GTCs]] youtube from where I get this 
    https://truthseekers.io/lessons/how-to-use-ivy-swiper-counsel-in-emacs-for-noobs/ text version lesson
    Ivy, Counsel, and Swiper are great if you can figure out how to use them!
 Luckily they are all pretty simple. In fact, you can just... install them and copy/paste some stuff and be on your way!
 I wanted to understand these emacs packages though, and that's a little more challenging.
    - ~Ivy~     :: is a package that helps you search. It helps you do things in M-x, or find file, and Dired, etc... Anything where you look for something in Emacs, Ivy can come to the rescue and help you type less. For example. Let's say I want to look through some Melpa packages. No longer do I have to type package-list-packages. Instead, I can just type "pa li packa" and Ivy will find all the results that match the search terms. Using spaces, you can target certain parts of what you're looking for. It just helps you type less. Ivy doesn't rely on anything, but
    - ~Swiper~  :: will automatically pull in Ivy when it's installed, because Swiper needs Ivy. Swiper does the same thing as Ivy, but replaces isearch, so you can use ivy features when searching through text.
*** DONE use-package
	CLOSED: [2019-09-13 Пт 05:52]


The easiest way is to install use-package.

(package-initialize)
(require 'package)
(add-to-list 'package-archives
    '("melpa" . "http://melpa.milkbox.net/packages/") t)

(dolist (package '(use-package))
   (unless (package-installed-p package)
       (package-install package)))

Then

 (use-package paredit
   :ensure t)

The :ensure t is what ensures that the package is installed.

To just load ensure multiple packages are install

(dolist (package '(package-a package-b package-c))
 (unless (package-installed-p package)
   (package-install package))
   (require package))))
*** emacs-purpose
https://github.com/bmag/emacs-purpose
Purpose ("window-purpose" on MELPA) provides a new window management system for Emacs, which gives you a better control over where Emacs displays buffers.

With Purpose, each buffer has a configurable "purpose" and each window can interactively be dedicated to a certain "purpose". When you dedicate a window (C-c , d), Purpose makes sure that this window will be used only for buffers which have the same purpose as the buffer that is currently displayed in that window. The purpose of a buffer can be customized via the variables purpose-user-mode-purposes, purpose-user-name-purposes, purpose-user-regexp-purposes and purpose-use-default-configuration (see the wiki).
*** ~Counsel~ 
:: gives you extra functions that aren't normally available. For example: You can open a buffer or file in a new window.
   
*** hidra mod 
    https://github.com/abo-abo/hydra
This is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common prefix - a Hydra.
*** Mover mods
**** Avy mods
     - Avy :: is one of my favorite packages in Emacs.
     https://truthseekers.io/lessons/avy-emacs-tutorial-moving-around-emacs-quickly/
     Learning how to use Avy is one of the easiest and fastest ways to improve your efficiency in Emacs. The Avy Emacs package allows you to quickly get to any visible point in an Emacs buffer, window, or frame. By using one of the functions Avy provides, you define a search term, and Avy provides a "Tree" list of options to choose from. You choose the point you want your cursor to move to by typing one or two characters and BOOM, your cursor is exactly where you need it. The best part about Avy is how simple it is. You only need one or two key bindings, and you're good to go.
**** DONE Fast Emacs Window & Frame switching with WindMove & FrameMove 
	 CLOSED: [2019-08-06 Вт 05:49]
https://truthseekers.io/lessons/an-introduction-to-emacs-everything-you-need-to-know-to-get-started/
;; Remap windmove keys to home keys
(global-set-key (kbd "M-h") 'windmove-left)
(global-set-key (kbd "M-j") 'windmove-down)
(global-set-key (kbd "M-k") 'windmove-up)
(global-set-key (kbd "M-l") 'windmove-right)
*** quickfix-mode 
https://github.com/emacsmirror/quickfix-mode
    quickfix-mode consists of a series of quickfixes registered for your favourite programming mode. 
These will suggest a possible suggestion depending on the error (or warning) reported for flymake.
 Oh yes, _quickfix-mode depends_ on ~flymake~ (and ~popup~).
 https://github.com/auto-complete/popup-el
    Quickfix in action
Let's say flymake reports some errors in your code (in this case in erlang)
flymake errors and warnings
bar is undefined
C-c C-f to the rescue...
quickfix suggest it could define the function for us
selecting...and voila!
and the function is defined so that we can work on it
Exporting unused functions works too.
foo is unused :-o
quickfix to the rescue
and we're good!
*** Emacs Support for reStructuredText
    reStructuredText is a syntax for simple text files that allows a tool set - docutils - to extract generic document structure. For people who use Emacs, there is a package that adds a major mode that supports editing the syntax of reStructuredText: rst.el. This document describes the features it provides, and how to setup your Emacs to use them and how to invoke them.
    ~reStructuredText~ is an easy-to-read, what-you-see-is-what-you-get plaintext markup syntax and parser system. It is useful for in-line program documentation (such as Python docstrings), for quickly creating simple web pages, and for standalone documents. reStructuredText is designed for extensibility for specific application domains. The reStructuredText parser is a component of Docutils. reStructuredText is a revision and reinterpretation of the StructuredText and Setext lightweight markup systems.

The primary goal of reStructuredText is to define and implement a markup syntax for use in Python docstrings and other documentation domains, that is readable and simple, yet powerful enough for non-trivial use. The intended purpose of the markup is the conversion of reStructuredText documents into useful structured data formats.

See statemachine.py for an example of a Python module fully documented using reStructuredText.
*** org-id  
*** Helm
http://tuhdo.github.io/helm-intro.html
https://github.com/emacs-helm/helm/wiki

Helm is the successor of Anything. It’s a generic framework for quickly accessing stuff within Emacs. Or: an “incremental completion and selection narrowing framework for Emacs.”

    Source available from GitHub
    Documentation on its own Helm Wiki
    This article is a nice introduction to Helm's many features

Other packages:

    HelmSwoop – like occur, but live
** TODO Add lisp code
*** Folding on Org Mode vs C mode
If you want to exclude one specific mode, you can do the following:

(global-set-key (kbd "<C-S-down>") 'move-line-down) 

to make it globally available, and

(define-key KEYMAP (kbd "<C-S-down>") nil) 

to exclude one mode where KEYMAP is the name name of the mode, followed by "mode-map" (e.g. ess-mode-map). You could also bind the original thing to the key instead of nil.
shareimprove this answer
** Exempls of cofig 
*** класная визуальная тема
**** Jessica Hamrick
  http://www.jesshamrick.com/2012/09/18/emacs-as-a-python-ide/
  ;--------------------;
  ;;; User Interface ;;;
  ;--------------------;

  ; always use spaces, not tabs, when indenting
  (setq indent-tabs-mode nil)

  ; ignore case when searching
  (setq case-fold-search t)

  ; require final newlines in files when they are saved
  (setq require-final-newline t)

  ; window modifications
  (global-set-key (kbd "S-C-") 'shrink-window-horizontally)
  (global-set-key (kbd "S-C-") 'enlarge-window-horizontally)
  (global-set-key (kbd "S-C-") 'shrink-window)
  (global-set-key (kbd "S-C-") 'enlarge-window)

  ; set the keybinding so that you can use f4 for goto line
  (global-set-key &#91;f4&#93; 'goto-line)

  ;----------------------;
  ;;; Windows & Frames ;;;
  ;----------------------;

  ; language
  (setq current-language-environment "English")

  ; don't show the startup screen
  (setq inhibit-startup-screen t)
  ; don't show the menu bar
  (menu-bar-mode nil)
  ; don't show the tool bar
  (require 'tool-bar)
  (tool-bar-mode nil)
  ; don't show the scroll bar
  (scroll-bar-mode nil)

  ; number of characters until the fill column
  (setq fill-column 70)

  ; specify the fringe width for windows -- this sets both the left and
  ; right fringes to 10
  (require 'fringe)
  (fringe-mode 10)

  ; lines which are exactly as wide as the window (not counting the
  ; final newline character) are not continued. Instead, when point is
  ; at the end of the line, the cursor appears in the right fringe.
  (setq overflow-newline-into-fringe t)

  ; each line of text gets one line on the screen (i.e., text will run
  ; off the left instead of wrapping around onto a new line)
  (setq truncate-lines t)
  ; truncate lines even in partial-width windows
  (setq truncate-partial-width-windows t)

  ; display line numbers to the right of the window
  (global-linum-mode t)
  ; show the current line and column numbers in the stats bar as well
  (line-number-mode t)
  (column-number-mode t)

  ;------------;
  ;;; Cursor ;;;
  ;--------------------;
  ;;; User Interface ;;;
  ;--------------------;

  ; always use spaces, not tabs, when indenting
  (setq indent-tabs-mode nil)

  ; ignore case when searching
  (setq case-fold-search t)

  ; require final newlines in files when they are saved
  (setq require-final-newline t)

  ; window modifications
  (global-set-key (kbd "S-C-") 'shrink-window-horizontally)
  (global-set-key (kbd "S-C-") 'enlarge-window-horizontally)
  (global-set-key (kbd "S-C-") 'shrink-window)
  (global-set-key (kbd "S-C-") 'enlarge-window)

  ; set the keybinding so that you can use f4 for goto line
  (global-set-key &#91;f4&#93; 'goto-line)

  ;----------------------;
  ;;; Windows & Frames ;;;
  ;----------------------;

  ; language
  (setq current-language-environment "English")

  ; don't show the startup screen
  (setq inhibit-startup-screen t)
  ; don't show the menu bar
  (menu-bar-mode nil)
  ; don't show the tool bar
  (require 'tool-bar)
  (tool-bar-mode nil)
  ; don't show the scroll bar
  (scroll-bar-mode nil)

  ; number of characters until the fill column
  (setq fill-column 70)

  ; specify the fringe width for windows -- this sets both the left and
  ; right fringes to 10
  (require 'fringe)
  (fringe-mode 10)

  ; lines which are exactly as wide as the window (not counting the
  ; final newline character) are not continued. Instead, when point is
  ; at the end of the line, the cursor appears in the right fringe.
  (setq overflow-newline-into-fringe t)

  ; each line of text gets one line on the screen (i.e., text will run
  ; off the left instead of wrapping around onto a new line)
  (setq truncate-lines t)
  ; truncate lines even in partial-width windows
  (setq truncate-partial-width-windows t)

  ; display line numbers to the right of the window
  (global-linum-mode t)
  ; show the current line and column numbers in the stats bar as well
  (line-number-mode t)
  (column-number-mode t)

  ;------------;
  ;;; Cursor ;;;
  ;------------;

  ; highlight the current line
  (require 'highlight-current-line)
  (global-hl-line-mode t)
  (setq highlight-current-line-globally t)
  (setq highlight-current-line-high-faces nil)
  (setq highlight-current-line-whole-line nil)
  (setq hl-line-face (quote highlight))

  ; don't blink the cursor
  (blink-cursor-mode nil)

  ; make sure transient mark mode is enabled (it should be by default,
  ; but just in case)
  (transient-mark-mode t)

  ; turn on mouse wheel support for scrolling
  (require 'mwheel)
  (mouse-wheel-mode t)

  ;-------------------------;
  ;;; Syntax Highlighting ;;;
  ;-------------------------;

  ; text decoration
  (require 'font-lock)
  (setq font-lock-maximum-decoration t)
  (global-font-lock-mode t)
  (global-hi-lock-mode nil)
  (setq jit-lock-contextually t)
  (setq jit-lock-stealth-verbose t)

  ; if there is size information associated with text, change the text
  ; size to reflect it
  (size-indication-mode t)

  ; highlight parentheses when the cursor is next to them
  (require 'paren)
  (show-paren-mode t)

  ;-----------------;
  ;;; Color Theme ;;;
  ;-----------------;

  ; use the "Subtle Hacker" color theme as a base for the custom scheme
  (require 'color-theme)
  (color-theme-initialize)
  (setq color-theme-is-global t)
  (color-theme-subtle-hacker)

  (custom-set-faces
   '(default ((t (:overline nil :inherit nil :stipple nil :background "gray2"
                  :foreground "#FFF991" :inverse-video nil :box nil
                  :strike-through nil :underline nil
                  :slant normal :weight normal :height 83 :width normal
                  :foundry "unknown" :family "DejaVu Sans Mono"))))
   '(border ((t nil)))
   '(cursor ((t (:background "firebrick1" :foreground "black"))))
   '(font-lock-comment-delimiter-face
      ((default (:inherit font-lock-comment-face :weight ultra-bold))
      (((class color) (min-colors 16)) nil)))
   '(font-lock-comment-face ((t (:foreground "lime green"))))
   '(font-lock-doc-face ((t (:foreground "tomato" :slant italic))))
   '(font-lock-function-name-face
      ((t (:foreground "deep sky blue" :underline t :weight bold))))
   '(font-lock-keyword-face ((t (:foreground "gold" :weight bold))))
   '(font-lock-string-face ((t (:foreground "tomato" :slant italic))))
   '(fringe ((nil (:background "black"))))
   '(highlight ((t (:background "khaki1" :foreground "black"
					:box (:line-width -1 :color "firebrick1")))))
   '(highlight-current-line-face ((t (:inherit highlight))))
   '(lazy-highlight ((t (:background "paleturquoise" :foreground "black"))))
   '(link ((t (:foreground "DodgerBlue3" :underline t))))
   '(menu ((t (:background "gray2" :foreground "#FFF991"))))
   '(minibuffer-prompt ((t (:foreground "royal blue"))))
   '(mode-line ((t (:background "dark olive green"
					:foreground "dark blue"
					:box (:line-width -1 :color "gray75")
					:weight bold))))
   '(mode-line-buffer-id ((t (:background "dark olive green" :foreground "beige"))))
   '(mode-line-highlight ((((class color) (min-colors 88)) nil)))
   '(mode-line-inactive ((t (:background "dark olive green"
							 :foreground "dark khaki" :weight light))))
   '(mouse ((t (:background "Grey" :foreground "black"))))
   '(trailing-whitespace ((((class color) (background dark))
							(:background "firebrick1")))))

  ; make sure the frames have the dark background mode by default
  (setq default-frame-alist (quote (
	(frame-background-mode . dark)
  )))

  ;------------;

  ; highlight the current line
  (require 'highlight-current-line)
  (global-hl-line-mode t)
  (setq highlight-current-line-globally t)
  (setq highlight-current-line-high-faces nil)
  (setq highlight-current-line-whole-line nil)
  (setq hl-line-face (quote highlight))

  ; don't blink the cursor
  (blink-cursor-mode nil)

  ; make sure transient mark mode is enabled (it should be by default,
  ; but just in case)
  (transient-mark-mode t)

  ; turn on mouse wheel support for scrolling
  (require 'mwheel)
  (mouse-wheel-mode t)

  ;-------------------------;
  ;;; Syntax Highlighting ;;;
  ;-------------------------;

  ; text decoration
  (require 'font-lock)
  (setq font-lock-maximum-decoration t)
  (global-font-lock-mode t)
  (global-hi-lock-mode nil)
  (setq jit-lock-contextually t)
  (setq jit-lock-stealth-verbose t)

  ; if there is size information associated with text, change the text
  ; size to reflect it
  (size-indication-mode t)

  ; highlight parentheses when the cursor is next to them
  (require 'paren)
  (show-paren-mode t)

  ;-----------------;
  ;;; Color Theme ;;;
  ;-----------------;

  ; use the "Subtle Hacker" color theme as a base for the custom scheme
  (require 'color-theme)
  (color-theme-initialize)
  (setq color-theme-is-global t)
  (color-theme-subtle-hacker)

  (custom-set-faces
   '(default ((t (:overline nil :inherit nil :stipple nil :background "gray2"
                  :foreground "#FFF991" :inverse-video nil :box nil
                  :strike-through nil :underline nil
                  :slant normal :weight normal :height 83 :width normal
                  :foundry "unknown" :family "DejaVu Sans Mono"))))
   '(border ((t nil)))
   '(cursor ((t (:background "firebrick1" :foreground "black"))))
   '(font-lock-comment-delimiter-face
      ((default (:inherit font-lock-comment-face :weight ultra-bold))
      (((class color) (min-colors 16)) nil)))
   '(font-lock-comment-face ((t (:foreground "lime green"))))
   '(font-lock-doc-face ((t (:foreground "tomato" :slant italic))))
   '(font-lock-function-name-face
      ((t (:foreground "deep sky blue" :underline t :weight bold))))
   '(font-lock-keyword-face ((t (:foreground "gold" :weight bold))))
   '(font-lock-string-face ((t (:foreground "tomato" :slant italic))))
   '(fringe ((nil (:background "black"))))
   '(highlight ((t (:background "khaki1" :foreground "black"
					:box (:line-width -1 :color "firebrick1")))))
   '(highlight-current-line-face ((t (:inherit highlight))))
   '(lazy-highlight ((t (:background "paleturquoise" :foreground "black"))))
   '(link ((t (:foreground "DodgerBlue3" :underline t))))
   '(menu ((t (:background "gray2" :foreground "#FFF991"))))
   '(minibuffer-prompt ((t (:foreground "royal blue"))))
   '(mode-line ((t (:background "dark olive green"
					:foreground "dark blue"
					:box (:line-width -1 :color "gray75")
					:weight bold))))
   '(mode-line-buffer-id ((t (:background "dark olive green" :foreground "beige"))))
   '(mode-line-highlight ((((class color) (min-colors 88)) nil)))
   '(mode-line-inactive ((t (:background "dark olive green"
							 :foreground "dark khaki" :weight light))))
   '(mouse ((t (:background "Grey" :foreground "black"))))
   '(trailing-whitespace ((((class color) (background dark))
							(:background "firebrick1")))))

  ; make sure the frames have the dark background mode by default
  (setq default-frame-alist (quote (
	(frame-background-mode . dark)
  )))

** Exempls of Code 
*** archive todos from org agenda
(defun mark-done-and-archive ()
   (interactive)
   (org-todo 'done)
   (org-archive-subtree))
 (define-key org-mode-map "\C-c\C-x\C-s" 'mark-done-and-archive)
 
* TODO Оргаизовать Org Mod
** TODO Разобратся с агендой
*** DONE разобрать фаил по подфайлам
	CLOSED: [2019-08-06 Вт 06:05]
*** DONE понять как разбить на карты повторного выполнения
	CLOSED: [2019-08-06 Вт 06:04]
*** настроить агеду чтоб показывать только глаыный фаили и зависиый родитель
*** DONE что делать с выполненыемт заданиями чтоб не замусоривать 
	CLOSED: [2019-08-06 Вт 06:04]
*** keys add agenda file
   C-c [     (org-agenda-file-to-front)

    Add current file to the list of agenda files. The file is added to the front of the list. If it was already in the list, it is moved to the front. With a prefix argument, file is added/moved to the end. 
C-c ]     (org-remove-file)

    Remove current file from the list of agenda files. 
   SCHEDULED: <2018-10-25 Чт 09:40>
*** comands to add agenda file
   (setq org-agenda-files '("~/org"))
   (setq org-agenda-files '("~/ORG/start.org"))
   (setq org-agenda-files (quote ("~/ORG/start.org")))
